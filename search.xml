<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Part 4.2 背包动态规划题解</title>
    <url>/luogu4-2-problems/</url>
    <content><![CDATA[<h1 id="Part-4-2-背包动态规划题解"><a href="#Part-4-2-背包动态规划题解" class="headerlink" title="Part 4.2 背包动态规划题解"></a>Part 4.2 背包动态规划题解</h1><h2 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h2><h3 id="题目链接：-NOIP2005-普及组-采药-洛谷"><a href="#题目链接：-NOIP2005-普及组-采药-洛谷" class="headerlink" title="题目链接：[NOIP2005 普及组] 采药 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1048">[NOIP2005 普及组] 采药 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>01背包模板题，必须记住并且理解。复杂度 $O(n^2)$</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> t,n,w[<span class="number">105</span>],v[<span class="number">105</span>],dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=w[i];j--) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1060-开心的金明"><a href="#P1060-开心的金明" class="headerlink" title="P1060 开心的金明"></a>P1060 开心的金明</h2><h3 id="题目链接：-NOIP2006-普及组-开心的金明-洛谷"><a href="#题目链接：-NOIP2006-普及组-开心的金明-洛谷" class="headerlink" title="题目链接：[NOIP2006 普及组] 开心的金明 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1060">[NOIP2006 普及组] 开心的金明 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>妈妈昨天对金明说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v[j]$，重要度为 $w[j]$，共选中了 $k$ 件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：</p>
<p>$v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[j_k] \times w[j_k]$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>01背包模型模板题，方法与采药相同。复杂度 $O(n^2)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> t,n,w[<span class="number">30</span>],v[<span class="number">30</span>],dp[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        v[i]*=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=w[i];j--) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[t]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1855-榨取kkksc03"><a href="#P1855-榨取kkksc03" class="headerlink" title="P1855 榨取kkksc03"></a>P1855 榨取kkksc03</h2><h3 id="题目链接：榨取kkksc03-洛谷"><a href="#题目链接：榨取kkksc03-洛谷" class="headerlink" title="题目链接：榨取kkksc03 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1855">榨取kkksc03 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>01背包模型的变形，多加了一种影响因素，只需在原有基础上多加一维循环即可。复杂度 $O(NMT)$</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ww,tt,w[<span class="number">105</span>],t[<span class="number">105</span>],dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;ww,&amp;tt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=ww;j&gt;=w[i];j--)<span class="comment">//金钱</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=tt;k&gt;=t[i];k--)<span class="comment">//时间</span></span><br><span class="line">                dp[j][k]=<span class="built_in">max</span>(dp[j][k],dp[j-w[i]][k-t[i]]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[ww][tt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5020-货币系统"><a href="#P5020-货币系统" class="headerlink" title="P5020 货币系统"></a>P5020 货币系统</h2><h3 id="题目链接：-NOIP2018-提高组-货币系统-洛谷"><a href="#题目链接：-NOIP2018-提高组-货币系统-洛谷" class="headerlink" title="题目链接：[NOIP2018 提高组] 货币系统 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5020">[NOIP2018 提高组] 货币系统 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 </p>
<p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 </p>
<p>两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p>
<p>现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>参照筛法的思想和完全背包统计方案数的做法，用已有的数筛去能被表达的数，剩余的数则为最小的集合。复杂度 $O(NM)$ </p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">105</span>],dp[<span class="number">25005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);<span class="comment">//集合内最小的数必然被保留</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//完全背包统计方案的做法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[a[i]]) cnt++;<span class="comment">//判断是否被筛去</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=a[n];j++)</span><br><span class="line">                dp[j]+=dp[j-a[i]];<span class="comment">//方案数大于0则被筛去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a>P1757 通天之分组背包</h2><h3 id="题目链接：通天之分组背包-洛谷"><a href="#题目链接：通天之分组背包-洛谷" class="headerlink" title="题目链接：通天之分组背包 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1757">通天之分组背包 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>一天，小 A 去远游，却发现他的背包不同于 01 背包，他的物品大致可分为 k 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>分组背包模型模板题</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> ww,n,mm,w[<span class="number">1005</span>],v[<span class="number">1005</span>],dp[<span class="number">1005</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[<span class="number">1002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ww,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;w[i],&amp;v[i],&amp;x);</span><br><span class="line">        p[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">        mm=<span class="built_in">max</span>(mm,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mm;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=ww;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;p[i].<span class="built_in">size</span>();k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=w[p[i][k]]) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[p[i][k]]]+v[p[i][k]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[ww]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1064-金明的预算方案"><a href="#P1064-金明的预算方案" class="headerlink" title="P1064 金明的预算方案"></a>P1064 金明的预算方案</h2><h3 id="题目链接：-NOIP2006-提高组-金明的预算方案-洛谷"><a href="#题目链接：-NOIP2006-提高组-金明的预算方案-洛谷" class="headerlink" title="题目链接：[NOIP2006 提高组] 金明的预算方案 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1064">[NOIP2006 提高组] 金明的预算方案 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>妈妈昨天对金明说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
<table>
<thead>
<tr>
<th align="center">主件</th>
<th align="center">附件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电脑</td>
<td align="center">打印机，扫描仪</td>
</tr>
<tr>
<td align="center">书柜</td>
<td align="center">图书</td>
</tr>
<tr>
<td align="center">书桌</td>
<td align="center">台灯，文具</td>
</tr>
<tr>
<td align="center">工作椅</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p>
<p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>题目是一道有依赖的分组背包问题，对于每个主件以及它的配件，根据题意可以组合成分组背包的同一组内的不同的物品，然后套用分组背包的解决方案即可解决。</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m, n, mw[<span class="number">33333</span>], mv[<span class="number">33333</span>], fw[<span class="number">33333</span>][<span class="number">3</span>], fv[<span class="number">33333</span>][<span class="number">3</span>], f[<span class="number">33333</span>], v, p, q;</span><br><span class="line"><span class="comment">//mw主件重量，mv主件价值，fw主件对应的附件重量，fv主副价值，n总重量，m总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!q) &#123; <span class="comment">//如果是主件</span></span><br><span class="line">            mw[i] = v; <span class="comment">//主件重量</span></span><br><span class="line">            mv[i] = v * p; <span class="comment">//主件价值与重量乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果是附件</span></span><br><span class="line">            fw[q][<span class="number">0</span>]++;<span class="comment">//记录主件的附件个数（只记录在fw就行，fv那里没用</span></span><br><span class="line">            fw[q][fw[q][<span class="number">0</span>]] = v; <span class="comment">//主件的个数是用来确定该附件应该填在第一个还是第二个格子里</span></span><br><span class="line">            fv[q][fw[q][<span class="number">0</span>]] = v * p; <span class="comment">//（是第一个还是第二个附件）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= mw[i]; j--) &#123; <span class="comment">//01背包模板</span></span><br><span class="line">            <span class="comment">//每一个if的前提是背包能不能装下该物品</span></span><br><span class="line">            <span class="comment">//情况1：只要主件 和啥都不要比较</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i]] + mv[i]);</span><br><span class="line">            <span class="comment">//情况2：主件和附件1 和上面选出的较大值比较</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">1</span>])f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">1</span>]] + mv[i] + fv[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//情况3：主件和附件2 和上面选出的较大值比较</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">2</span>])f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">2</span>]] + mv[i] + fv[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">//情况4：都要</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">1</span>] + fw[i][<span class="number">2</span>])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">1</span>] - fw[i][<span class="number">2</span>]] + mv[i] + fv[i][<span class="number">1</span>] + fv[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//输出在价值为n时能得到的最大值</span></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2946-Cow-Frisbee-Team-S"><a href="#P2946-Cow-Frisbee-Team-S" class="headerlink" title="P2946 Cow Frisbee Team S"></a>P2946 Cow Frisbee Team S</h2><h3 id="题目链接：-USACO09MAR-Cow-Frisbee-Team-S-洛谷"><a href="#题目链接：-USACO09MAR-Cow-Frisbee-Team-S-洛谷" class="headerlink" title="题目链接：[USACO09MAR]Cow Frisbee Team S - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2946">[USACO09MAR]Cow Frisbee Team S - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>约翰打算从他家的 $N$ 头奶牛中选出一支队伍。</p>
<p>每只奶牛的能力为整数，第 $i$ 头奶牛的能力为$R_i$ 。飞盘队的队员数量不能少于 $1$ 、大于$N$。一支队伍的总能力就是所有队员能力的总和。约翰比较迷信，他的幸运数字是 $F$ ，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>类似 01 背包的求方案数问题，对于每头牛都有选或不选两种选择，用 $dp[i][j]$ 表示在前 $i$ 头牛中选择的和（mod F）为 $j$ 的方案数。</p>
<p>对于 $dp[i][j]$</p>
<ul>
<li><p>不选 $i$ ，则为前 $i-1$ 头牛中和为 $j$ 的方案数 $dp[i-1][j]$</p>
</li>
<li><p>选 $j$ ，则为前 $i-1$ 头牛中与 $a[i]$ 相加为 $j$ 的数量，即 $dp[i-1][j-a[i]]$</p>
</li>
<li><p>综合上面的选择方案，转移方程为 $dp[i][j]=dp[i][j]+dp[i-1][j]+dp[i-1][(j-a[i]+m)\%m]$</p>
</li>
<li><p>$j-a[i]$ 可能为负数，由于是考虑取模问题，故仅需加上模数再取模即可</p>
</li>
</ul>
<p>复杂度 $O(nm)$</p>
<h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">2005</span>],dp[<span class="number">2005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);a[i]%=m;dp[i][a[i]]=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][(j-a[i]+m)%m])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1156-垃圾陷阱"><a href="#P1156-垃圾陷阱" class="headerlink" title="P1156 垃圾陷阱"></a>P1156 垃圾陷阱</h2><h3 id="题目链接：垃圾陷阱"><a href="#题目链接：垃圾陷阱" class="headerlink" title="题目链接：垃圾陷阱"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱</a></h3><h3 id="题面：-7"><a href="#题面：-7" class="headerlink" title="题面："></a>题面：</h3><p>卡门――农夫约翰极其珍视的一条 <code>Holsteins</code> 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内没有进食，卡门就将饿死。</p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>类似于 01 背包，但是不选会对状态造成影响，把高度当作是动态规划的边界，$f[i]$ 表示高度为 $i$ 时的最大生命值，采用刷表法对未知变量进行更新。</p>
<h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="type">int</span> n,D;</span><br><span class="line"><span class="type">int</span> f[maxn*<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,health,hight;</span><br><span class="line">&#125;r[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Rub a,Rub b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;D,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;r[i].t,&amp;r[i].health,&amp;r[i].hight);</span><br><span class="line">    <span class="built_in">sort</span>(r+<span class="number">1</span>,r+<span class="number">1</span>+n,cmp);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=D;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(f[j] &gt;= r[i].t)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j+r[i].hight&gt;=D)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r[i].t);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[j+r[i].hight]=<span class="built_in">max</span>(f[j+r[i].hight],f[j]);</span><br><span class="line">                f[j]+=r[i].health;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5322-排兵布阵"><a href="#P5322-排兵布阵" class="headerlink" title="P5322 排兵布阵"></a>P5322 排兵布阵</h2><h3 id="题目链接：-BJOI2019-排兵布阵-洛谷"><a href="#题目链接：-BJOI2019-排兵布阵-洛谷" class="headerlink" title="题目链接：[BJOI2019] 排兵布阵 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5322">[BJOI2019] 排兵布阵 - 洛谷</a></h3><h3 id="题面：-8"><a href="#题面：-8" class="headerlink" title="题面："></a>题面：</h3><p>小 C 正在玩一款排兵布阵的游戏。在游戏中有 $n$ 座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 $m$ 名士兵，可以向第 $i$ 座城堡派遣 $a_i$ 名士兵去争夺这个城堡，使得总士兵数不超过 $m$。   </p>
<p>如果一名玩家向第 $i$ 座城堡派遣的士兵数<strong>严格</strong>大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得 $i$ 分。  </p>
<p>现在小 C 即将和其他 $s$ 名玩家两两对战，这 $s$ 场对决的派遣士兵方案必须相同。小 C 通过某些途径得知了其他 $s$ 名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。   </p>
<p>由于答案可能不唯一，你只需要输出小 C 总分的最大值。</p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>非常好的一道分组背包模型题，可以将每个城堡看做是一组，每个玩家是一个组内的物品。组内排序后，物品的价值即为所获分数 $i∗s$，体积为攻打所需兵力 $2∗i_s​+1$，而背包体积就是兵力 $m$</p>
<h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> s,n,m,a[<span class="number">105</span>][<span class="number">105</span>],dp[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[j][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">sort</span>(a[i]+<span class="number">1</span>,a[i]+<span class="number">1</span>+s);<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//分组背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">2</span>*a[i][k]+<span class="number">1</span>) dp[j]=<span class="built_in">max</span>(dp[j],dp[j<span class="number">-2</span>*a[i][k]<span class="number">-1</span>]+k*i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[m]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.1 线性动态规划题解</title>
    <url>/luogu4-1-problems/</url>
    <content><![CDATA[<h1 id="Part-4-1-线性动态规划题解"><a href="#Part-4-1-线性动态规划题解" class="headerlink" title="Part 4.1 线性动态规划题解"></a>Part 4.1 线性动态规划题解</h1><h2 id="P1216-数字三角形"><a href="#P1216-数字三角形" class="headerlink" title="P1216 数字三角形"></a>P1216 数字三角形</h2><h3 id="题目链接：-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷"><a href="#题目链接：-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷" class="headerlink" title="题目链接：[USACO1.5][IOI1994]数字三角形 Number Triangles - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1216">[USACO1.5][IOI1994]数字三角形 Number Triangles - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        <span class="number">7</span> </span><br><span class="line">      <span class="number">3</span>   <span class="number">8</span> </span><br><span class="line">    <span class="number">8</span>   <span class="number">1</span>   <span class="number">0</span> </span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>在上面的样例中,从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每一个位置所能得到的最大值均由上一层的对应位置的最大值转移而来，故考虑用 $f[i][j]$ 表示到达第 $i$ 层第 $j$ 个位置时的最大值，复杂度 $O(n^2)$</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>],ma;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);<span class="comment">//读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)<span class="comment">//因为只用到上一层加和结果，所以没有另开数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>) a[i][j]+=a[i<span class="number">-1</span>][j];<span class="comment">//考虑边界情况，最左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==i) a[i][j]+=a[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//考虑边界情况，最右边</span></span><br><span class="line">            <span class="keyword">else</span> a[i][j]+=<span class="built_in">max</span>(a[i<span class="number">-1</span>][j<span class="number">-1</span>],a[i<span class="number">-1</span>][j]);<span class="comment">//比较最大值，进行选择</span></span><br><span class="line">            <span class="keyword">if</span>(i==n) ma=<span class="built_in">max</span>(ma,a[i][j]);<span class="comment">//记录最后一行的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1020-导弹拦截"><a href="#P1020-导弹拦截" class="headerlink" title="P1020 导弹拦截"></a>P1020 导弹拦截</h2><h3 id="题目链接：-NOIP1999-普及组-导弹拦截-洛谷"><a href="#题目链接：-NOIP1999-普及组-导弹拦截-洛谷" class="headerlink" title="题目链接：[NOIP1999 普及组] 导弹拦截 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1020">[NOIP1999 普及组] 导弹拦截 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>对于第一个问题，答案为求解最长不上升子序列的长度，这是一个经典的线性动态规划模型</p>
<p>对于第二个问题，抽象出来就是考虑把一个数列划分成最少数量的最长不上升子序列，解决这个问题需要引入一个定理，<strong>Dilworth</strong>定理</p>
<ul>
<li><p><strong>Dilworth</strong> 定理：对于一个偏序集，最少链划分等于最长反链长度</p>
</li>
<li><p><strong>Dilworth</strong> 定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度</p>
</li>
</ul>
<p>简而言之，将一个数列划分成最少的<strong>不上升子序列的数目</strong>就等于这个<strong>数列最长上升子序列的长度</strong>，因此只需求两次最长上升子序列（LIS）即可，复杂度 $O(n\log n)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> idx=<span class="number">0</span>,a[<span class="number">100005</span>],dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a[++idx]);idx--;<span class="comment">//动态读入数据</span></span><br><span class="line">    <span class="type">int</span> pos=<span class="number">1</span>;dp[<span class="number">1</span>]=a[idx];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=idx<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="comment">//（LIS）求最长不上升子序列==反向最长不下降子序列</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span>                 <span class="comment">//二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pos);</span><br><span class="line">    pos=<span class="number">1</span>;dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">//二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;=a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1091-合唱队形"><a href="#P1091-合唱队形" class="headerlink" title="P1091 合唱队形"></a>P1091 合唱队形</h2><h3 id="题目链接：-NOIP2004-提高组-合唱队形-洛谷"><a href="#题目链接：-NOIP2004-提高组-合唱队形-洛谷" class="headerlink" title="题目链接：[NOIP2004 提高组] 合唱队形 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1091">[NOIP2004 提高组] 合唱队形 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。</p>
<p>合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1&lt; \cdots <t_i>t_{i+1}&gt;$ … $&gt;t_k(1\le i\le k)$。</p>
<p>你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>对于一个合唱队形，它的前半段是上升的而后半段是下降的，想要使这个队形尽可能长，就是要使中间点的最长上升子序列长度与最长下降子序列的长度之和最大，故求两次（LIS）并遍历比较即可，复杂度 $O(n^2)$</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,a[<span class="number">105</span>],dp1[<span class="number">105</span>],dp2[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);<span class="comment">//读入数据</span></span><br><span class="line">        dp1[i]=<span class="number">1</span>;dp2[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正反两次 LIS </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i]) dp1[i]=<span class="built_in">max</span>(dp1[i],dp1[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i]) dp2[i]=<span class="built_in">max</span>(dp2[i],dp2[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历比较</span></span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp1[i]+dp2[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ma);<span class="comment">//题目中所求为出列人数，而非队伍长度，记得减去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1095-守望者的逃离"><a href="#P1095-守望者的逃离" class="headerlink" title="P1095 守望者的逃离"></a>P1095 守望者的逃离</h2><h3 id="题目链接：-NOIP2007-普及组-守望者的逃离-洛谷"><a href="#题目链接：-NOIP2007-普及组-守望者的逃离-洛谷" class="headerlink" title="题目链接：[NOIP2007 普及组] 守望者的逃离 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1095">[NOIP2007 普及组] 守望者的逃离 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。</p>
<p>为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。</p>
<p>守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。</p>
<p>现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。</p>
<p>注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>在 1s 内仅能选择闪现、跑步、恢复中的一项，那么可以考虑每次同时进行两项，选择结果更优项作为选择，$f[i]$ 表示 $i$ s 内行进的最远距离 ，复杂度 $O(n)$</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m,s,t,dp[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">if</span>(m&gt;=<span class="number">10</span>)<span class="comment">//优先使用闪现</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">60</span>;</span><br><span class="line">            m-=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            m+=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;dp[i<span class="number">-1</span>]+<span class="number">17</span>)<span class="comment">//改为选择走路</span></span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;=s)</span><br><span class="line">        &#123;</span><br><span class="line">            ok=<span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;No\n%d&quot;</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1541-乌龟棋"><a href="#P1541-乌龟棋" class="headerlink" title="P1541 乌龟棋"></a>P1541 乌龟棋</h2><h3 id="题目链接：P1541-NOIP2010-提高组-乌龟棋"><a href="#题目链接：P1541-NOIP2010-提高组-乌龟棋" class="headerlink" title="题目链接：P1541 [NOIP2010 提高组] 乌龟棋"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p>
<p>乌龟棋中 $M$ 张爬行卡片，分成4种不同的类型（ $M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p>
<p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p>
<p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p>
<p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>对于动态规划中的选择最优解类问题，往往是在一个过程中不断转移迭代达到整体最优的目的，需要对种类、数量、空间、价值等特征加以辨析进而表达状态，写出转移方程，本题中可以借鉴记忆化搜索和背包模型的思想，用多维表示当前卡牌数量，以及从上一层的最优解转移到当前层中，$f[a][b][c][d]$ 表示已使用的每种卡牌的数量，转移方程为 </p>
<p>$f[a][b][c][d]= f[a-1][b][c][d]+ val[ a+b\ast2+c\ast3+d\ast4 ]$  (例：第一种卡牌)</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,v[<span class="number">355</span>],cnt[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        cnt[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=v[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=cnt[<span class="number">1</span>];a++)<span class="comment">//循环遍历状态，类似背包模型</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;=cnt[<span class="number">2</span>];b++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;=cnt[<span class="number">3</span>];c++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=cnt[<span class="number">4</span>];d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> now=<span class="number">1</span>+a*<span class="number">1</span>+b*<span class="number">2</span>+c*<span class="number">3</span>+d*<span class="number">4</span>;<span class="comment">//当前所到达的格子</span></span><br><span class="line">                    <span class="comment">//状态转移</span></span><br><span class="line">                    <span class="keyword">if</span>(a) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a<span class="number">-1</span>][b][c][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(b) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b<span class="number">-1</span>][c][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(c) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c<span class="number">-1</span>][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(d) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c][d<span class="number">-1</span>]+v[now]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]][cnt[<span class="number">4</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1868-饥饿的奶牛"><a href="#P1868-饥饿的奶牛" class="headerlink" title="P1868 饥饿的奶牛"></a>P1868 饥饿的奶牛</h2><h3 id="题目链接：饥饿的奶牛-洛谷"><a href="#题目链接：饥饿的奶牛-洛谷" class="headerlink" title="题目链接：饥饿的奶牛 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1868">饥饿的奶牛 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。</p>
<p>对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>类似于最长上升子序列和背包模型的做法，$f[i]$ 表示右端点为 $i$ 时的最大值，先将区间按右端点排序，然后考虑对每一段区间选或者不选，如果选，则是采取二分找到从最靠近这段区间左端点的不相交区间的右端点进行转移，若不选则直接等于之前取得的最大值： $f[i]=max(f[i],f[k]+len) (k_{max}&lt;i)$  复杂度 $O(n\log n)$</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma;</span><br><span class="line">pii a[<span class="number">150005</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; dp;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii e1,pii e2)</span><span class="comment">//右端点排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e1.second==e2.second) <span class="keyword">return</span> e1.first&gt;e2.first;</span><br><span class="line">    <span class="keyword">return</span> e1.second&lt;e2.second;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">        <span class="keyword">if</span>(st[a[i].second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a[i].second]=<span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">push_back</span>(a[i].second);<span class="comment">//保存右端点，便于二分查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)<span class="comment">//二分查找上一个满足不与当前区间相交的区间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[mid]&lt;a[i].first) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[a[i].second]=<span class="built_in">max</span>(ma,dp[s[r]]+a[i].second-a[i].first+<span class="number">1</span>);<span class="comment">//后面的区间的最大值自然包含前面区间的最大值，类似前缀思想</span></span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp[a[i].second]);</span><br><span class="line">        <span class="comment">//printf(&quot;t %d %d %d %d %d\n&quot;,a[i].second,r,s[r],dp[s[r]],dp[a[i].second]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2679-子串"><a href="#P2679-子串" class="headerlink" title="P2679 子串"></a>P2679 子串</h2><h3 id="题目链接：-NOIP2015-提高组-子串-洛谷"><a href="#题目链接：-NOIP2015-提高组-子串-洛谷" class="headerlink" title="题目链接：[NOIP2015 提高组] 子串 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2679">[NOIP2015 提高组] 子串 - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>有两个仅包含小写英文字母的字符串 $A$ 和 $B$。</p>
<p>现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？</p>
<p>注意：子串取出的位置不同也认为是不同的方案。</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><h2 id="P2501-数字序列"><a href="#P2501-数字序列" class="headerlink" title="P2501 数字序列"></a>P2501 数字序列</h2><h3 id="题目链接：-HAOI2006-数字序列-洛谷"><a href="#题目链接：-HAOI2006-数字序列-洛谷" class="headerlink" title="题目链接：[HAOI2006]数字序列 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2501">[HAOI2006]数字序列 - 洛谷</a></h3><h3 id="题面：-7"><a href="#题面：-7" class="headerlink" title="题面："></a>题面：</h3><p>现在我们有一个长度为 n 的整数序列 a 。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。</p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>对于第一问，可以将求最少需要改变的数量转化为求最多能够保留的数量，即求最长上升子序列的长度，但是题目中要求改变后整个序列严格单调递增，故保留的数之间需满足其差的绝对值大于之间的距离，$a[i]-a[j] \geq i-j$ ，这样才能保证其中间的数改变后仍保持整个序列单调递增</p>
<p>对于第二问，留白待补</p>
<h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,pos=<span class="number">1</span>,a[<span class="number">30005</span>],dp[<span class="number">30005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);a[i]-=i;&#125;<span class="comment">//构造条件数组</span></span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// LIS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3558-BAJ-Bytecomputer"><a href="#P3558-BAJ-Bytecomputer" class="headerlink" title="P3558 BAJ-Bytecomputer"></a>P3558 BAJ-Bytecomputer</h2><h3 id="题目链接：-POI2013-BAJ-Bytecomputer-洛谷"><a href="#题目链接：-POI2013-BAJ-Bytecomputer-洛谷" class="headerlink" title="题目链接：[POI2013]BAJ-Bytecomputer - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3558">[POI2013]BAJ-Bytecomputer - 洛谷</a></h3><h3 id="题面：-8"><a href="#题面：-8" class="headerlink" title="题面："></a>题面：</h3><p>给定一个长度为 n 的只包含 $−1,0,1$ 的数列 a，每次操作可以使 $a_i$ ​← $a_i​+a_i−1$​，求最少操作次数使得序列单调不降。如果不可能通过该操作使得序列单调不降，请输出 <code>BRAK</code>。</p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>根据题面，数列中只含有 $-1,0,1$ 三个数，当前阶段的数可以根据上一阶段的数进行变换，考虑用状态表示出当前阶段数变化后使整个序列保证单调不降的总变化数，即 $f[i][j]$ 表示第 $i$ 个数变化为 $j$ 时仍保证序列单调不减的总变化数。由于每一层的状态转移只考虑到前一层，故可以使用滚动数组优化空间。复杂度 $O(n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,x,dp[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//滚动数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=inf,dp[<span class="number">1</span>][<span class="number">1</span>]=inf,dp[<span class="number">1</span>][<span class="number">2</span>]=inf;<span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">1</span>][x+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//第一个值没有前值进行转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">//转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=inf;<span class="comment">//-1 变为 0 需要前一个数为 1，此时不满足单调不减，矛盾置为inf</span></span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">2</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>],dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mi=<span class="built_in">min</span>(dp[n%<span class="number">2</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[n%<span class="number">2</span>][<span class="number">1</span>],dp[n%<span class="number">2</span>][<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">if</span>(mi&gt;=inf) <span class="built_in">printf</span>(<span class="string">&quot;BRAK&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,mi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4158-粉刷匠"><a href="#P4158-粉刷匠" class="headerlink" title="P4158 粉刷匠"></a>P4158 粉刷匠</h2><h3 id="题面链接：-SCOI2009-粉刷匠-洛谷"><a href="#题面链接：-SCOI2009-粉刷匠-洛谷" class="headerlink" title="题面链接：[SCOI2009]粉刷匠 - 洛谷"></a>题面链接：<a href="https://www.luogu.com.cn/problem/P4158">[SCOI2009]粉刷匠 - 洛谷</a></h3><h3 id="题面：-9"><a href="#题面：-9" class="headerlink" title="题面："></a>题面：</h3><p>windy 有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。</p>
<p>windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。</p>
<p>如果 windy 只能粉刷 T 次，他最多能正确粉刷多少格子？</p>
<p>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</p>
<h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3>]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.1 线性动态规划</title>
    <url>/luogu4-1/</url>
    <content><![CDATA[<h1 id="Part-4-1-线性动态规划"><a href="#Part-4-1-线性动态规划" class="headerlink" title="Part 4.1 线性动态规划"></a>Part 4.1 线性动态规划</h1><h2 id="最长上升子序列-（LIS）"><a href="#最长上升子序列-（LIS）" class="headerlink" title="最长上升子序列 （LIS）"></a>最长上升子序列 （LIS）</h2><h3 id="朴素版-n-2"><a href="#朴素版-n-2" class="headerlink" title="朴素版 ( $n^2$ )"></a>朴素版 ( $n^2$ )</h3>]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu4.2</title>
    <url>/luogu4-2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Part 4.3 区间动态规划题解</title>
    <url>/luogu4-3-problems/</url>
    <content><![CDATA[<h1 id="Part-4-3-区间动态规划题解"><a href="#Part-4-3-区间动态规划题解" class="headerlink" title="Part 4.3 区间动态规划题解"></a>Part 4.3 区间动态规划题解</h1><h2 id="P1880-石子合并"><a href="#P1880-石子合并" class="headerlink" title="P1880 石子合并"></a>P1880 石子合并</h2><h3 id="题目链接：-NOI1995-石子合并-洛谷"><a href="#题目链接：-NOI1995-石子合并-洛谷" class="headerlink" title="题目链接：[NOI1995] 石子合并 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1880">[NOI1995] 石子合并 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p>
<p>试设计出一个算法，计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>经典的环形区间 DP 问题，用小区间更新大区间的值</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">305</span>],s[<span class="number">305</span>];</span><br><span class="line"><span class="type">int</span> dpa[<span class="number">305</span>][<span class="number">305</span>],dpi[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) </span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="built_in">memset</span>(dpa,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dpa));</span><br><span class="line">    <span class="built_in">memset</span>(dpi,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dpi));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n*<span class="number">2</span>;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dpa[l][r]=dpi[l][r]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpa[l][r]=<span class="built_in">max</span>(dpa[l][r],dpa[l][k]+dpa[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">                    dpi[l][r]=<span class="built_in">min</span>(dpi[l][r],dpi[l][k]+dpi[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> mi=INT_MAX,ma=-INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mi=<span class="built_in">min</span>(mi,dpi[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dpa[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,mi,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3146-248-G"><a href="#P3146-248-G" class="headerlink" title="P3146 248 G"></a>P3146 248 G</h2><h3 id="题目链接：-USACO16OPEN-248-G-洛谷"><a href="#题目链接：-USACO16OPEN-248-G-洛谷" class="headerlink" title="题目链接：[USACO16OPEN]248 G - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3146">[USACO16OPEN]248 G - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>给定一个 $1*n$ 的地图，在里面玩 2048，每次可以合并相邻两个（数值范围 $1-40$ ），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是+1，例如 2 与 2 合并后的数值为 3 。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>区间 DP </p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,a[<span class="number">255</span>],dp[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dp[l][r]=a[l];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[l][k]==dp[k+<span class="number">1</span>][r]) dp[l][r]=<span class="built_in">max</span>(dp[l][r],dp[l][k]+<span class="number">1</span>);</span><br><span class="line">                    ma=<span class="built_in">max</span>(ma,dp[l][r]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1063-能量项链"><a href="#P1063-能量项链" class="headerlink" title="P1063 能量项链"></a>P1063 能量项链</h2><h3 id="题目链接：-NOIP2006-提高组-能量项链-洛谷"><a href="#题目链接：-NOIP2006-提高组-能量项链-洛谷" class="headerlink" title="题目链接：[NOIP2006 提高组] 能量项链 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1063">[NOIP2006 提高组] 能量项链 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>能量项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \times r \times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。</p>
<p>需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,head[<span class="number">255</span>],tail[<span class="number">255</span>],dp[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        head[i%n]=x;</span><br><span class="line">        tail[i<span class="number">-1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    head[n]=head[<span class="number">0</span>];tail[n]=tail[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        head[i]=head[i-n],tail[i]=tail[i-n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                dp[l][r]=<span class="built_in">max</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+head[l]*tail[k]*tail[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1005-矩阵取数游戏"><a href="#P1005-矩阵取数游戏" class="headerlink" title="P1005 矩阵取数游戏"></a>P1005 矩阵取数游戏</h2><h3 id="题目链接：-NOIP2007-提高组-矩阵取数游戏-洛谷"><a href="#题目链接：-NOIP2007-提高组-矩阵取数游戏-洛谷" class="headerlink" title="题目链接：[NOIP2007 提高组] 矩阵取数游戏 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1005">[NOIP2007 提高组] 矩阵取数游戏 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：</p>
<ol>
<li>每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；</li>
<li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li>
<li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；</li>
<li>游戏结束总得分为 $m$ 次取数得分之和。</li>
</ol>
<p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>题目涉及高精，待补</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="P4170-涂色"><a href="#P4170-涂色" class="headerlink" title="P4170 涂色"></a>P4170 涂色</h2><h3 id="题目链接：-CQOI2007-涂色-洛谷"><a href="#题目链接：-CQOI2007-涂色-洛谷" class="headerlink" title="题目链接：[CQOI2007]涂色 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4170">[CQOI2007]涂色 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\texttt{RGBGR}$。</p>
<p>每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\texttt{RRRRR}$，第二次涂成 $\texttt{RGGGR}$，第三次涂成 $\texttt{RGBGR}$，达到目标。</p>
<p>用尽量少的涂色次数达到目标。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s.<span class="built_in">length</span>();len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l+len<span class="number">-1</span>&lt;s.<span class="built_in">length</span>();l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dp[l][r]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[l]==s[r]) dp[l][r]=<span class="built_in">min</span>(dp[l][r<span class="number">-1</span>],dp[l+<span class="number">1</span>][r]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                    dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][s.<span class="built_in">length</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4302-字符串折叠"><a href="#P4302-字符串折叠" class="headerlink" title="P4302 字符串折叠"></a>P4302 字符串折叠</h2><h3 id="题目链接：-SCOI2003-字符串折叠-洛谷"><a href="#题目链接：-SCOI2003-字符串折叠-洛谷" class="headerlink" title="题目链接：[SCOI2003]字符串折叠 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4302">[SCOI2003]字符串折叠 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>折叠的定义如下： </p>
<ol>
<li><p>一个字符串可以看成它自身的折叠。记作 S = S </p>
</li>
<li><p>X(S) 是 X(X&gt;1) 个 S 连接在一起的串的折叠。记作 X(S) = SSSS…S ( X 个 S )。</p>
</li>
<li><p>如果 A = A’, B = B’，则 AB = A’B’ 例如，因为 3(A) = AAA, 2(B) = BB，所以 3(A)C2(B) = AAACBB，而 2(3(A)C)2(B) = AAACAAACBB</p>
</li>
</ol>
<p>给一个字符串，求它的最短折叠。例如 AAAAAAAAAABABABCCD 的最短折叠为：9(A)3(AB)CCD。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string st;</span><br><span class="line"><span class="type">int</span> n,m[<span class="number">110</span>],f[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(st[i]!=st[(i-l)%len+l]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;st;</span><br><span class="line">    n=st.<span class="built_in">size</span>();</span><br><span class="line">    st=<span class="string">&#x27; &#x27;</span>+st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) m[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&lt;=<span class="number">99</span>;i++) m[i]=<span class="number">2</span>;</span><br><span class="line">    m[<span class="number">100</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=i+l<span class="number">-1</span>;j&lt;=n;i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len=k-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l%len!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i,j,len)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+<span class="number">2</span>+m[l/len]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.4 树形动态规划题解</title>
    <url>/luogu4-4-problems/</url>
    <content><![CDATA[<h1 id="Part-4-4-树形动态规划题解"><a href="#Part-4-4-树形动态规划题解" class="headerlink" title="Part 4.4 树形动态规划题解"></a>Part 4.4 树形动态规划题解</h1><h2 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h2><h3 id="题目链接：没有上司的舞会-洛谷"><a href="#题目链接：没有上司的舞会-洛谷" class="headerlink" title="题目链接：没有上司的舞会 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>某大学有 n 个职员，编号为 $1…n$ 。</p>
<p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p>
<p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$​ ，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p>
<p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,root,val[<span class="number">6005</span>],dp[<span class="number">6006</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">6006</span>],e[<span class="number">6006</span>],ne[<span class="number">6005</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">6006</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val[u]&gt;<span class="number">0</span>) dp[u][<span class="number">1</span>]+=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        st[a]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!st[i]) root=i;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1040-加分二叉树"><a href="#P1040-加分二叉树" class="headerlink" title="P1040 加分二叉树"></a>P1040 加分二叉树</h2><h3 id="题目链接：-NOIP2003-提高组-加分二叉树-洛谷"><a href="#题目链接：-NOIP2003-提高组-加分二叉树-洛谷" class="headerlink" title="题目链接：[NOIP2003 提高组] 加分二叉树 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1040">[NOIP2003 提高组] 加分二叉树 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为 $(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：</p>
<p>$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。</p>
<p>若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p>
<p>试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出</p>
<ol>
<li><p>$\text{tree}$ 的最高加分。</p>
</li>
<li><p>$\text{tree}$ 的前序遍历。</p>
</li>
</ol>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">35</span>],dp[<span class="number">35</span>][<span class="number">35</span>],root[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root[l][r]);</span><br><span class="line">    <span class="built_in">dfs</span>(l,root[l][r]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) &#123;dp[l][r]=a[l];root[l][r]=l;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">                    <span class="keyword">if</span>(k==l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[k+<span class="number">1</span>][r]+dp[l][l]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[k+<span class="number">1</span>][r]+dp[l][l];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k==r)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[l][k<span class="number">-1</span>]+dp[r][r]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[l][k<span class="number">-1</span>]+dp[r][r];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1122-最大子树和"><a href="#P1122-最大子树和" class="headerlink" title="P1122 最大子树和"></a>P1122 最大子树和</h2><h3 id="题目链接：最大子树和-洛谷"><a href="#题目链接：最大子树和-洛谷" class="headerlink" title="题目链接：最大子树和 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1122">最大子树和 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N−1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma=<span class="number">-1e9</span>,w[<span class="number">17000</span>],dp[<span class="number">17000</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">17000</span>],e[<span class="number">34000</span>],ne[<span class="number">34000</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">17000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u]=w[u];</span><br><span class="line">    st[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u]+=<span class="built_in">max</span>(<span class="number">0</span>,dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ma=<span class="built_in">max</span>(ma,dp[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1273-有线电视网"><a href="#P1273-有线电视网" class="headerlink" title="P1273 有线电视网"></a>P1273 有线电视网</h2><h3 id="题目链接：有线电视网-洛谷"><a href="#题目链接：有线电视网-洛谷" class="headerlink" title="题目链接：有线电视网 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1273">有线电视网 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。</p>
<p>从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。</p>
<p>现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。</p>
<p>写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>误区警告，多出来的钱可以摊给其他路线</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3>]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu4.3</title>
    <url>/luogu4-3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu4.4</title>
    <url>/luogu4-4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>第11章 导数和图像</title>
    <url>/calculus/calculus11/</url>
    <content><![CDATA[<h1 id="第11章-导数和图像"><a href="#第11章-导数和图像" class="headerlink" title="第11章 导数和图像"></a>第11章 导数和图像</h1><p>全局最大(小)值 或 绝对最大(小)值<br>局部最大(小)值 或 相对最大(小)值<br><strong>最大值与最小值定理</strong>：如果 $f$ 在 $[a,b]$ 上连续，那么 $f$ 在 $[a,b]$ 上至少有一个最大值和一个最小值<br><strong>极值定理</strong>：假设函数 $f$ 定义在开区间 $(a,b)$ 内，并且点 $c$ 在 $(a,b)$ 区间内，如果点 $c$ 为函数的局部最大值或最小值，那么点 $c$ 一定为该函数的临界点，也就是说，$f’(c)=0$ 或 $f’(c)$ 不存在，此定理适用于开区间<br>在一个开区间内的局部最大值和最小值只有可能出现在临界点，但临界点未必一定是局部最大值或局部最小值，例如 $f(x)=x^3$<br><strong>罗尔定理</strong>：假设函数 $f$ 在闭区间 $[a,b]$ 内连续，在开区间 $(a,b)$ 内可导，如果 $f(a)=f(b)$，那么在开区间 $(a,b)$ 内至少存在一点 $c$，使得 $f’(c)=0$<br>罗尔定理应用的例子：假设有一个函数 $f$ 满足 $f’(x)&gt;0$，则该函数一定满足水平线检验</p>
<ul>
<li>证明：首先假设 $f$ 不满足水平线检验，那么一定有一条水平线 $y=L$，它与图像相交两次或者更多，假设这些交点中的两点横坐标为 $a$ 和 $b$，则有 $f(a)=f(b)=L$，由于 $f(a)=f(b)$，所以可以使用罗尔定理，由定理可得在 $a$ 和 $b$ 之间一定存在一点 $c$ 使得 $f’(c)=0$，这与条件相悖，故证明该函数满足水平线检验</li>
</ul>
<p><strong>中值定理</strong>：假设函数 $f$ 在闭区间 $[a,b]$ 内连续，在开区间 $(a,b)$ 内可导，那么在开区间 $(a,b)$ 内至少有一点 $c$ 使得 $f’(c)=\frac{f(b)-f(a)}{b-a}$<br>中值定理应用的例子：假设有一个函数，对于所有的实数 $x$ 处处可导并且 $f’(x)&gt;4$，证明这个函数 $y=f(x)$ 的图像与线性函数 $y=3x-2$ 最多只有一个交点</p>
<ul>
<li>证明：如果点 $(x,y)$ 是同时满足函数 $y=f(x)$ 和线性函数 $y=3x-2$ 的点，一定会有 $f(x)=3x-2$，运用反证法，假设交点不止一个，任选其中两个，并分配记号 $a$ 和 $b$，使得 $a&lt;b$，由于他们是交点，有 $f(a)=3a-2$ 和 $f(b)=3b-2$，又由于该函数对于所有实数都处处可导且连续，根据中值定理，在开区间 $(a,b)$ 内一定有一点 $c$ 使得 $f’(c)=\frac{f(b)-f(a)}{b-a}$ 代入 $f(a)=3a-2$ 和 $f(b)=3b-2$，可得 $f’(c)=\frac{f(3b-2)-f(3a-2)}{b-a}=\frac{3(b-a)}{b-a}=3$ 与条件中 对于所有 $x$，$f’(x)&gt;4$ 相悖，因此最多只能有一个交点</li>
</ul>
<p>中值定理的推论</p>
<ul>
<li>如果对于在定义域 $(a,b)$ 内的所有 $x$，都有 $f’(x)=0$，那么函数 $f$ 在开区间 $(a,b)$ 内为常数函数</li>
<li>如果对于任意实数 $x$ 都有 $f’(x)=g’(x)$，那么有 $f(x)=g(x)+C$ ( $C$ 为常数)</li>
</ul>
<p>二阶导数在区间内始终为正，则函数在该区间内是凹向上的<br>二阶导数在区间内始终为负，则函数在该区间内是凹向下<br>如果 $x=c$ 点是函数 $f$ 的拐点，则有 $f’’(c)=0$<br>如果 $f’’(c)=0$，$c$ 点不一定是函数 $f$ 的拐点，例如 $f(x)=x^4$</p>
<p>对导数为零点的分类<br>假设有一个函数 $f$ 以及数 $c$ 使得 $f’(c)=0$，即 $x=c$ 处切线为水平的，有三种常见的可能性：$x=c$ 可能为局部最大值；也可能为局部最小值；还可能为水平拐点<br>留白，待补图<br>使用一次导数进行判断</p>
<ul>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号由正变负，那么 $c$ 点为局部最大值</li>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号由负变正，那么 $c$ 点为局部最小值</li>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号不发生变化，那么 $c$ 点为水平拐点</li>
</ul>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 函数、图像和直线</title>
    <url>/calculus/calculus1/</url>
    <content><![CDATA[<h1 id="第一章-函数、图像和直线"><a href="#第一章-函数、图像和直线" class="headerlink" title="第一章 函数、图像和直线"></a>第一章 函数、图像和直线</h1><p>定义域，函数输入的取值范围<br>值域，函数输出的可能值组成的集合<br>上域，函数输出的可能值范围，$上域 \supset 值域$<br>垂线检验，判断是否为函数<br>反函数，$f^{-1}$ 和 $f$ 互为反函数<br>水平线检验，判断是否有反函数<br>反函数与原函数以 $y=x$ 为对称轴<br>函数复合，书写为$f(x)=h(g(x)),f=h \circ g$，即 f 是 g 与 h 的<strong>复合</strong><br>偶函数具有镜面对称性，$f(x)=f(-x)$<br>奇函数具有原点对称性，$f(-x)=-f(x)$<br>只有一个函数是既奇又偶的，即$f(x)=0$<br>两个奇函数之积是偶函数<br>两偶函数之积仍为偶函数<br>奇函数和偶函数之积是奇函数<br>形如 $f(x)=mx+b$ 的函数叫做线性函数，其图像为直线，直线斜率是m<br>确定两点即可确定线性函数的图像<br>线性函数 y 轴的截距为 b ，x 轴截距为 $y=0$ 时自变量 x 的值<br>知道斜率和一个点就可以确定一条直线<br>点斜式：$如果已知直线通过点(x_0,y_0),斜率为m,则它的方程为 y-y_0=m(x-x_0)$<br>如果你知道两个确定点，就可以求出斜率，进而得到直线方程<br>$如果一条直线通过点(x_1,y_1)和(x_2,y_2),则它的斜率等于 \frac{y_2-y_1}{x_2-x_1}$<br>多项式，以 x 的非负次幂为基本项同实数做乘法并将有限个这样的项相加得到<br>每项中所乘实数称作系数，最大的幂指数 n （该项系数不为 0）叫作多项式的次数<br>次数为 n 的多项式的数学通式为<br>$p(x)=a_nx^n+a_{n-1}x^{n-1}+\dots+a_2x^2+a_1x+a_0$<br>其中 $a_n$ 为 $x^n$ 的系数， $a_{n-1}$ 为 $x^{n-1}$ 的系数，以此类推，直到最后一项 $1$ 的系数为 $a_0$<br>多项式图像左右两端的走势是由最高次数的项的系数决定的，该系数叫作<strong>首项系数</strong>，我们只需考虑首项系数正负以及多项式次数的奇偶就能判断图像两端的走势，有四种情况<br>此处留白，图片待补<br>次数为 2 的多项式又叫二次函数<br>一般写作 $p(x)=ax^2+bx+c$<br>我们可以通过判别式的符号确定二次函数有几个实数解，通常我们用希腊字母 $\Delta$ 来表示判别式 $\Delta=b^2-4ac$ ，若 $\Delta ＞ 0$，有两个不同的解，若 $\Delta = 0$，只有一个解， 若$\Delta ＜ 0$，则实数范围内无解，对于前两种情况，有解时，解为$\frac{-b \pm \sqrt{b^2-4ac}}{2a}$<br>二次函数配方<br>举例一枚：考虑二次函数 $2x^2-3x+10$</p>
<ul>
<li>第一步，把二项式系数提出，多项式变为 $2(x^2-\frac{3}{2}x+5)$</li>
<li>第二步，配方，根据完全平方公式，我们通过 x 的系数 $- \frac{3}{2}$ 除以 2，再平方得到配方数 $\frac{9}{16}$，此时括号内式子可变为 $x^2- \frac{3}{2}x+ \frac{9}{16}+5- \frac{9}{16}$</li>
<li>第三步，使用完全平方公式，括号内式子变为 $(x- \frac{3}{4})^2+5- \frac{9}{16}$ ，最后恢复系数得到 $2(x- \frac{3}{4})^2+\frac{71}{8}$</li>
</ul>
<p>有理函数，形如 $\frac{p(x)}{q(x)}$，其中 p 和 q 为多项式的函数，叫作有理函数<br>指数函数，$y=b^x(b&gt;0)$<br>对数函数，$y=log_b(x)$<br>指数函数与对数函数互为反函数<br>$|x-y|$ 是数轴上 x 和 y两点间的距离</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 反函数和反三角函数</title>
    <url>/calculus/calculus10/</url>
    <content><![CDATA[<h1 id="第十章-反函数和反三角函数"><a href="#第十章-反函数和反三角函数" class="headerlink" title="第十章 反函数和反三角函数"></a>第十章 反函数和反三角函数</h1><p>使用导数证明反函数存在，满足水平线检验的图像必定是具有严格单调性的，故如果 $f$ 在其定义域 $(a,b)$ 上可导且满足以下条件中的任意一条，则 $f$ 有反函数</p>
<ul>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x) &gt;0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)&lt;0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)\geqslant0$ 且对于有限个数的 $x$，$f’(x)=0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)\leqslant0$ 且对于有限个数的 $x$，$f’(x)=0$</li>
<li>如果其定义域是 $[a,b]、[a,b)、(a,b]$ 的形式，且 $f$ 在整个定义域上连续，那么如果 $f$满足上述条件中的任意一条，它仍然具有反函数</li>
<li>*函数导数值为零的点数有限，否则不满足水平线检验，区间需连续，否则结论不成立</li>
</ul>
<p>反函数的导数，如果 $y=f^{-1}(x)$，则 $\frac{dy}{dx}=\frac{1}{f’(y)}$<br>如果用 $x$ 来表达所有项，那么必须用 $f^{-1}(x)$ 替换 $y$，得到 $\frac{d}{dx}(f^{-1}(x))=\frac{1}{f’(f^{-1}(x))}$<br>原函数处处可导，其反函数不一定处处可导</p>
<p>例子一枚：<br>$f(x)=x^2(x-5)^3$，并且其定义域为 $[2,\infty)$，$f(4)=-16$，计算 $(f^{-1})’(-16)$</p>
<ul>
<li>$y=f^{-1}(x)$</li>
<li>$\frac{dy}{dx}=\frac{1}{f’(y)}=\frac{1}{5y(y-5)^2(y-2)}$</li>
<li>$\frac{dy}{dx}=\frac{1}{5(4)(4-5)^2(4-2)}=\frac{1}{40}$</li>
</ul>
<p>反三角函数，由限制三角函数区间得到<br>$\frac{d}{dx}arcsin(x)=\frac{1}{\sqrt{1-x^2}}$，其中 $-1&lt;x&lt;1$<br>$arcsin$ 是奇函数；其定义域为 $[-1,1]$，值域为 $[-\frac{π}{2},\frac{π}{2}]$<br>$\frac{d}{dx}arccos(x)=-\frac{1}{\sqrt{1-x^2}}$，其中 $-1&lt;x&lt;1$<br>$arccos$ 既不是奇函数也不是偶函数；其定义域为 $[-1,1]$，值域为 $[0,π]$<br>$arcsin$ 和 $arccos$ 的导数互为相反数，即 $\frac{d}{dx}(arcsin(x)+arccos(x))=0$<br>因此通过微积分证明了以下恒等式：<br>$arcsin(x)+arccos(x)=\frac{π}{2}$<br>微积分和几何学殊途同归！！！</p>
<p>对于所有的实数 $x$，$\frac{d}{dx}arctan(x)=\frac{1}{1+x^2}$<br>$arctan$ 是奇函数；其定义域是 $R$，值域为 $(-\frac{π}{2},\frac{π}{2})$<br>$\lim\limits_{x \rightarrow \infty}arctan(x)=\frac{π}{2}$<br>$\lim\limits_{x \rightarrow -\infty}arctan(x)=-\frac{π}{2}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arcsec(x)=\frac{π}{2}$<br>$\lim\limits_{x \rightarrow -\infty}arcsec(x)=\frac{π}{2}$<br>对于 $x&gt;1$ 或 $x&lt;-1$，$\frac{d}{dx}arcsec(x)=\frac{1}{|x|\sqrt{x^2-1}}$<br>$arcsec$ 既不是奇函数也不是偶函数；其定义域是 $(-\infty,-1] \cup [1,\infty)$ 且值域是 $[0,π] \setminus {\frac{π}{2}}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arccsc(x)=0$<br>$\lim\limits_{x \rightarrow -\infty}arccsc(x)=0$<br>对于 $x&gt;1$ 或 $x&lt;-1$，$\frac{d}{dx}arccsc(x)=-\frac{1}{|x|\sqrt{x^2-1}}$<br>$arccsc$ 是奇函数；其定义域为 $(-\infty,-1] \cup [1,\infty)$ 且值域是 $[-\frac{π}{2},\frac{π}{2}] \setminus {0}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arccot(x)=0$<br>$\lim\limits_{x \rightarrow -\infty}arccot(x)=π$<br>对于所有的实数 $x$，$\frac{d}{dx}arccot(x)=-\frac{1}{1+x^2}$<br>$arccot$ 既不是奇函数也不是偶函数；其定义域为 $R$ 且值域是 $(0,π)$</p>
<p>以上留白，待补图例和反函数求导证明</p>
<p>$cosh^{-1}$ 既不是奇函数也不是偶函数；其定义域是 $[1,\infty)$ 且值域是 $[0,\infty)$<br>$sinh^{-1}$ 是奇函数；其定义域和值域都是 $R$</p>
<p>留白，待补图例</p>
<p>对于 $x&gt;1$，$\frac{d}{dx}cosh^{-1}(x)=\frac{1}{\sqrt{x^2-1}}$<br>对于所有的实数 $x$，$\frac{d}{dx}sinh^{-1}(x)=\frac{1}{\sqrt{x^2+1}}$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章 绘制函数图像</title>
    <url>/calculus/calculus12/</url>
    <content><![CDATA[<h1 id="第12章-绘制函数图像"><a href="#第12章-绘制函数图像" class="headerlink" title="第12章 绘制函数图像"></a>第12章 绘制函数图像</h1>]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章 最优化和线性化</title>
    <url>/calculus/calculus13/</url>
    <content><![CDATA[<h1 id="第13章-最优化和线性化"><a href="#第13章-最优化和线性化" class="headerlink" title="第13章 最优化和线性化"></a>第13章 最优化和线性化</h1><p><strong>最优化</strong>，往往是指对于某个我们关心的特定变量，使其在区间内最大化或最小化<br>解决最优化问题的一般方法：</p>
<ul>
<li>识别出所有你可能用到的变量，并确定你试图最大化或最小化的目标变量</li>
<li>确定各个变量的定义域范围</li>
<li>写出关联起不同变量的各个方程</li>
<li>努力通过方程消去其他变量，使得目标变量可以表示为只关于一个变量的函数</li>
<li>对上述函数关于那个变量求导，找出临界点</li>
<li>求出目标变量在临界点及端点所对应的值，得到最大值和最小值</li>
<li>得到结论</li>
</ul>
<p><strong>线性化</strong>，留白</p>
<p>估算或近似计算一个难以计算的数的基本策略：</p>
<ul>
<li>写出主要公式：$f(x) \approx L(x) = f(a)+f’(a)(x-a)$</li>
<li>选择一个函数 $f$ 以及一个数 $x$，使得所求数等于 $f(x)$，同时选取一个接近于 $x$ 的 $a$，并使得 $f(a)$ 易于计算</li>
<li>对 $f$ 求导，计算 $f’(x)$</li>
<li>带入公式计算</li>
</ul>
<p>留白，待补关于误差的讨论</p>
<p><strong>牛顿法</strong>，假设 $a$，是对方程 $f(x)=0$ 的解的一个近似，如果令 $b=a-\frac{f(a)}{f’(a)}$，则在很多情况下，$b$ 是个比 $a$ 更好的近似<br>牛顿法失效的四种情况</p>
<ul>
<li>$f’(a)$ 的值接近于 $0$</li>
<li>如果 $f(x)=0$ 有不止一个解，可能得到的并非所预测的那个解</li>
<li>近似可能变得越来越糟</li>
<li>可能陷入循环</li>
</ul>
<p>留白，待补上述情况图例</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章 洛必达法则</title>
    <url>/calculus/calculus14/</url>
    <content><![CDATA[<h1 id="第14章-洛必达法则"><a href="#第14章-洛必达法则" class="headerlink" title="第14章 洛必达法则"></a>第14章 洛必达法则</h1><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h2><p><strong>洛必达法则</strong>，如果 $f(a)=g(a)=0$，那么 $\lim\limits_{x \rightarrow a}\frac{f(x)}{g(x)}=\lim\limits_{x \rightarrow a}\frac{f’(x)}{g’(x)}$，假设等式右端的极限存在，且当 $x$ 趋于但不等于 $a$ 时，$g’(x)$ 不为 $0$</p>
<h3 id="类型-A-：-frac-0-0-或-frac-pm-infty-pm-infty"><a href="#类型-A-：-frac-0-0-或-frac-pm-infty-pm-infty" class="headerlink" title="类型 $A$：$\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$"></a>类型 $A$：$\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{x^3} \ (\frac{0}{0})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{x^3}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{3x^2}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{6x}=\frac{1}{6}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=\frac{1}{6}$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \infty}\frac{3x^2+7x}{2x^2-5} \ (\frac{\infty}{\infty})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{3x^2+7x}{2x^2-5}\overset{l’H}{=}\lim\limits_{x \rightarrow \infty}\frac{6x+7}{4x}=\lim\limits_{x \rightarrow \infty}(\frac{6}{4}+\frac{7}{4x})=\frac{3}{2}$</li>
</ul>
<p>例子三枚：$\lim\limits_{x \rightarrow 0^+}\frac{csc(x)}{1-ln(x)}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}\frac{csc(x)}{1-ln(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{-csc(x)cot(x)}{-\frac{1}{x}}=\lim\limits_{x \rightarrow 0^+}xcsc(x)cot(x)=\lim\limits_{x \rightarrow 0^+}\frac{x}{sin(x)}\frac{1}{tan(x)}=\infty$</li>
</ul>
<p><strong>只有形如 $\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$ 不定式才能使用洛必达法则</strong></p>
<h3 id="类型-B1-：-pm-infty-infty"><a href="#类型-B1-：-pm-infty-infty" class="headerlink" title="类型 $B1$：$\pm(\infty-\infty)$"></a>类型 $B1$：$\pm(\infty-\infty)$</h3><p>转化为类型 $A$ 求解，经常采取通分的手段进行转化，仅在能将原始表达式转化为两式之比时才能考虑使用洛必达法则<br>例子一枚：$\lim\limits_{x \rightarrow 0}(\frac{1}{sin(x)}-\frac{1}{x})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}(\frac{1}{sin(x)}-\frac{1}{x})=\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{xsin(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{sin(x)+xcos(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{cos(x)+cos(x)-xsin(x)}=\frac{0}{2}=0$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})=\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})×\frac{\sqrt{x+ln(x)}+\sqrt{x}}{\sqrt{x+ln(x)}+\sqrt{x}}=\lim\limits_{x \rightarrow \infty}\frac{x+ln(x)-x}{\sqrt{x+ln(x)}+\sqrt{x}}=\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{\sqrt{x+ln(x)}+\sqrt{x}}\overset{l’H}{=}\lim\limits_{x \rightarrow \infty}\frac{\frac{1}{x}}{\frac{1+\frac{1}{x}}{2\sqrt{x+ln(x)}}+\frac{1}{2\sqrt{x}}}=\lim\limits_{x \rightarrow \infty}\frac{1}{\frac{x+1}{2\sqrt{x+ln(x)}}+\frac{\sqrt{x}}{2}}=0$</li>
</ul>
<h3 id="类型-B2-：-0-×-pm-infty"><a href="#类型-B2-：-0-×-pm-infty" class="headerlink" title="类型 $B2$：$(0 × \pm\infty)$"></a>类型 $B2$：$(0 × \pm\infty)$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0^+}xln(x)$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}xln(x)=\lim\limits_{x \rightarrow 0^+}\frac{ln(x)}{\frac{1}{x}}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{\frac{1}{x}}{-\frac{1}{x^2}}=\lim\limits_{x \rightarrow 0^+}(-x)=0$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \frac{π}{2}}(x-\frac{\pi}{2})tan(x)$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \frac{π}{2}}(x-\frac{\pi}{2})tan(x)=\lim\limits_{x \rightarrow \frac{π}{2}}\frac{x-\frac{\pi}{2}}{cot(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow \frac{\pi}{2}}\frac{1}{(-csc^2(x))}=\frac{1}{-1}=-1$</li>
</ul>
<h3 id="类型-C-：-1-pm-infty-0-0-或-infty-0"><a href="#类型-C-：-1-pm-infty-0-0-或-infty-0" class="headerlink" title="类型 $C$：$(1^{\pm\infty},0^0 或 \infty^0)$"></a>类型 $C$：$(1^{\pm\infty},0^0 或 \infty^0)$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0^+}x^{sin(x)}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}ln(x^{sin(x)})=\lim\limits_{x \rightarrow 0^+}sin(x)ln(x)=\lim\limits_{x \rightarrow 0^+}\frac{ln(x)}{csc(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{\frac{1}{x}}{-csc(x)cot(x)}=\lim\limits_{x \rightarrow 0^+}-\frac{sin(x)}{x}×tan(x)=-1\times0=0$</li>
<li>$\lim\limits_{x \rightarrow 0^+}x^{sin(x)}=e^0=1$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow 0}(1+3tan(x))^{\frac{1}{x}}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}ln((1+3tan(x))^{\frac{1}{x}})=\lim\limits_{x \rightarrow 0}\frac{1}{x}ln(1+3tan(x))=\lim\limits_{x \rightarrow 0}\frac{ln(1+3tan(x))}{x}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{\frac{3sec^2(x)}{1+3tan(x)}}{1}=\frac{3(1)^2}{1+3(0)}=3$</li>
<li>$\lim\limits_{x \rightarrow 0}(1+3tan(x))^{\frac{1}{x}}=e^3$</li>
</ul>
<h3 id="洛必达法则类型总结"><a href="#洛必达法则类型总结" class="headerlink" title="洛必达法则类型总结"></a>洛必达法则类型总结</h3><ul>
<li><strong>类型A</strong>，如果极限是分式形式，且该分式为形如 $\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$ 的不定式时，可以使用洛必达法则 $\lim\limits_{x \rightarrow a}\frac{f(x)}{g(x)}=\lim\limits_{x \rightarrow a}\frac{f’(x)}{g’(x)}$ 在求导的过程中，不要使用商的求导法则，同时为求解新的极限，可能需要再次使用洛必达法则</li>
<li><strong>类型B1</strong>，如果是求差的极限，如 $\lim\limits_{x \rightarrow a}(f(x)-g(x))$，该形式为 $\pm(\infty-\infty)$，可使用通分或者同时乘以除以一个共轭表达式从而转化为类型A进行求解</li>
<li><strong>类型B2</strong>，如果所求极限是乘积的形式，如 $\lim\limits_{x \rightarrow a}f(x)g(x)$，该形式为 $(0 × \pm\infty)$，则选择两个因式中较简单的那个取倒数，将它移至分母(尽量不要选对数做分母，将它留在分子)，将其转化为类型A进行求解</li>
<li><strong>类型C</strong>，如果极限为指数的形式，并且该指数的底数和指数部分都包含变量，例如$\lim\limits_{x \rightarrow a}f(x)^{g(x)}$，我们先取其对数，然后转化为已知易解的形式进行求解</li>
</ul>
<h2 id="关于极限的总结"><a href="#关于极限的总结" class="headerlink" title="关于极限的总结"></a>关于极限的总结</h2>]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第15章 积分</title>
    <url>/calculus/calculus15/</url>
    <content><![CDATA[<h1 id="第15章-积分"><a href="#第15章-积分" class="headerlink" title="第15章 积分"></a>第15章 积分</h1><p>$\sum$ 求和符号<br>过渡章</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第16章 定积分</title>
    <url>/calculus/calculus16/</url>
    <content><![CDATA[<h1 id="第16章-定积分"><a href="#第16章-定积分" class="headerlink" title="第16章 定积分"></a>第16章 定积分</h1><p>留白，待补图积分简例</p>
<p><strong>定积分</strong>，$\displaystyle\int^b_af(x)dx$，读作“函数 $f(x)$ 对于 $x$ 从 $a$ 到 $b$ 的积分”，表达式 $f(x)$ 叫作<strong>被积函数</strong>，$a$ 和 $b$ 说明两条垂线在哪，也叫 <strong>积分极限</strong> 或者 <strong>积分端点</strong>，$dx$ 说明 $x$ 是水平轴的变量，$x$ 是虚拟变量.</p>
<p>如果函数 $f$ 为有界函数并在区间 $[a,b]$ 上有有限个不连续点，那么函数 $f$ 是可积的.</p>
<p>$\displaystyle\int_a^bf(x)dx$ 是由曲线 $y=f(x)$，两条垂线 $x=a$ 和 $x=b$，以及 $x$ 轴所围成的有向面积(平方单位)</p>
<ul>
<li>$\displaystyle\int_b^af(x)dx=-\displaystyle\int_a^bf(x)dx$</li>
<li>$\displaystyle\int_a^af(x)dx=0$</li>
<li>$\displaystyle\int_a^bf(x)dx=\displaystyle\int_a^cf(x)dx+\displaystyle\int_c^bf(x)dx$</li>
<li>$\displaystyle\int_a^bCf(x)dx=C\displaystyle\int_a^bf(x)dx$</li>
<li>$\displaystyle\int_a^b(f(x)+g(x))dx=\displaystyle\int_a^bf(x)dx+\displaystyle\int_a^bg(x)dx$</li>
</ul>
<p>如果对于在区间 $[a,b]$ 内所有的 $x$ 都有 $f(x)\leqslant g(x)$，那么就有 $\displaystyle\int_a^bf(x)dx\leqslant\displaystyle\int_a^bg(x)dx$</p>
<p>如果对于在 $[a,b]$ 区间内的所有 $x$ 有 $m \leqslant f(x) \leqslant M$，那么 $m(b-a) \leqslant \displaystyle\int_a^bf(x)dx \leqslant M(b-a)$</p>
<p>可积函数 $f$ 的平均值定义为：函数 $f$ 在区间 $[a,b]$ 内的平均值 = $\frac{1}{b-a}\displaystyle\int_a^bf(x)dx$</p>
<p><strong>积分的中值定理</strong>，如果函数 $f$ 在闭区间 $[a,b]$ 上连续，那么在开区间 $(a,b)$ 内总有一点 $c$，满足 $f(c)=\frac{1}{b-a}\displaystyle\int_a^bf(x)dx$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第17章 微积分基本定理</title>
    <url>/calculus/calculus17/</url>
    <content><![CDATA[<h1 id="第17章-微积分基本定理"><a href="#第17章-微积分基本定理" class="headerlink" title="第17章 微积分基本定理"></a>第17章 微积分基本定理</h1><h2 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h2><p><strong>微积分的第一基本定理</strong>：如果函数 $f$ 在闭区间 $[a,b]$ 上是连续的，定义 $F$ 为 $F(x)=\displaystyle\int_a^xf(t)dt,x \in [a,b]$ 则 $F$ 在开区间 $(a,b)$ 内是可导函数，而且 $F’(x)=f(x)$<br>简而言之，可以总结为 $\frac{d}{dx}\int_a^xf(t)dt=f(x)$<br><strong>微积分的第二基本定理</strong>：如果函数 $f$ 在闭区间 $[a,b]$ 上是连续的，$F$ 是 $f$ 的任意一个反导数(关于 $x$)，那么有 $\displaystyle\int_a^bf(x)dx=F(b)-F(a)$<br>在实践中，通常写成 $F(x)\big|_a^b=F(b)-F(a)$</p>
<p>例子：$\displaystyle\int_{\frac{\pi}{6}}^{\frac{\pi}{2}}cos(x)dx=sin(x)\big|_{\frac{\pi}{6}}^{\frac{\pi}{2}}=sin(\frac{\pi}{2})-sin(\frac{\pi}{6})=1-\frac{1}{2}=\frac{1}{2}$</p>
<p>$\displaystyle\int f(x)dx$，表示函数 $f$ 的反导数的集合</p>
<p>如果 $\frac{d}{dx}F(x)=f(x)$，那么 $\displaystyle\int f(x)dx=F(x)+C$</p>
<p>通过有无积分上下限区分定积分和不定积分</p>
<ul>
<li>定积分，如 $\displaystyle\int_a^bf(x)dx$ 是一个数.其表示由曲线 $y=f(x)$、$x$ 轴以及垂线 $x=a$ 和 $x=b$ 所围成面积</li>
<li>不定积分，如 $\displaystyle\int f(x)dx$，是一个函数的集合，这个集合由函数 $f$ 的所有反导数(关于 $x$)组成</li>
</ul>
<p>不定积分的两个性质，如果 $f$ 和 $g$ 是可积的，$c$ 是一个常数，这时<br>$\int (f(x)+g(x))dx=\int f(x)dx+\int g(x)dx$<br>$\int cf(x)dx=c \int f(x)dx$</p>
<p>微分和导数是相反的运算</p>
<h2 id="怎样解决问题：微积分的第一基本定理"><a href="#怎样解决问题：微积分的第一基本定理" class="headerlink" title="怎样解决问题：微积分的第一基本定理"></a>怎样解决问题：微积分的第一基本定理</h2><p>$\frac{d}{dx}\int_a^xf(t)dt=f(x)$</p>
<h3 id="变形1：变量是积分下限"><a href="#变形1：变量是积分下限" class="headerlink" title="变形1：变量是积分下限"></a>变形1：变量是积分下限</h3><p>将上限与下限互换，再在新的积分前面加个负号<br>例：$\displaystyle\frac{d}<br>{dx}\int_x^7t^3cos(tln(t))dt$<br>解：$\displaystyle\frac{d}<br>{dx}\int_x^7t^3cos(tln(t))dt\ =\frac{d}{dx}(-\int_7^xt^3cos(tln(t))dt)\ =-x^3cos(xln(x))$</p>
<h3 id="变形2：积分上限是一个函数"><a href="#变形2：积分上限是一个函数" class="headerlink" title="变形2：积分上限是一个函数"></a>变形2：积分上限是一个函数</h3><p>使用链式求导法则<br>例：$\displaystyle\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt$<br>解：先设置这个积分为 $y$<br>$\displaystyle y=\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt$<br>要计算 $\frac{dy}{dx}$，因为 $y$ 是一个关于 $x^2$ 的函数，而非直接关于 $x$，所以我们设置 $u=x^2$<br>$\displaystyle y=\frac{d}{dx}\int_0^utan^{-1}(t^7+3t)dt$<br>根据链式求导法则，<br>$\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$<br>根据微积分第一基本定理，<br>$\displaystyle\frac{dy}{du}=tan^{-1}(u^7+3u)\ \frac{du}{dx}=2x$<br> 用 $x^2$ 替换 $u$，可得答案<br>$\displaystyle\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt=2xtan^{-1}(x^{14}+3x^2)$</p>
<h3 id="变形3：积分上下限都为函数"><a href="#变形3：积分上下限都为函数" class="headerlink" title="变形3：积分上下限都为函数"></a>变形3：积分上下限都为函数</h3><p>用一个常数将这个积分分成两个部分，然后求解<br>例：$\displaystyle\frac{d}{dx}\int_{x^5}^{x^6}ln(t^2-sin(t)+7)dt$<br>解：</p>
<p>$\begin{aligned}<br>&amp;\ \ \ \ \ \displaystyle\frac{d}{dx}\int_{x^5}^{x^6}ln(t^2-sin(t)+7)dt\\&amp;=\frac{d}{dx}(\int_{x^5}^{0}ln(t^2-sin(t)+7)dt+\int_{0}^{x^6}ln(t^2-sin(t)+7)dt)\\&amp;=\frac{d}{dx}(-\int_{0}^{x^5}ln(t^2-sin(t)+7)dt+\int_{0}^{x^6}ln(t^2-sin(t)+7)dt)\\&amp;=-5x^4ln(x^{10}-sin(x^5)+7)+6x^5ln(x^{12}-sin(x^6)+7)<br>\end{aligned}$</p>
<h3 id="变形4：极限伪装成导数"><a href="#变形4：极限伪装成导数" class="headerlink" title="变形4：极限伪装成导数"></a>变形4：极限伪装成导数</h3><p>例：$\displaystyle\lim\limits_{h \rightarrow 0}\frac{1}{h}\int_x^{x+h}log_3(cos^6(t)+2)dt$<br>解：</p>
<p>$\begin{aligned}<br>&amp;\ \ \ \ \ \displaystyle\lim\limits_{h \rightarrow 0}\frac{1}{h}\int_x^{x+h}log_3(cos^6(t)+2)dt\\&amp;=\lim\limits_{h \rightarrow 0}\frac{F(x+h)-F(x)}{h}\\&amp;=\frac{d}{dx}\int_a^xlog_3(cos^6(t)+2)dt\\&amp;=log_3(cos^6(x)+2)<br>\end{aligned}$</p>
<h2 id="怎样解决问题：微积分的第二基本定理"><a href="#怎样解决问题：微积分的第二基本定理" class="headerlink" title="怎样解决问题：微积分的第二基本定理"></a>怎样解决问题：微积分的第二基本定理</h2><p>留白，待补图<br>例子</p>
<p>微积分第一基本定理的证明</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 极限导论</title>
    <url>/calculus/calculus3/</url>
    <content><![CDATA[<h1 id="第三章-极限导论"><a href="#第三章-极限导论" class="headerlink" title="第三章 极限导论"></a>第三章 极限导论</h1><p>极限，$\lim\limits_{x \rightarrow 0}$<br>通常双侧极限在 $x=a$ 处存在，仅当左极限和右极限在 $x=a$ 处都存在且相等。用数学语言描述为：$\lim\limits_{x \rightarrow a^-}f(x)=L$ 且 $\lim\limits_{x \rightarrow a^+}f(x)=L$ 等价于 $\lim\limits_{x \rightarrow a}f(x)=L$<br>若左极限和右极限不相等，那么双侧极限不存在，缩写“DNE”不存在<br>关于“垂直渐近线”的正式定义<br>“$f$ 在 $x=a$ 处有一条垂直渐近线”说的是，$\lim\limits_{x \rightarrow a^+}f(x)$ 和 $\lim\limits_{x \rightarrow a^-}f(x)$，其中至少有一个极限是 $\infty$ 或 $-\infty$<br>关于“水平渐进线”的定义<br>“$f$ 在 $y=L$ 处有一条右侧水平渐近线”意味着 $\lim\limits_{x \rightarrow \infty}f(x)=L$<br>“$f$ 在 $y=M$ 处有一条左侧水平渐近线”意味着 $\lim\limits_{x \rightarrow -\infty}f(x)=M$<br>水平渐近线的可能数为0、1、2<br>垂直渐近线可以有很多条<br>一个函数可能与水平渐近线相交，例如 $y=\frac{sin(x)}{x},x＞3$<br>三明治定理（夹逼定理）<br>如果对于所有在 a 附近的 x 都有 $g(x) \leqslant f(x) \leqslant h(x)$，且 $\lim\limits_{x \rightarrow a}g(x)=\lim\limits_{x \rightarrow a}h(x)=L$，则 $\lim\limits_{x \rightarrow a}f(x)=L$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 三角学回顾</title>
    <url>/calculus/calculus2/</url>
    <content><![CDATA[<h1 id="第二章-三角学回顾"><a href="#第二章-三角学回顾" class="headerlink" title="第二章 三角学回顾"></a>第二章 三角学回顾</h1><ul>
<li>$正弦函数sin(\theta)$</li>
<li>$余弦函数cos(\theta)$</li>
<li>$正切函数tan(\theta)$</li>
<li>$余割函数csc(\theta)=\frac{1}{sin(\theta)}$</li>
<li>$正割函数sec(\theta)=\frac{1}{cos(\theta)}$</li>
<li>$余切函数cot(\theta)=\frac{1}{tan(\theta)}$</li>
</ul>
<p>毕达哥拉斯定理（勾股定理）：$在一个直角三角形中，直角边的平方之和等于斜边的平方，即a^2+b^2=c^2$<br>ASTC 方法判断各象限内三角函数的符号<br>三角函数的图像<br>留白，此处待补三角函数图像<br>三角函数的奇偶性，$sin(x)、tan(x)、cot(x)，及csc(x)都是x的奇函数，cos(x)和sec(x)都是x的偶函数$<br>三角恒等式<br>$tan(x)=\frac{sin(x)}{cos(x)}，cot(x)=\frac{cos(x)}{sin(x)}$<br>$cos^2(x)+sin^2(x)=1$（毕达哥拉斯定理）<br>$1+tan^2(x)=sec^2(x)$<br>$cot^2(x)+1=csc^2(x)$<br>$三角函数(x)=co-三角函数(\frac{π}{2}-x)$<br>例：</p>
<ul>
<li>$sin(x)=cos(\frac{π}{2}-x)$</li>
<li>$tan(x)=cot(\frac{π}{2}-x)$</li>
<li>$sec(x)=csc(\frac{π}{2}-x)$</li>
<li>$cos(x)=sin(\frac{π}{2}-x)$</li>
<li>$cot(x)=tan(\frac{π}{2}-x)$</li>
<li>$csc(x)=sec(\frac{π}{2}-x)$</li>
</ul>
<p>角的和<br>$sin(A+B)=sin(A)cos(B)+cos(A)sin(B)$<br>$cos(A+B)=cos(A)cos(B)-sin(A)sin(B)$</p>
<p>倍角公式<br>$sin(2x)=2sin(x)cos(x)$<br>$cos(2x)=2cos^2(x)-1=1-2sin^2(x)$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第18章 积分的方法 I</title>
    <url>/calculus/calculus18/</url>
    <content><![CDATA[<h1 id="第18章-积分的方法-I"><a href="#第18章-积分的方法-I" class="headerlink" title="第18章 积分的方法 I"></a>第18章 积分的方法 I</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><p>例子一枚：$\displaystyle\int x^2cos(x^3)dx$</p>
<ul>
<li>设 $t=x^3$，考虑用 $t$ 替代表达式中的每一个 $x$</li>
<li>$cos(x^3)$ 变为 $cos(t)$；因为 $t=x^3$，所以有 $\frac{dt}{dx}=3x^2$，将 $dx$ 移到等式右侧，有 $dt=3x^2dx$，等式两端同时除以 $3$ 得 $\frac{1}{3}dt=x^2dx$</li>
<li>$\displaystyle\int x^2cos(x^3)dx=\int cos(x^3)(x^2dx)=\int cos(t)(\frac{1}{3}dt)=\frac{1}{3}\int cos(t)dt=\frac{1}{3}sin(t)+C$</li>
<li>最后用 $x^3$ 替代 $t$ 即可</li>
<li>$\displaystyle\int x^2cos(x^3)dx=\frac{1}{3}sin(x^3)+C$</li>
</ul>
<p>如果 $f$ 是可导函数，那么 $\displaystyle\int \frac{f’(x)}{f(x)}dx=ln|f(x)|+C$</p>
<p>关于计算 $\sqrt[n]{ax+b}$ 这种类型的积分，我们有一个非常好的方法.可以简单地设 $\sqrt[n]{ax+b}$，在求 $dt$ 之前先两边同时 $n$ 次方，所以： 在换掉 $\sqrt[n]{ax+b}$ 之前，设 $t=\sqrt[n]{ax+b}$ 并对等式 $t^n=ax+b$ 两端求导<br>例：$\displaystyle\int x\sqrt[5]{3x+2}dx$</p>
<ul>
<li>设 $t=\sqrt[5]{3x+2}$</li>
<li>等式两端 $5$ 次方，得 $t^5=3x+2$</li>
<li>对新等式两端同时求导，得 $5t^4\frac{dt}{dx}=3$</li>
<li>进一步变形，得 $dx=\frac{5}{3}t^4dt$</li>
<li>写出关于$x$ 的表达式：$x=\frac{1}{3}(t^5-2)$</li>
<li>$\displaystyle\int x\sqrt[5]{3x+2}dx=\int \frac{1}{3}(t^5-2)(t)×\frac{5}{3}t^4dt$</li>
<li>$\displaystyle\frac{5}{9}\int (t^{10}-2t^5)dt=\frac{5}{99}t^{11}-\frac{5}{27}t^6+C$</li>
<li>再回到以 $x$ 为变量的积分：用 $t=(3x+2)^{\frac{1}{5}}$ 再替换得 $ \frac{5}{99}(3x+2)^{\frac{11}{5}}-\frac{5}{27}(3x+2)^{\frac{6}{5}}+C$</li>
</ul>
<p>对于<strong>不定积分</strong>，用 $t$ 和 $dt$ 分别表示带有 $x$ 的表达式和 $dx$，然后再求这个新的用 $t$ 表达的积分，最后再换回到 $x$<br>对于<strong>定积分</strong>，用 $t$ 和 $dt$ 分别表示带有 $x$ 的表达式和 $dx$，并且也要把积分上下限换为与 $t$ 相关，这时计算这个新的积分.当然也可以先求不定积分，再将积分上下限分别代入进行求解</p>
<p>如果 $u$ 和 $v$ 是关于 $x$ 的函数，则有 $\frac{d}{dx}(uv)=v\frac{du}{dx}+u\frac{dv}{dx}$<br>重写这个等式，然后两边同时再对 $x$ 求积分，得到 $\displaystyle\int u\frac{dv}{dx}dx=\int \frac{d}{dx}(uv)dx-\int v\frac{du}{dx}dx$<br>等式右侧的第一项是函数 $uv$ 导数的反导数，故证明 $\displaystyle\int u\frac{dv}{dx}dx=uv-\int v\frac{du}{dx}dx$<br>这就是分部积分公式</p>
<p>分部积分公式的简写形式，用 $dv$ 替代 $\frac{dv}{dx}dx$，用 $du$ 替代 $\frac{du}{dx}dx$，得到公式 $\displaystyle\int udv=uv-\int vdu$<br>该公式仅仅是简写形式</p>
<p>例子一枚：$\displaystyle\int xe^xdx$</p>
<ul>
<li>考虑使用分部积分法首先要得到 $\displaystyle\int udv$ 形式的积分</li>
<li>设 $u=x$，$dv=e^xdx$</li>
<li>这时我们有 $\displaystyle\int xe^xdx=\int udv$</li>
<li>然后考虑找到 $du$ 和 $v$</li>
<li>由于 $u=x$，所以 $du=dx$</li>
<li>关于 $v$，我们有 $dv=e^xdx$，同时对等式两侧求积分，$\displaystyle\int dv=\int e^xdx$，得到 $v=e^x$</li>
<li>采用分部积分法：<br>$\begin{aligned}<br>\int u\ \ \ dv\ \ &amp;=uv-\int vdu\\<br>\int x\ \overbrace{e^xdx}&amp;=xe^x-\int e^xdx<br>\end{aligned}$</li>
<li>$\displaystyle\int xe^xdx=xe^x-e^x+C$</li>
</ul>
<p>例子二枚：$\displaystyle\int x^2sin(x)dx$</p>
<ul>
<li>设 $u=x^2$，并且 $dv=sin(x)dx$</li>
<li>可以得到：<br>$\ \ u=x^2\ \ \ \ \ \ \ \ \ \ \ \ v=-cos(x)$<br>$du=2xdx\ \ \ \ \ dv=sin(x)dx$</li>
<li>使用分部积分法：<br>$\begin{aligned}<br>\int u\ \ \ \ \ \ \ dv\ \ \ \ \ \ &amp;=u\ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ -\int \ \ \ \ \ \ v\ \ \ \ \ \ \ \ du\\ \int x^2\overbrace{sin(x)dx}&amp;=x^2\overbrace{(-cos(x))}-\int \overbrace{-cos(x)}\overbrace{2xdx}\\&amp;=-x^2cos(x)+\int cos(x) \cdot 2xdx<br>\end{aligned}$</li>
<li>求解等式右侧的积分</li>
<li>假设 $U=x$ 并且 $dV=cos(x)dx$</li>
<li>可以得到：<br>$\ \ U=x\ \ \ \ \ \ \ \ \ V=sin(x)$<br>$dU=dx\ \ \ \ \ dV=cos(x)dx$</li>
<li>再次使用分部积分法：<br>$\begin{aligned}<br>\int U\ \ \ \ \ dV\ \ \ \ \ &amp;=U\ \ \ \ V\ \ \ \ -\int \ \ \ \ V\ \ \ \ dU\\ \int x\ \overbrace{cos(x)dx}&amp;=x\ sin(x)-\int sin(x)dx<br>\end{aligned}$</li>
<li>已知 $\displaystyle\int sin(x)dx=-cos(x)+C$，所以有 $\displaystyle\int xcos(x)dx=xsin(x)+cos(x)+C$</li>
<li>将这些结果代入原始表达式，得：<br>$\int x^2sin(x)dx=-x^2cos(x)+2xsin(x)+2cos(x)+C$</li>
</ul>
<p>求解有理函数的积分，计算积分 $$\int \frac{p(x)}{q(x)}dx$$</p>
<ul>
<li>第一步 <strong>先看分子分母最高项的次数，如有必要请做多项式除法</strong>，查看分子的次数是否小于分母次数.如果是，则进入第二步，否则做一个多项式除法，然后进入第二步</li>
<li>第二步 <strong>对分母进行因式分解</strong>，使用二次公式或猜想一个根，然后再做除法，以便因式分解被积函数的分母</li>
<li>第三步 <strong>分部</strong>，分别写出带有未知常数的“分部”，写下一个形如：被积函数=分部 的等式</li>
<li>第四步 <strong>计算常数的值</strong>，把方程的两边同时乘以分母，通过任一方法计算常数的值：(a) 换掉 $x$ 的值；(b) 系数相等法；或者结合使用 (a) 和 (b) 两种方法</li>
<li>第五步 <strong>分解分母为线性项次幂的积分</strong>，求解分母是线性函数次幂的积分；答案将会是对数形式或该线性项的负次幂</li>
<li>第六步 <strong>对分母是二次函数的被积函数求积分</strong>，对于分母是二次函数且不能因式分解的被积函数求积分，先配方，然后换元，再把它尽可能分解为两个积分，前者会涉及对数，而第二个会涉及正切函数的反函数，如果仅仅有一个积分，它可能是对数形式又可能是正切函数的反函数形式，这个公式通常是十分实用的：$\displaystyle\int \frac{1}{t^2+a^2}dt=\frac{1}{a}tan^{-1}\big(\frac{t}{a}\big)+C$</li>
</ul>
<p>例子</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 求解多项式的极限问题</title>
    <url>/calculus/calculus4/</url>
    <content><![CDATA[<h1 id="第四章-求解多项式的极限问题"><a href="#第四章-求解多项式的极限问题" class="headerlink" title="第四章 求解多项式的极限问题"></a>第四章 求解多项式的极限问题</h1><h2 id="求解-x-rightarrow-a-时的有理函数的极限"><a href="#求解-x-rightarrow-a-时的有理函数的极限" class="headerlink" title="求解 $x \rightarrow a$ 时的有理函数的极限"></a>求解 $x \rightarrow a$ 时的有理函数的极限</h2><ul>
<li>将 $x=a$ 代入表达式</li>
<li>如果能得到合理值，则此值为所求极限行，否则进行下一步</li>
<li>尝试进行因式分解，删除公因子后得到新表达式，扩大定义域后再次将 $x=a$ 代入进行计算</li>
<li>若求解后答案出现分母为 0 分子不为 0时，则有四种情况可能出现，同时在 $x=a$ 处会有一条垂直渐近线</li>
</ul>
<p>留白，待补图解</p>
<p>补充：立方差公式<br>$a^3-b^3=(a-b)(a^2+ab+b^2)$</p>
<h2 id="求解-x-rightarrow-a-时的平方根的极限"><a href="#求解-x-rightarrow-a-时的平方根的极限" class="headerlink" title="求解 $x \rightarrow a$ 时的平方根的极限"></a>求解 $x \rightarrow a$ 时的平方根的极限</h2><ul>
<li>首先尝试代入表达式求解</li>
<li>如果出现 $\frac{0}{0}$ 的不定式，考虑分子分母同时乘以分子的共轭表达式，即配方使分子可以使用完全平方公式，然后进行化简，再次求解</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的有理函数的极限"><a href="#求解-x-rightarrow-infty-时的有理函数的极限" class="headerlink" title="求解 $x \rightarrow \infty$ 时的有理函数的极限"></a>求解 $x \rightarrow \infty$ 时的有理函数的极限</h2><p>重要的多项式性质：当 x 很大时，首项决定一切。例如 $p(x)=3x^3-1000x^2+5x-7$，同时设 $p_L(x)=3x^3$，即 p 的首项，当 x 变得非常非常大时，$p(x)$ 和 $p_L(x)$ 会相对地非常接近，即 $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=1$<br>留白，待补为什么写成相比趋近于1，而非极限相同<br>证明结论： $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=1$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=\lim\limits_{x \rightarrow \infty}\frac{3x^3-1000x^2+5x-7}{3x^3}$</li>
<li>$\lim\limits_{x \rightarrow \infty}(\frac{3x^3}{3x^3}-\frac{1000x^2}{3x^3}+\frac{5x}{3x^3}-\frac{7}{3x^3})=\lim\limits_{x \rightarrow \infty}(1-\frac{1000}{3x}+\frac{5}{3x^2}-\frac{7}{3x^3})$</li>
<li>定理：对于任意的 $n&gt;0$ ，只要 C 是常数，就有 $\lim\limits_{x \rightarrow \infty}\frac{C}{x^n}=0$</li>
<li>$\lim\limits_{x \rightarrow \infty}(\frac{3x^3}{3x^3}-\frac{1000x^2}{3x^3}+\frac{5x}{3x^3}-\frac{7}{3x^3})=\lim\limits_{x \rightarrow \infty}(1-\frac{1000}{3x}+\frac{5}{3x^2}-\frac{7}{3x^3})=1-0+0-0=1$</li>
</ul>
<p>总结：$\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p(x)的首项}=1$，此方法适用于任意的多项式</p>
<p>一般的方法为 $\frac{p(x)}{p(x)的首项}×(p(x)的首项)$,对于每一个多项式都这样做，实例应用：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}=\lim\limits_{x \rightarrow \infty}\frac{\frac{x-8x^4}{-8x^4}×(-8x^4)}{\frac{7x^4+5x^3+2000x^2-6}{7x^4}×(7x^4)}=\lim\limits_{x \rightarrow \infty}\frac{-8x^4}{7x^4}=\frac{-8}{7}$</li>
</ul>
<p>一般地，考虑极限 $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{q(x)}$，<br>其中 p 和 q 为多项式，我们可以判断</p>
<ul>
<li>如果 p 的次数等于 q 的次数，则极限是有限的且非零</li>
<li>如果 p 的次数大于 q 的次数，则极限是 $\infty$ 或 $-\infty$</li>
<li>如果 p 的次数小于 q 的次数，则极限是 0</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的多项式型函数的极限"><a href="#求解-x-rightarrow-infty-时的多项式型函数的极限" class="headerlink" title="求解 $x \rightarrow \infty$ 时的多项式型函数的极限"></a>求解 $x \rightarrow \infty$ 时的多项式型函数的极限</h2><p>整体求解逻辑如之前提到的技巧类似<br>例子一枚：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{\sqrt{4x^6-5x^5}-2x^3}{\sqrt[3]{27x^6+8x}}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{\sqrt{4x^6-5x^5}-2x^3}{\sqrt[3]{27x^6+8x}}×\frac{\sqrt{4x^6-5x^5}+2x^3}{\sqrt{4x^6-5x^5}+2x^3}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{(4x^6-5x^5)-(2x^3)^2}{\sqrt[3]{27x^6+8x}(\sqrt{4x^6-5x^5}+2x^3)}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{-5x^5}{(\frac{\sqrt[3]{27x^6+8x}}{\sqrt[3]{27x^6}}×(3x^2))(\frac{\sqrt{4x^6-5x^5}+2x^3}{4x^3}×(4x^3))}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{1}{(\frac{\sqrt[3]{27x^6+8x}}{\sqrt[3]{27x^6}})(\frac{\sqrt{4x^6-5x^5}+2x^3}{4x^3})}×\frac{-5x^5}{(3x^2)(4x^3)}$</li>
<li>$\frac{-5}{12}$</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的有理函数的极限-1"><a href="#求解-x-rightarrow-infty-时的有理函数的极限-1" class="headerlink" title="求解 $x \rightarrow -\infty$ 时的有理函数的极限"></a>求解 $x \rightarrow -\infty$ 时的有理函数的极限</h2><p>基本求解逻辑与以上思路相近<br>补充总结：<br>如果 $x＜0$，并且想写 $\sqrt[n]{x^{某次幂}}=x^m$，那么需要在 $x^m$ 之前加一个负号的唯一情形是，n 是偶的而 m 是奇的</p>
<h2 id="求解包含绝对值的函数的极限"><a href="#求解包含绝对值的函数的极限" class="headerlink" title="求解包含绝对值的函数的极限"></a>求解包含绝对值的函数的极限</h2><p>分段处理</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 连续性和可导性</title>
    <url>/calculus/calculus5/</url>
    <content><![CDATA[<h1 id="第五章-连续性和可导性"><a href="#第五章-连续性和可导性" class="headerlink" title="第五章 连续性和可导性"></a>第五章 连续性和可导性</h1><p>关于在一点处连续：如果 $\lim\limits_{x \rightarrow a}f(x)=f(a)$，函数 f 在点 $x=a$ 处连续，若函数在某点连续，须明确以下三条成立</p>
<ul>
<li>双侧极限 $\lim\limits_{x \rightarrow a}f(x)$ 存在，且是有限的</li>
<li>函数在点 $x=a$ 处有定义，即 $f(a)$ 存在，且是有限的</li>
<li>$\lim\limits_{x \rightarrow a}f(x)=f(a)$</li>
</ul>
<p>关于区间上的连续性，需要区间中所有的点都连续，若区间为闭区间，则两端点需满足单侧连续性</p>
<p>一个连续函数的常数倍是连续的<br>两个连续函数做加减乘以及复合运算也会得到一个连续函数。当用一个连续函数除以另一个连续函数时，除了分母为零的点外，商函数处处连续。</p>
<p>介值定理：如果 f 在 $[a,b]$ 上连续，并且 $f(a)&lt;0$ 且 $f(b)&gt;0$，那么在区间 $(a,b)$ 上至少有一点 c ，使得 $f(c)=0$，代之以 $f(a)&gt;0$ 且 $f(b)&lt;0$，同样成立</p>
<p>一个区间是连续的，则在此区间内必然有极大极小值</p>
<p>导数，记作 $f’=\frac{dy}{dx}$</p>
<p>对导数再次求导得到的导数称为二阶导，写作 $f’’$</p>
<p>二阶导数，记作 $f’’=\frac{d^2y}{dx^2}$<br>高阶导数，记作 $f^{(n)}(x)$</p>
<p>若导数存在，那么左右导数都存在且等于导数值<br>存在不可导的连续函数，不存在不连续的可导函数<br>如果一个函数 $f$ 在 $x$ 上可导，那么它在 $x$ 上连续</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 隐函数求导和相关变化率</title>
    <url>/calculus/calculus8/</url>
    <content><![CDATA[<h1 id="第八章-隐函数求导和相关变化率"><a href="#第八章-隐函数求导和相关变化率" class="headerlink" title="第八章 隐函数求导和相关变化率"></a>第八章 隐函数求导和相关变化率</h1><p><strong>隐函数的求导</strong></p>
<ul>
<li>在原始方程中，对一切求导并使用链式求导法则、乘积法则、以及商法则进行化简</li>
<li>如果求的是特定值的斜率，则么先代入 x 和 y 的已知值，整理求出 $\frac{dy}{dx}$</li>
</ul>
<p><strong>隐函数求二次导</strong>，是在一次导的情况下再对每一项做一次求导运算，得到结果中可能有一阶导数，记得代入计算即可</p>
<p><strong>相关变化率</strong>，量 $Q$ 的变化率是 $Q$ 关于时间的导数，也就是说，如果 $Q$ 是某个量，那么 $Q$ 的变化率是 $\frac{dQ}{dt}$</p>
<p>求解相关变化率问题的一般方法</p>
<ul>
<li>读题，识别出所有的量并注意到哪一个量是你需要对其求相关变化率的</li>
<li>写出一个关联所有量的方程(有时可能不止一个方程)</li>
<li>对剩余的方程关于时间 t 做隐函数求导，对每一个方程两边添加一个 $\frac{d}{dt}$，得到一个或多个关联起各个变化率的方程</li>
<li>最后将所有已知值代入所有方程中做替换，联立求解方程得到所求解的变化率</li>
</ul>
<p>留白，待补例题 n 个</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 三角函数的极限和导数</title>
    <url>/calculus/calculus7/</url>
    <content><![CDATA[<h1 id="第七章-三角函数的极限和导数"><a href="#第七章-三角函数的极限和导数" class="headerlink" title="第七章 三角函数的极限和导数"></a>第七章 三角函数的极限和导数</h1><p>学会判断极限中实际上是大数还是小数<br>重要的公式</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=1$</li>
<li>$\lim\limits_{x \rightarrow 0}cos(x)=1$</li>
<li>$\lim\limits_{x \rightarrow 0}\frac{tan(x)}{x}=1$</li>
<li>$\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{x}=0$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{sin(x)}{x}=0$ (三明治定理证明)</li>
<li>学会换元求解</li>
<li>学会借助 $-1 \leq sin(x) \leq 1$ 以及 $-1 \leq cos(x) \leq 1$ 的不等式拓展，从而通过求出多项式型的极限，进而使用三明治定理，求出含三角函数的极限</li>
<li>对于任意的正指数 $\alpha$ :$\lim\limits_{x \rightarrow \infty}\frac{sin(任何东西)}{x^\alpha}=0$</li>
</ul>
<p>$sin(x)$ 表现的像 x，仅在乘积或商的语境中才成立，除了常数函数 0 本身，没有任何函数表现得像 0</p>
<p>面对 $x \rightarrow a$ 的极限，而 $a \neq 0$ 时，有一个很好的的一般原则，那就是用 $t = x - a$ 作替换，将问题转化为 $t \rightarrow 0$<br>例子一枚：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \frac{π}{2}}\frac{cos(x)}{x-\frac{π}{2}}$</li>
<li>$\lim\limits_{t \rightarrow 0}\frac{cos(t+\frac{π}{2})}{t}$</li>
<li>三角恒等式 $cos(\frac{π}{2}-x)=sin(x)$</li>
<li>$cos(\frac{π}{2}+t)=sin(-t)=-sin(t)$</li>
<li>$\lim\limits_{t \rightarrow 0}\frac{-sin(t)}{t}=-1$</li>
</ul>
<p>重要证明 $\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=1$</p>
<ul>
<li>$\frac{sin(x)}{2} &lt; \frac{x}{2} &lt; \frac{tan(x)}{2}$</li>
<li>$sin(x) &lt; x &lt; tan(x),0 &lt; x &lt; \frac{π}{2}$</li>
<li>$\frac{1}{sin(x)} &gt; \frac{1}{x} &gt; \frac{cos(x)}{sin(x)}$</li>
<li>$cos(x) &lt; \frac{sin(x)}{x} &lt; 1$</li>
<li>运用三明治定理证明左右极限</li>
</ul>
<p>留白，待补三角函数求导总结</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 求解微分问题</title>
    <url>/calculus/calculus6/</url>
    <content><![CDATA[<h1 id="第六章-求解微分问题"><a href="#第六章-求解微分问题" class="headerlink" title="第六章 求解微分问题"></a>第六章 求解微分问题</h1><p>使用导数的定义求导，即 $f’(x)=\lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}$<br>留白，待补微分求导图<br>乘积法则版本1：如果 $h(x)=f(x)g(x)$，那么 $h’(x)=f’(x)g(x)+f(x)g’(x)$<br>乘积法则版本2：如果 $y=uv$，则 $\frac{dy}{dx}=v\frac{du}{dx}+u\frac{dv}{dx}$<br>乘积法则(三个变量)：如果 $y=uvw$，那么 $\frac{dy}{dx}=\frac{du}{dx}vw+u\frac{dv}{dx}w+uv\frac{dw}{dx}$<br>商法则(版本1)：如果 $h(x)=\frac{f(x)}{g(x)}$，那么 $h’(x)=\frac{f’(x)g(x)-f(x)g’(x)}{(g(x))^2}$<br>商法则(版本2)：如果 $y=\frac{u}{v}$，那么 $\frac{dy}{dx}=\frac{v\frac{du}{dx}-u\frac{dv}{dx}}{v^2}$<br>链式求导法则求复合函数的导数<br>链式求导法则(版本1)：如果 $h(x)=f(g(x))$，那么 $h’(x)=f’(g(x))g’(x)$<br>链式求导法则(版本2)：如果 $y$ 是 $u$ 的函数，并且 $u$ 是 $x$ 的函数，那么 $\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$<br>极限可能是伪装的导数</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 指数函数和对数函数</title>
    <url>/calculus/calculus9/</url>
    <content><![CDATA[<h1 id="第九章-指数函数和对数函数"><a href="#第九章-指数函数和对数函数" class="headerlink" title="第九章 指数函数和对数函数"></a>第九章 指数函数和对数函数</h1><h2 id="指数法则"><a href="#指数法则" class="headerlink" title="指数法则"></a>指数法则</h2><ul>
<li>$b^0=1$ 任意非零数的零次幂是 $1$</li>
<li>$b^1=b$ 一个数的一次幂正好是该数本身</li>
<li>$b^xb^y=b^{x+y}$ 当将两个底数相同的幂相乘时，将指数相加</li>
<li>$\frac{b^x}{b^y}=b^{x-y}$ 当将两个底数相同的幂相除时，将分子的指数减去分母的指数</li>
<li>$(b^x)^y=b^{xy}$ 当取幂的幂时，将指数相乘</li>
</ul>
<p>$log_b(y)$ 是为了得到 $y$ 你必须将底数 $b$ 提升的幂次，即 $b^{log_b(y)}=y$</p>
<p>指数函数和对数函数为反函数</p>
<p>对数的指数就是原始的数，即 $log_b(b^x)=x$ (对于任意的实数 $x$ 及 $b&gt;1$)</p>
<h2 id="对数法则"><a href="#对数法则" class="headerlink" title="对数法则"></a>对数法则</h2><ul>
<li>$log_b(1)=0$</li>
<li>$log_b(b)=1$</li>
<li>$log_b(xy)=log_b(x)+log_b(y)$ 乘积的对数是对数的和</li>
<li>$log_b(\frac{x}{y})=log_b(x)-log_b(y)$ 商的对数是对数的差</li>
<li>$log_b(x^y)=ylog_b(x)$ 对数将指数移至对数之前，该方法中，$y$ 可以是任意的实数</li>
<li>换底法则，对于任意的底数 $b&gt;1$ 和 $c&gt;1$ 及任意的数 $x&gt;0$，$log_b(x)=\frac{log_c(x)}{log_c(b)}$，这意味着，所有的不同底数的对数函数其实是互为常数倍的，即 $log_b(x)=Klog_c(x)$</li>
</ul>
<p>留白，待补相关证明(*)</p>
<p>底数为 $e$ 的对数称为自然对数</p>
<p>留白，待补关于 $\lim\limits_{h \rightarrow 0^-}(1+rh)^{\frac{1}{h}}$ 的左极限证明</p>
<h2 id="关于-e-的公式"><a href="#关于-e-的公式" class="headerlink" title="关于 $e$ 的公式"></a>关于 $e$ 的公式</h2><ul>
<li>$\lim\limits_{n \rightarrow \infty}(1+\frac{x}{n})^n=e^x$</li>
<li>$\lim\limits_{h \rightarrow 0}(1+xh)^{\frac{1}{h}}=e^x$</li>
<li>$\lim\limits_{n \rightarrow \infty}(1+\frac{1}{n})^n=e$</li>
<li>$\lim\limits_{h \rightarrow 0}(1+h)^{\frac{1}{h}}=e$</li>
</ul>
<p>令 $g(x)=log_b(x)$，对 $g$ 求导</p>
<ul>
<li>根据导数定义，<br>$\begin{aligned}<br>g’(x) &amp;=\lim\limits_{h \rightarrow 0}\frac{g’(x+h)-g(x)}{h}\<br>&amp;=\lim\limits_{h \rightarrow 0}\frac{log_b(x+h)-log_b(x)}{h}\<br>&amp;=\lim\limits_{h \rightarrow 0}\frac{1}{h}log_b(\frac{x+h}{x})\<br>&amp;=\lim\limits_{h \rightarrow 0}log_b(1+\frac{h}{x})^{\frac{1}{h}}\<br>&amp;=log_b(e^{\frac{1}{x}})<br>\end{aligned}$</li>
<li>$\frac{d}{dx}log_b(x)=\frac{1}{x}log_b(e)$</li>
<li>若设 $b=e$，那么就能得到以 $e$ 为底的对数的导数了，即 $\ \frac{d}{dx}log_e(x)=\frac{1}{x}log_e(e)=\frac{1}{x}$</li>
</ul>
<p>得到重要公式</p>
<ul>
<li>$\frac{d}{dx}ln(x)=\frac{1}{x}$</li>
<li>$\frac{d}{dx}log_b(x)=\frac{1}{xln(b)}$$(log_b(e)=\frac{log_e(e)}{log_e(b)}=\frac{1}{ln(b)})$</li>
</ul>
<p>推导指数函数导数 $y=b^x$</p>
<ul>
<li>$y=b^x$</li>
<li>$x=log_b(y)$</li>
<li>对上述公式关于 $y$ 求导</li>
<li>$\frac{dx}{dy}=\frac{1}{yln(b)}$</li>
<li>根据链式求导法则，可上下颠倒得到</li>
<li>$\frac{dy}{dx}=yln(b)$</li>
<li>由于 $y=b^x$，故证明以下公式</li>
<li>$\frac{d}{dx}(b^x)=b^xln(b)$</li>
<li>特别地，$\frac{d}{dx}(e^x)=e^x$</li>
</ul>
<p>$\lim\limits_{h \rightarrow 0}\frac{e^h-1}{h}=1$<br>证明：</p>
<ul>
<li>根据极限定义 $\ \lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}=f’(x)$</li>
<li>变为 $\lim\limits_{h \rightarrow 0}\frac{e^{x+h}-e^x}{h}=e^x$</li>
<li>用 $0$ 替换 $x$ 即可得到 $\lim\limits_{h \rightarrow 0}\frac{e^h-1}{h}=1$</li>
</ul>
<p>求解 $\lim\limits_{h \rightarrow 0}\frac{ln(1+h)}{h}$</p>
<ul>
<li>这是一个导数伪装的极限</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}=f’(x)$</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{ln(x+h)-ln(x)}{h}=\frac{1}{x}$</li>
<li>将 $x=1$ 代入，并得到</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{ln(1+h)-ln(1)}{h}=1$</li>
<li>结论 $\lim\limits_{h \rightarrow 0}\frac{ln(1+h)}{h}=1$</li>
</ul>
<p>例子一枚：</p>
<ul>
<li>求解 $\lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{5h^2}$</li>
<li>$\ \ \ \ \lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{5h^2}\ =\lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{-7h^2}×\frac{-7h^2}{5h^2}\ =\frac{-7}{5}$</li>
</ul>
<p>$\lim\limits_{x \rightarrow \infty}e^x=\infty$<br>$\lim\limits_{x \rightarrow -\infty}e^x=0$</p>
<p>指数函数增长迅速，$\lim\limits_{x \rightarrow \infty}\frac{x^n}{e^x}=0$<br>其中 $x^n$ 可替换为多项式型函数，$e^x$ 可替换为指数为大的、正的多项式型指数函数，陈述依然成立</p>
<p>$\lim\limits_{x \rightarrow \infty}ln(x)=\infty$</p>
<p>对数函数增长缓慢，不管 $a$ 有多小，如果 $a&gt;0$，$\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{x^a}=0$<br>其中 $ln(x)$ 可替换为任何正的多项式型的对数函数，$x^a$ 可替换为具有正的幂次的多项式型函数，陈述依然成立</p>
<p>对数函数和指数函数互为反函数，如果你取 $\frac{ln(x)}{x^a}$，并用 $e^t$ 替换 $x$，那么你会得到<br>$\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{x^a}=\lim\limits_{t \rightarrow \infty}\frac{ln(e^t)}{(e^t)^a}=\lim\limits_{t \rightarrow \infty}\frac{t}{e^{at}}=0$<br>这样就证明了指数函数增长迅速这一事实会自动导出对数函数增长缓慢这一结论</p>
<p>求解极限 $\lim\limits_{x \rightarrow 0^+}xln(x)$</p>
<ul>
<li>首先考虑我们直接代入，因为 $ln(0)$ 不存在，所以不能这样求解</li>
<li>我们用 $\frac{1}{t}$ 替换 $x$，于是当 $x \rightarrow 0^+$ 时，可以得到 $t \rightarrow \infty$，因此有</li>
<li>$\lim\limits_{x \rightarrow 0^+}xln(x)=\lim\limits_{t \rightarrow \infty}\frac{1}{t}ln(\frac{1}{t})$</li>
<li>$ln(\frac{1}{t})=ln(1)-ln(t)=-ln(t)$</li>
<li>$\lim\limits_{t \rightarrow \infty}\frac{1}{t}ln(\frac{1}{t})=\lim\limits_{t \rightarrow \infty}\frac{-ln(t)}{t}=0$</li>
<li>由于对数函数增长缓慢，故极限是0</li>
<li>技巧：用 $\frac{1}{t}$ 替换 $x$ 可以将对数函数在 $0$ 附近的行为转换为在 $\infty$ 附近的行为</li>
</ul>
<p>对数函数在 $0$ 附近“增长缓慢”：不管 $a$ 有多小，如果 $a&gt;0$，$\lim\limits_{x \rightarrow 0^+}x^aln(x)=0$<br>其中 $x^a$ 可替换为任何多项式型函数，$ln(x)$ 的底数可替换为任意其他大于 1 的底数，陈述依然成立</p>
<p>对形如 $f(x)^{g(x)}$ 的函数关于 $x$ 求导</p>
<ul>
<li>设 $y$ 是想要求导的 $x$ 的函数<br>$y=f(x)^{g(x)}$</li>
<li>对等号两边取对数，右边的指数 $g$得以移动下来<br>$ln(y)=ln(f(x)^{g(x)})=g(x)ln(f(x))$</li>
<li>对等号两边关于 $x$ 做隐函数求导</li>
<li>用 $f(x)^{g(x)}$ 替换 $y$，求出 $\frac{dy}{dx}$，完成求解</li>
</ul>
<p>学会使用取对数求导</p>
<ul>
<li>$\frac{d}{dx}(x^a)=ax^{a-1}$</li>
<li>证明<br>$\begin{aligned}<br>y&amp;=x^a\<br>ln(y)&amp;=aln(x)\<br>\frac{1}{y}\frac{dy}{dx}&amp;=\frac{a}{x}\<br>\frac{dy}{dx}&amp;=\frac{ay}{x}\<br>\frac{dy}{dx}&amp;=\frac{ax^a}{x}\<br>\frac{dy}{dx}&amp;=ax^{a-1}<br>\end{aligned}$</li>
</ul>
<p>如果 $\frac{dy}{dx}=ky$，那么 $y=Ae^{kx}$，其中 $A$ 为某个常数</p>
<p>指数增长方程：$P(t)=P_0e^{kt}$<br>其中 $P_0$是初始的总数，$k$ 是增长常数</p>
<h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><p>双曲余弦函数 $cosh(x)=\frac{e^x+e^{-x}}{2}$<br>双曲正弦函数 $sinh(x)=\frac{e^x-e^{-x}}{2}$</p>
<ul>
<li>$cosh^2(x)=(\frac{e^x+e^{-x}}{2})^2=\frac{e^{2x}+e^{-2x}+2}{4}$</li>
<li>$sinh^2(x)=(\frac{e^x-e^{-x}}{2})^2=\frac{e^{2x}+e^{-2x}-2}{4}$</li>
<li>$cosh^2(x)-sinh^2(x)=1$</li>
</ul>
<p>$\frac{d}{dx}sinh(x)=cosh(x)$<br>$\frac{d}{dx}cosh(x)=sinh(x)$</p>
<ul>
<li>$\frac{d}{dx}sinh(x)=\frac{d}{dx}(\frac{e^x-e^{-x}}{2})=\frac{e^x+e^{-x}}{2}=cosh(x)$</li>
<li>$\frac{d}{dx}cosh(x)=\frac{d}{dx}(\frac{e^x+e^{-x}}{2})=\frac{e^x-e^{-x}}{2}=sinh(x)$</li>
</ul>
<p>留白，待补双曲函数图像</p>
<p>关于双曲函数的导数</p>
<ul>
<li>$\frac{d}{dx}sinh(x)=cosh(x)$</li>
<li>$\frac{d}{dx}cosh(x)=sinh(x)$</li>
<li>$\frac{d}{dx}tanh(x)=sech^2(x)$</li>
<li>$\frac{d}{dx}sech(x)=-sech(x)tanh(x)$</li>
<li>$\frac{d}{dx}csch(x)=-csch(x)coth(x)$</li>
<li>$\frac{d}{dx}coth(x)=-csch^2(x)$</li>
</ul>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
</search>
