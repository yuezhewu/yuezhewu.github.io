<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Part 4.2 背包动态规划题解</title>
    <url>/luogu4-2-problems/</url>
    <content><![CDATA[<h1 id="Part-4-2-背包动态规划题解"><a href="#Part-4-2-背包动态规划题解" class="headerlink" title="Part 4.2 背包动态规划题解"></a>Part 4.2 背包动态规划题解</h1><h2 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h2><h3 id="题目链接：-NOIP2005-普及组-采药-洛谷"><a href="#题目链接：-NOIP2005-普及组-采药-洛谷" class="headerlink" title="题目链接：[NOIP2005 普及组] 采药 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1048">[NOIP2005 普及组] 采药 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>01背包模板题，必须记住并且理解。复杂度 $O(n^2)$</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> t,n,w[<span class="number">105</span>],v[<span class="number">105</span>],dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=w[i];j--) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1060-开心的金明"><a href="#P1060-开心的金明" class="headerlink" title="P1060 开心的金明"></a>P1060 开心的金明</h2><h3 id="题目链接：-NOIP2006-普及组-开心的金明-洛谷"><a href="#题目链接：-NOIP2006-普及组-开心的金明-洛谷" class="headerlink" title="题目链接：[NOIP2006 普及组] 开心的金明 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1060">[NOIP2006 普及组] 开心的金明 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>妈妈昨天对金明说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v[j]$，重要度为 $w[j]$，共选中了 $k$ 件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：</p>
<p>$v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[j_k] \times w[j_k]$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>01背包模型模板题，方法与采药相同。复杂度 $O(n^2)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> t,n,w[<span class="number">30</span>],v[<span class="number">30</span>],dp[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        v[i]*=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=w[i];j--) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[t]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1855-榨取kkksc03"><a href="#P1855-榨取kkksc03" class="headerlink" title="P1855 榨取kkksc03"></a>P1855 榨取kkksc03</h2><h3 id="题目链接：榨取kkksc03-洛谷"><a href="#题目链接：榨取kkksc03-洛谷" class="headerlink" title="题目链接：榨取kkksc03 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1855">榨取kkksc03 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>01背包模型的变形，多加了一种影响因素，只需在原有基础上多加一维循环即可。复杂度 $O(NMT)$</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ww,tt,w[<span class="number">105</span>],t[<span class="number">105</span>],dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;ww,&amp;tt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=ww;j&gt;=w[i];j--)<span class="comment">//金钱</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=tt;k&gt;=t[i];k--)<span class="comment">//时间</span></span><br><span class="line">                dp[j][k]=<span class="built_in">max</span>(dp[j][k],dp[j-w[i]][k-t[i]]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[ww][tt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5020-货币系统"><a href="#P5020-货币系统" class="headerlink" title="P5020 货币系统"></a>P5020 货币系统</h2><h3 id="题目链接：-NOIP2018-提高组-货币系统-洛谷"><a href="#题目链接：-NOIP2018-提高组-货币系统-洛谷" class="headerlink" title="题目链接：[NOIP2018 提高组] 货币系统 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5020">[NOIP2018 提高组] 货币系统 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 </p>
<p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 </p>
<p>两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p>
<p>现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>参照筛法的思想和完全背包统计方案数的做法，用已有的数筛去能被表达的数，剩余的数则为最小的集合。复杂度 $O(NM)$ </p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">105</span>],dp[<span class="number">25005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);<span class="comment">//集合内最小的数必然被保留</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//完全背包统计方案的做法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[a[i]]) cnt++;<span class="comment">//判断是否被筛去</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=a[n];j++)</span><br><span class="line">                dp[j]+=dp[j-a[i]];<span class="comment">//方案数大于0则被筛去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a>P1757 通天之分组背包</h2><h3 id="题目链接：通天之分组背包-洛谷"><a href="#题目链接：通天之分组背包-洛谷" class="headerlink" title="题目链接：通天之分组背包 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1757">通天之分组背包 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>一天，小 A 去远游，却发现他的背包不同于 01 背包，他的物品大致可分为 k 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>分组背包模型模板题</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> ww,n,mm,w[<span class="number">1005</span>],v[<span class="number">1005</span>],dp[<span class="number">1005</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[<span class="number">1002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ww,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;w[i],&amp;v[i],&amp;x);</span><br><span class="line">        p[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">        mm=<span class="built_in">max</span>(mm,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mm;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=ww;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;p[i].<span class="built_in">size</span>();k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=w[p[i][k]]) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[p[i][k]]]+v[p[i][k]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[ww]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1064-金明的预算方案"><a href="#P1064-金明的预算方案" class="headerlink" title="P1064 金明的预算方案"></a>P1064 金明的预算方案</h2><h3 id="题目链接：-NOIP2006-提高组-金明的预算方案-洛谷"><a href="#题目链接：-NOIP2006-提高组-金明的预算方案-洛谷" class="headerlink" title="题目链接：[NOIP2006 提高组] 金明的预算方案 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1064">[NOIP2006 提高组] 金明的预算方案 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>妈妈昨天对金明说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
<table>
<thead>
<tr>
<th align="center">主件</th>
<th align="center">附件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电脑</td>
<td align="center">打印机，扫描仪</td>
</tr>
<tr>
<td align="center">书柜</td>
<td align="center">图书</td>
</tr>
<tr>
<td align="center">书桌</td>
<td align="center">台灯，文具</td>
</tr>
<tr>
<td align="center">工作椅</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p>
<p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>题目是一道有依赖的分组背包问题，对于每个主件以及它的配件，根据题意可以组合成分组背包的同一组内的不同的物品，然后套用分组背包的解决方案即可解决。</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m, n, mw[<span class="number">33333</span>], mv[<span class="number">33333</span>], fw[<span class="number">33333</span>][<span class="number">3</span>], fv[<span class="number">33333</span>][<span class="number">3</span>], f[<span class="number">33333</span>], v, p, q;</span><br><span class="line"><span class="comment">//mw主件重量，mv主件价值，fw主件对应的附件重量，fv主副价值，n总重量，m总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (!q) &#123; <span class="comment">//如果是主件</span></span><br><span class="line">            mw[i] = v; <span class="comment">//主件重量</span></span><br><span class="line">            mv[i] = v * p; <span class="comment">//主件价值与重量乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果是附件</span></span><br><span class="line">            fw[q][<span class="number">0</span>]++;<span class="comment">//记录主件的附件个数（只记录在fw就行，fv那里没用</span></span><br><span class="line">            fw[q][fw[q][<span class="number">0</span>]] = v; <span class="comment">//主件的个数是用来确定该附件应该填在第一个还是第二个格子里</span></span><br><span class="line">            fv[q][fw[q][<span class="number">0</span>]] = v * p; <span class="comment">//（是第一个还是第二个附件）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= mw[i]; j--) &#123; <span class="comment">//01背包模板</span></span><br><span class="line">            <span class="comment">//每一个if的前提是背包能不能装下该物品</span></span><br><span class="line">            <span class="comment">//情况1：只要主件 和啥都不要比较</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i]] + mv[i]);</span><br><span class="line">            <span class="comment">//情况2：主件和附件1 和上面选出的较大值比较</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">1</span>])f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">1</span>]] + mv[i] + fv[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//情况3：主件和附件2 和上面选出的较大值比较</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">2</span>])f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">2</span>]] + mv[i] + fv[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">//情况4：都要</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= mw[i] + fw[i][<span class="number">1</span>] + fw[i][<span class="number">2</span>])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - mw[i] - fw[i][<span class="number">1</span>] - fw[i][<span class="number">2</span>]] + mv[i] + fv[i][<span class="number">1</span>] + fv[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//输出在价值为n时能得到的最大值</span></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2946-Cow-Frisbee-Team-S"><a href="#P2946-Cow-Frisbee-Team-S" class="headerlink" title="P2946 Cow Frisbee Team S"></a>P2946 Cow Frisbee Team S</h2><h3 id="题目链接：-USACO09MAR-Cow-Frisbee-Team-S-洛谷"><a href="#题目链接：-USACO09MAR-Cow-Frisbee-Team-S-洛谷" class="headerlink" title="题目链接：[USACO09MAR]Cow Frisbee Team S - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2946">[USACO09MAR]Cow Frisbee Team S - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>约翰打算从他家的 $N$ 头奶牛中选出一支队伍。</p>
<p>每只奶牛的能力为整数，第 $i$ 头奶牛的能力为$R_i$ 。飞盘队的队员数量不能少于 $1$ 、大于$N$。一支队伍的总能力就是所有队员能力的总和。约翰比较迷信，他的幸运数字是 $F$ ，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>类似 01 背包的求方案数问题，对于每头牛都有选或不选两种选择，用 $dp[i][j]$ 表示在前 $i$ 头牛中选择的和（mod F）为 $j$ 的方案数。</p>
<p>对于 $dp[i][j]$</p>
<ul>
<li><p>不选 $i$ ，则为前 $i-1$ 头牛中和为 $j$ 的方案数 $dp[i-1][j]$</p>
</li>
<li><p>选 $j$ ，则为前 $i-1$ 头牛中与 $a[i]$ 相加为 $j$ 的数量，即 $dp[i-1][j-a[i]]$</p>
</li>
<li><p>综合上面的选择方案，转移方程为 $dp[i][j]=dp[i][j]+dp[i-1][j]+dp[i-1][(j-a[i]+m)\%m]$</p>
</li>
<li><p>$j-a[i]$ 可能为负数，由于是考虑取模问题，故仅需加上模数再取模即可</p>
</li>
</ul>
<p>复杂度 $O(nm)$</p>
<h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">2005</span>],dp[<span class="number">2005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);a[i]%=m;dp[i][a[i]]=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][(j-a[i]+m)%m])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1156-垃圾陷阱"><a href="#P1156-垃圾陷阱" class="headerlink" title="P1156 垃圾陷阱"></a>P1156 垃圾陷阱</h2><h3 id="题目链接：垃圾陷阱"><a href="#题目链接：垃圾陷阱" class="headerlink" title="题目链接：垃圾陷阱"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱</a></h3><h3 id="题面：-7"><a href="#题面：-7" class="headerlink" title="题面："></a>题面：</h3><p>卡门――农夫约翰极其珍视的一条 <code>Holsteins</code> 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内没有进食，卡门就将饿死。</p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>类似于 01 背包，但是不选会对状态造成影响，把高度当作是动态规划的边界，$f[i]$ 表示高度为 $i$ 时的最大生命值，采用刷表法对未知变量进行更新。</p>
<h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="type">int</span> n,D;</span><br><span class="line"><span class="type">int</span> f[maxn*<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,health,hight;</span><br><span class="line">&#125;r[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Rub a,Rub b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;D,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;r[i].t,&amp;r[i].health,&amp;r[i].hight);</span><br><span class="line">    <span class="built_in">sort</span>(r+<span class="number">1</span>,r+<span class="number">1</span>+n,cmp);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=D;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(f[j] &gt;= r[i].t)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j+r[i].hight&gt;=D)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r[i].t);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[j+r[i].hight]=<span class="built_in">max</span>(f[j+r[i].hight],f[j]);</span><br><span class="line">                f[j]+=r[i].health;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5322-排兵布阵"><a href="#P5322-排兵布阵" class="headerlink" title="P5322 排兵布阵"></a>P5322 排兵布阵</h2><h3 id="题目链接：-BJOI2019-排兵布阵-洛谷"><a href="#题目链接：-BJOI2019-排兵布阵-洛谷" class="headerlink" title="题目链接：[BJOI2019] 排兵布阵 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5322">[BJOI2019] 排兵布阵 - 洛谷</a></h3><h3 id="题面：-8"><a href="#题面：-8" class="headerlink" title="题面："></a>题面：</h3><p>小 C 正在玩一款排兵布阵的游戏。在游戏中有 $n$ 座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 $m$ 名士兵，可以向第 $i$ 座城堡派遣 $a_i$ 名士兵去争夺这个城堡，使得总士兵数不超过 $m$。   </p>
<p>如果一名玩家向第 $i$ 座城堡派遣的士兵数<strong>严格</strong>大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得 $i$ 分。  </p>
<p>现在小 C 即将和其他 $s$ 名玩家两两对战，这 $s$ 场对决的派遣士兵方案必须相同。小 C 通过某些途径得知了其他 $s$ 名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。   </p>
<p>由于答案可能不唯一，你只需要输出小 C 总分的最大值。</p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>非常好的一道分组背包模型题，可以将每个城堡看做是一组，每个玩家是一个组内的物品。组内排序后，物品的价值即为所获分数 $i∗s$，体积为攻打所需兵力 $2∗i_s​+1$，而背包体积就是兵力 $m$</p>
<h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> s,n,m,a[<span class="number">105</span>][<span class="number">105</span>],dp[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[j][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">sort</span>(a[i]+<span class="number">1</span>,a[i]+<span class="number">1</span>+s);<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//分组背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">2</span>*a[i][k]+<span class="number">1</span>) dp[j]=<span class="built_in">max</span>(dp[j],dp[j<span class="number">-2</span>*a[i][k]<span class="number">-1</span>]+k*i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[m]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.1 线性动态规划题解</title>
    <url>/luogu4-1-problems/</url>
    <content><![CDATA[<h1 id="Part-4-1-线性动态规划题解"><a href="#Part-4-1-线性动态规划题解" class="headerlink" title="Part 4.1 线性动态规划题解"></a>Part 4.1 线性动态规划题解</h1><h2 id="P1216-数字三角形"><a href="#P1216-数字三角形" class="headerlink" title="P1216 数字三角形"></a>P1216 数字三角形</h2><h3 id="题目链接：-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷"><a href="#题目链接：-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷" class="headerlink" title="题目链接：[USACO1.5][IOI1994]数字三角形 Number Triangles - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1216">[USACO1.5][IOI1994]数字三角形 Number Triangles - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        <span class="number">7</span> </span><br><span class="line">      <span class="number">3</span>   <span class="number">8</span> </span><br><span class="line">    <span class="number">8</span>   <span class="number">1</span>   <span class="number">0</span> </span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>在上面的样例中,从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每一个位置所能得到的最大值均由上一层的对应位置的最大值转移而来，故考虑用 $f[i][j]$ 表示到达第 $i$ 层第 $j$ 个位置时的最大值，复杂度 $O(n^2)$</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>],ma;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);<span class="comment">//读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)<span class="comment">//因为只用到上一层加和结果，所以没有另开数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>) a[i][j]+=a[i<span class="number">-1</span>][j];<span class="comment">//考虑边界情况，最左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==i) a[i][j]+=a[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//考虑边界情况，最右边</span></span><br><span class="line">            <span class="keyword">else</span> a[i][j]+=<span class="built_in">max</span>(a[i<span class="number">-1</span>][j<span class="number">-1</span>],a[i<span class="number">-1</span>][j]);<span class="comment">//比较最大值，进行选择</span></span><br><span class="line">            <span class="keyword">if</span>(i==n) ma=<span class="built_in">max</span>(ma,a[i][j]);<span class="comment">//记录最后一行的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1020-导弹拦截"><a href="#P1020-导弹拦截" class="headerlink" title="P1020 导弹拦截"></a>P1020 导弹拦截</h2><h3 id="题目链接：-NOIP1999-普及组-导弹拦截-洛谷"><a href="#题目链接：-NOIP1999-普及组-导弹拦截-洛谷" class="headerlink" title="题目链接：[NOIP1999 普及组] 导弹拦截 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1020">[NOIP1999 普及组] 导弹拦截 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>对于第一个问题，答案为求解最长不上升子序列的长度，这是一个经典的线性动态规划模型</p>
<p>对于第二个问题，抽象出来就是考虑把一个数列划分成最少数量的最长不上升子序列，解决这个问题需要引入一个定理，<strong>Dilworth</strong>定理</p>
<ul>
<li><p><strong>Dilworth</strong> 定理：对于一个偏序集，最少链划分等于最长反链长度</p>
</li>
<li><p><strong>Dilworth</strong> 定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度</p>
</li>
</ul>
<p>简而言之，将一个数列划分成最少的<strong>不上升子序列的数目</strong>就等于这个<strong>数列最长上升子序列的长度</strong>，因此只需求两次最长上升子序列（LIS）即可，复杂度 $O(n\log n)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> idx=<span class="number">0</span>,a[<span class="number">100005</span>],dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a[++idx]);idx--;<span class="comment">//动态读入数据</span></span><br><span class="line">    <span class="type">int</span> pos=<span class="number">1</span>;dp[<span class="number">1</span>]=a[idx];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=idx<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)<span class="comment">//（LIS）求最长不上升子序列==反向最长不下降子序列</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span>                 <span class="comment">//二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pos);</span><br><span class="line">    pos=<span class="number">1</span>;dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">//二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;=a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1091-合唱队形"><a href="#P1091-合唱队形" class="headerlink" title="P1091 合唱队形"></a>P1091 合唱队形</h2><h3 id="题目链接：-NOIP2004-提高组-合唱队形-洛谷"><a href="#题目链接：-NOIP2004-提高组-合唱队形-洛谷" class="headerlink" title="题目链接：[NOIP2004 提高组] 合唱队形 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1091">[NOIP2004 提高组] 合唱队形 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。</p>
<p>合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1&lt; \cdots <t_i>t_{i+1}&gt;$ … $&gt;t_k(1\le i\le k)$。</p>
<p>你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>对于一个合唱队形，它的前半段是上升的而后半段是下降的，想要使这个队形尽可能长，就是要使中间点的最长上升子序列长度与最长下降子序列的长度之和最大，故求两次（LIS）并遍历比较即可，复杂度 $O(n^2)$</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,a[<span class="number">105</span>],dp1[<span class="number">105</span>],dp2[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);<span class="comment">//读入数据</span></span><br><span class="line">        dp1[i]=<span class="number">1</span>;dp2[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正反两次 LIS </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i]) dp1[i]=<span class="built_in">max</span>(dp1[i],dp1[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i]) dp2[i]=<span class="built_in">max</span>(dp2[i],dp2[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历比较</span></span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp1[i]+dp2[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ma);<span class="comment">//题目中所求为出列人数，而非队伍长度，记得减去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1095-守望者的逃离"><a href="#P1095-守望者的逃离" class="headerlink" title="P1095 守望者的逃离"></a>P1095 守望者的逃离</h2><h3 id="题目链接：-NOIP2007-普及组-守望者的逃离-洛谷"><a href="#题目链接：-NOIP2007-普及组-守望者的逃离-洛谷" class="headerlink" title="题目链接：[NOIP2007 普及组] 守望者的逃离 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1095">[NOIP2007 普及组] 守望者的逃离 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。</p>
<p>为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。</p>
<p>守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。</p>
<p>现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。</p>
<p>注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>在 1s 内仅能选择闪现、跑步、恢复中的一项，那么可以考虑每次同时进行两项，选择结果更优项作为选择，$f[i]$ 表示 $i$ s 内行进的最远距离 ，复杂度 $O(n)$</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m,s,t,dp[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">if</span>(m&gt;=<span class="number">10</span>)<span class="comment">//优先使用闪现</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">60</span>;</span><br><span class="line">            m-=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            m+=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;dp[i<span class="number">-1</span>]+<span class="number">17</span>)<span class="comment">//改为选择走路</span></span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;=s)</span><br><span class="line">        &#123;</span><br><span class="line">            ok=<span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;No\n%d&quot;</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1541-乌龟棋"><a href="#P1541-乌龟棋" class="headerlink" title="P1541 乌龟棋"></a>P1541 乌龟棋</h2><h3 id="题目链接：P1541-NOIP2010-提高组-乌龟棋"><a href="#题目链接：P1541-NOIP2010-提高组-乌龟棋" class="headerlink" title="题目链接：P1541 [NOIP2010 提高组] 乌龟棋"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p>
<p>乌龟棋中 $M$ 张爬行卡片，分成4种不同的类型（ $M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p>
<p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p>
<p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p>
<p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>对于动态规划中的选择最优解类问题，往往是在一个过程中不断转移迭代达到整体最优的目的，需要对种类、数量、空间、价值等特征加以辨析进而表达状态，写出转移方程，本题中可以借鉴记忆化搜索和背包模型的思想，用多维表示当前卡牌数量，以及从上一层的最优解转移到当前层中，$f[a][b][c][d]$ 表示已使用的每种卡牌的数量，转移方程为 </p>
<p>$f[a][b][c][d]= f[a-1][b][c][d]+ val[ a+b\ast2+c\ast3+d\ast4 ]$  (例：第一种卡牌)</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,v[<span class="number">355</span>],cnt[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        cnt[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=v[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=cnt[<span class="number">1</span>];a++)<span class="comment">//循环遍历状态，类似背包模型</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;=cnt[<span class="number">2</span>];b++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;=cnt[<span class="number">3</span>];c++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=cnt[<span class="number">4</span>];d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> now=<span class="number">1</span>+a*<span class="number">1</span>+b*<span class="number">2</span>+c*<span class="number">3</span>+d*<span class="number">4</span>;<span class="comment">//当前所到达的格子</span></span><br><span class="line">                    <span class="comment">//状态转移</span></span><br><span class="line">                    <span class="keyword">if</span>(a) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a<span class="number">-1</span>][b][c][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(b) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b<span class="number">-1</span>][c][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(c) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c<span class="number">-1</span>][d]+v[now]);</span><br><span class="line">                    <span class="keyword">if</span>(d) dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c][d<span class="number">-1</span>]+v[now]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]][cnt[<span class="number">4</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1868-饥饿的奶牛"><a href="#P1868-饥饿的奶牛" class="headerlink" title="P1868 饥饿的奶牛"></a>P1868 饥饿的奶牛</h2><h3 id="题目链接：饥饿的奶牛-洛谷"><a href="#题目链接：饥饿的奶牛-洛谷" class="headerlink" title="题目链接：饥饿的奶牛 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1868">饥饿的奶牛 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。</p>
<p>对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>类似于最长上升子序列和背包模型的做法，$f[i]$ 表示右端点为 $i$ 时的最大值，先将区间按右端点排序，然后考虑对每一段区间选或者不选，如果选，则是采取二分找到从最靠近这段区间左端点的不相交区间的右端点进行转移，若不选则直接等于之前取得的最大值： $f[i]=max(f[i],f[k]+len) (k_{max}&lt;i)$  复杂度 $O(n\log n)$</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma;</span><br><span class="line">pii a[<span class="number">150005</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; dp;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii e1,pii e2)</span><span class="comment">//右端点排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e1.second==e2.second) <span class="keyword">return</span> e1.first&gt;e2.first;</span><br><span class="line">    <span class="keyword">return</span> e1.second&lt;e2.second;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">        <span class="keyword">if</span>(st[a[i].second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[a[i].second]=<span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">push_back</span>(a[i].second);<span class="comment">//保存右端点，便于二分查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)<span class="comment">//二分查找上一个满足不与当前区间相交的区间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[mid]&lt;a[i].first) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[a[i].second]=<span class="built_in">max</span>(ma,dp[s[r]]+a[i].second-a[i].first+<span class="number">1</span>);<span class="comment">//后面的区间的最大值自然包含前面区间的最大值，类似前缀思想</span></span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp[a[i].second]);</span><br><span class="line">        <span class="comment">//printf(&quot;t %d %d %d %d %d\n&quot;,a[i].second,r,s[r],dp[s[r]],dp[a[i].second]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2679-子串"><a href="#P2679-子串" class="headerlink" title="P2679 子串"></a>P2679 子串</h2><h3 id="题目链接：-NOIP2015-提高组-子串-洛谷"><a href="#题目链接：-NOIP2015-提高组-子串-洛谷" class="headerlink" title="题目链接：[NOIP2015 提高组] 子串 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2679">[NOIP2015 提高组] 子串 - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>有两个仅包含小写英文字母的字符串 $A$ 和 $B$。</p>
<p>现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？</p>
<p>注意：子串取出的位置不同也认为是不同的方案。</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><h2 id="P2501-数字序列"><a href="#P2501-数字序列" class="headerlink" title="P2501 数字序列"></a>P2501 数字序列</h2><h3 id="题目链接：-HAOI2006-数字序列-洛谷"><a href="#题目链接：-HAOI2006-数字序列-洛谷" class="headerlink" title="题目链接：[HAOI2006]数字序列 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2501">[HAOI2006]数字序列 - 洛谷</a></h3><h3 id="题面：-7"><a href="#题面：-7" class="headerlink" title="题面："></a>题面：</h3><p>现在我们有一个长度为 n 的整数序列 a 。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。</p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>对于第一问，可以将求最少需要改变的数量转化为求最多能够保留的数量，即求最长上升子序列的长度，但是题目中要求改变后整个序列严格单调递增，故保留的数之间需满足其差的绝对值大于之间的距离，$a[i]-a[j] \geq i-j$ ，这样才能保证其中间的数改变后仍保持整个序列单调递增</p>
<p>对于第二问，留白待补</p>
<h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="comment">//const int inf = 0x3f3f3f3f;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,pos=<span class="number">1</span>,a[<span class="number">30005</span>],dp[<span class="number">30005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);a[i]-=i;&#125;<span class="comment">//构造条件数组</span></span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// LIS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=dp[pos]) dp[++pos]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3558-BAJ-Bytecomputer"><a href="#P3558-BAJ-Bytecomputer" class="headerlink" title="P3558 BAJ-Bytecomputer"></a>P3558 BAJ-Bytecomputer</h2><h3 id="题目链接：-POI2013-BAJ-Bytecomputer-洛谷"><a href="#题目链接：-POI2013-BAJ-Bytecomputer-洛谷" class="headerlink" title="题目链接：[POI2013]BAJ-Bytecomputer - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3558">[POI2013]BAJ-Bytecomputer - 洛谷</a></h3><h3 id="题面：-8"><a href="#题面：-8" class="headerlink" title="题面："></a>题面：</h3><p>给定一个长度为 n 的只包含 $−1,0,1$ 的数列 a，每次操作可以使 $a_i$ ​← $a_i​+a_i−1$​，求最少操作次数使得序列单调不降。如果不可能通过该操作使得序列单调不降，请输出 <code>BRAK</code>。</p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>根据题面，数列中只含有 $-1,0,1$ 三个数，当前阶段的数可以根据上一阶段的数进行变换，考虑用状态表示出当前阶段数变化后使整个序列保证单调不降的总变化数，即 $f[i][j]$ 表示第 $i$ 个数变化为 $j$ 时仍保证序列单调不减的总变化数。由于每一层的状态转移只考虑到前一层，故可以使用滚动数组优化空间。复杂度 $O(n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,x,dp[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//滚动数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=inf,dp[<span class="number">1</span>][<span class="number">1</span>]=inf,dp[<span class="number">1</span>][<span class="number">2</span>]=inf;<span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">1</span>][x+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//第一个值没有前值进行转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">//转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=inf;<span class="comment">//-1 变为 0 需要前一个数为 1，此时不满足单调不减，矛盾置为inf</span></span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">2</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>]=dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">2</span>]=<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>],dp[(i+<span class="number">1</span>)%<span class="number">2</span>][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mi=<span class="built_in">min</span>(dp[n%<span class="number">2</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[n%<span class="number">2</span>][<span class="number">1</span>],dp[n%<span class="number">2</span>][<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">if</span>(mi&gt;=inf) <span class="built_in">printf</span>(<span class="string">&quot;BRAK&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,mi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4158-粉刷匠"><a href="#P4158-粉刷匠" class="headerlink" title="P4158 粉刷匠"></a>P4158 粉刷匠</h2><h3 id="题面链接：-SCOI2009-粉刷匠-洛谷"><a href="#题面链接：-SCOI2009-粉刷匠-洛谷" class="headerlink" title="题面链接：[SCOI2009]粉刷匠 - 洛谷"></a>题面链接：<a href="https://www.luogu.com.cn/problem/P4158">[SCOI2009]粉刷匠 - 洛谷</a></h3><h3 id="题面：-9"><a href="#题面：-9" class="headerlink" title="题面："></a>题面：</h3><p>windy 有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。</p>
<p>windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。</p>
<p>如果 windy 只能粉刷 T 次，他最多能正确粉刷多少格子？</p>
<p>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</p>
<h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3>]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.1 线性动态规划</title>
    <url>/luogu4-1/</url>
    <content><![CDATA[<h1 id="Part-4-1-线性动态规划"><a href="#Part-4-1-线性动态规划" class="headerlink" title="Part 4.1 线性动态规划"></a>Part 4.1 线性动态规划</h1><h2 id="最长上升子序列-（LIS）"><a href="#最长上升子序列-（LIS）" class="headerlink" title="最长上升子序列 （LIS）"></a>最长上升子序列 （LIS）</h2><h3 id="朴素版-O-n-2"><a href="#朴素版-O-n-2" class="headerlink" title="朴素版 $O(n^2)$"></a>朴素版 $O(n^2)$</h3><p>对于一段序列 $a$ , $dp[i]$ 表示以 $a[i]$ 为结尾的最大上升子序列的长度</p>
<p>状态转移方程为：$dp[i]=Max(dp[i],dp[j]+1),1 \leq j &lt; i , a[j]&lt;a[i]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;a[i]) dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="利用二分查找优化-O-nlogn"><a href="#利用二分查找优化-O-nlogn" class="headerlink" title="利用二分查找优化 $O(nlogn)$"></a>利用二分查找优化 $O(nlogn)$</h3><p>对于一段序列 $a$ , $dp[i]$ 表示长度为 $i$ 的上升子序列结尾的数值</p>
<p>对于序列中的每一个数，如果大于当前最长上升子序列长度的结尾值，则连接上，并更新最长上升子序列的长度，如果不大于，则判断更新之前上升子序列的结尾值，使其更优，易于下一个数进行连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pos=<span class="number">1</span>;dp[<span class="number">1</span>]=a[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;dp[pos]) dp[++pos]=a[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=pos;<span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid]&gt;a[i]) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l]=a[i];<span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dilworth-定理"><a href="#Dilworth-定理" class="headerlink" title="Dilworth 定理"></a>Dilworth 定理</h3><ul>
<li><p><strong>Dilworth</strong> 定理：对于一个偏序集，最少链划分等于最长反链长度</p>
</li>
<li><p><strong>Dilworth</strong> 定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.2 背包动态规划</title>
    <url>/luogu4-2/</url>
    <content><![CDATA[<h1 id="背包动态规划"><a href="#背包动态规划" class="headerlink" title="背包动态规划"></a>背包动态规划</h1><h2 id="01背包-O-NW"><a href="#01背包-O-NW" class="headerlink" title="01背包 $O(NW)$"></a>01背包 $O(NW)$</h2><p>有 $N$ 个物品，背包体积为 $W$，每个物品选择拿与不拿，问有限体积内的最大价值</p>
<p>$dp[i]$ 表示背包占用 $i$ 体积能获得的最大价值</p>
<p>状态转移方程：$dp[i]=max(dp[i],dp[i-w[idx]+v[idx]),1 \leq i \leq W,1 \leq idx \leq n$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)<span class="comment">//遍历体积</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);<span class="comment">//状态转移</span></span><br></pre></td></tr></table></figure>

<h2 id="完全背包-O-NW"><a href="#完全背包-O-NW" class="headerlink" title="完全背包 $O(NW)$"></a>完全背包 $O(NW)$</h2><p>有 $N$ 种物品，每种物品有无穷多个，背包体积为 $W$，每个物品选择拿与不拿，问有限体积内的最大价值</p>
<p>$dp[i]$ 表示背包占用 $i$ 体积能获得的最大价值</p>
<p>状态转移方程：$dp[i]=max(dp[i],dp[i-w[idx]+v[idx]),1 \leq i \leq W,1 \leq idx \leq n$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=W;j++)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有 $N$ 种物品，每种物品有 $num_i$ 个，背包体积为 $W$，每个物品选择拿与不拿，问有限体积内的最大价值</p>
<p>$dp[j]$ 表示背包占用 $j$ 体积能获得的最大价值</p>
<p>先将多重背包内的通过二进制的方式优化，然后采取 01 背包的解决方案即可</p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>有 $N$ 组物品，每组物品有 $num_i$ 个，背包体积为 $W$，每组物品只能选择拿一个或不拿，问有限体积内的最大价值</p>
<p>$dp[j]$ 表示背包占用 $j$ 体积能获得的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历分组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=<span class="number">0</span>;j--)<span class="comment">//遍历体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=num[i];k++)<span class="comment">//遍历组内物品</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i][k]) dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i][k]]+v[i][k]);</span><br></pre></td></tr></table></figure>

<h2 id="01-背包统计方案数"><a href="#01-背包统计方案数" class="headerlink" title="01 背包统计方案数"></a>01 背包统计方案数</h2><p>有 $N$ 个物品，背包体积为 $W$，每个物品选择拿与不拿，问有限体积内的最大价值的方案数</p>
<p>在求解 01 背包的同时统计最优方案的数量，$cnt[j]$ 表示背包占用 $j$ 体积获得最大价值时的方案数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=W;i++) cnt[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]&lt;dp[j-w[i]]+v[i])<span class="comment">//统计方案</span></span><br><span class="line">                cnt[j]=cnt[j-w[i]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[j]==dp[j-w[i]]+v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[j]+=cnt[j-w[i]];</span><br><span class="line">                cnt[j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="01-背包记录方案"><a href="#01-背包记录方案" class="headerlink" title="01 背包记录方案"></a>01 背包记录方案</h2><p>有 $N$ 个物品，背包体积为 $W$，每个物品选择拿与不拿，要求输出一种有限体积内最大价值的具体方案</p>
<p>做法类似于统计方案，在求解 01 背包的过程中记录状态转移的策略，</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.3 区间动态规划题解</title>
    <url>/luogu4-3-problems/</url>
    <content><![CDATA[<h1 id="Part-4-3-区间动态规划题解"><a href="#Part-4-3-区间动态规划题解" class="headerlink" title="Part 4.3 区间动态规划题解"></a>Part 4.3 区间动态规划题解</h1><h2 id="P1880-石子合并"><a href="#P1880-石子合并" class="headerlink" title="P1880 石子合并"></a>P1880 石子合并</h2><h3 id="题目链接：-NOI1995-石子合并-洛谷"><a href="#题目链接：-NOI1995-石子合并-洛谷" class="headerlink" title="题目链接：[NOI1995] 石子合并 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1880">[NOI1995] 石子合并 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p>
<p>试设计出一个算法，计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>经典的环形区间 DP 问题，对于环形问题，先要破环为链，将环延长一倍后，用小区间更新大区间的值</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">305</span>],s[<span class="number">305</span>];</span><br><span class="line"><span class="type">int</span> dpa[<span class="number">305</span>][<span class="number">305</span>],dpi[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) </span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="built_in">memset</span>(dpa,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dpa));</span><br><span class="line">    <span class="built_in">memset</span>(dpi,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dpi));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)<span class="comment">//区间DP</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n*<span class="number">2</span>;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dpa[l][r]=dpi[l][r]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpa[l][r]=<span class="built_in">max</span>(dpa[l][r],dpa[l][k]+dpa[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">                    dpi[l][r]=<span class="built_in">min</span>(dpi[l][r],dpi[l][k]+dpi[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> mi=INT_MAX,ma=-INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mi=<span class="built_in">min</span>(mi,dpi[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dpa[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,mi,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3146-248-G"><a href="#P3146-248-G" class="headerlink" title="P3146 248 G"></a>P3146 248 G</h2><h3 id="题目链接：-USACO16OPEN-248-G-洛谷"><a href="#题目链接：-USACO16OPEN-248-G-洛谷" class="headerlink" title="题目链接：[USACO16OPEN]248 G - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3146">[USACO16OPEN]248 G - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>给定一个 $1*n$ 的地图，在里面玩 2048，每次可以合并相邻两个（数值范围 $1-40$ ），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是+1，例如 2 与 2 合并后的数值为 3 。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>区间 DP，注意区间合并条件为两个相邻区间的值相等即 $dp[l][k]==dp[k+1][r]$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,a[<span class="number">255</span>],dp[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dp[l][r]=a[l];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                &#123;    <span class="comment">//判断合并条件</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[l][k]==dp[k+<span class="number">1</span>][r]) dp[l][r]=<span class="built_in">max</span>(dp[l][r],dp[l][k]+<span class="number">1</span>);</span><br><span class="line">                    ma=<span class="built_in">max</span>(ma,dp[l][r]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1063-能量项链"><a href="#P1063-能量项链" class="headerlink" title="P1063 能量项链"></a>P1063 能量项链</h2><h3 id="题目链接：-NOIP2006-提高组-能量项链-洛谷"><a href="#题目链接：-NOIP2006-提高组-能量项链-洛谷" class="headerlink" title="题目链接：[NOIP2006 提高组] 能量项链 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1063">[NOIP2006 提高组] 能量项链 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>能量项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \times r \times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。</p>
<p>需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>思路与石子合并类似，先破环为链，然后做区间状态转移</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,head[<span class="number">255</span>],tail[<span class="number">255</span>],dp[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        head[i%n]=x;</span><br><span class="line">        tail[i<span class="number">-1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    head[n]=head[<span class="number">0</span>];tail[n]=tail[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)<span class="comment">//破环为链</span></span><br><span class="line">        head[i]=head[i-n],tail[i]=tail[i-n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                dp[l][r]=<span class="built_in">max</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+head[l]*tail[k]*tail[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ma=<span class="built_in">max</span>(ma,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1005-矩阵取数游戏"><a href="#P1005-矩阵取数游戏" class="headerlink" title="P1005 矩阵取数游戏"></a>P1005 矩阵取数游戏</h2><h3 id="题目链接：-NOIP2007-提高组-矩阵取数游戏-洛谷"><a href="#题目链接：-NOIP2007-提高组-矩阵取数游戏-洛谷" class="headerlink" title="题目链接：[NOIP2007 提高组] 矩阵取数游戏 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1005">[NOIP2007 提高组] 矩阵取数游戏 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：</p>
<ol>
<li>每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；</li>
<li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li>
<li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；</li>
<li>游戏结束总得分为 $m$ 次取数得分之和。</li>
</ol>
<p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>题目涉及高精，待补</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="P4170-涂色"><a href="#P4170-涂色" class="headerlink" title="P4170 涂色"></a>P4170 涂色</h2><h3 id="题目链接：-CQOI2007-涂色-洛谷"><a href="#题目链接：-CQOI2007-涂色-洛谷" class="headerlink" title="题目链接：[CQOI2007]涂色 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4170">[CQOI2007]涂色 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\texttt{RGBGR}$。</p>
<p>每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\texttt{RRRRR}$，第二次涂成 $\texttt{RGGGR}$，第三次涂成 $\texttt{RGBGR}$，达到目标。</p>
<p>用尽量少的涂色次数达到目标。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>题意是求对字符串的最少染色次数，设<code>f[i][j]</code>为字符串的子串<code>s[i]~s[j]</code>的最少染色次数，我们分析一下：</p>
<p>当<code>i==j</code>时，子串明显只需要涂色一次，于是<code>f[i][j]=1</code>。</p>
<p>当<code>i!=j</code>且<code>s[i]==s[j]</code>时，可以想到只需要在首次涂色时多涂一格即可，于是<code>f[i][j]=min(f[i][j-1],f[i+1][j])</code></p>
<p>当<code>i!=j</code>且<code>s[i]!=s[j]</code>时，我们需要考虑将子串断成两部分来涂色，于是需要枚举子串的断点，设断点为<code>k</code>，那么<code>f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])</code></p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//初始化</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s.<span class="built_in">length</span>();len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l+len<span class="number">-1</span>&lt;s.<span class="built_in">length</span>();l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) dp[l][r]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[l]==s[r]) dp[l][r]=<span class="built_in">min</span>(dp[l][r<span class="number">-1</span>],dp[l+<span class="number">1</span>][r]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                    dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][s.<span class="built_in">length</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4302-字符串折叠"><a href="#P4302-字符串折叠" class="headerlink" title="P4302 字符串折叠"></a>P4302 字符串折叠</h2><h3 id="题目链接：-SCOI2003-字符串折叠-洛谷"><a href="#题目链接：-SCOI2003-字符串折叠-洛谷" class="headerlink" title="题目链接：[SCOI2003]字符串折叠 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4302">[SCOI2003]字符串折叠 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>折叠的定义如下： </p>
<ol>
<li><p>一个字符串可以看成它自身的折叠。记作 S = S </p>
</li>
<li><p>X(S) 是 X(X&gt;1) 个 S 连接在一起的串的折叠。记作 X(S) = SSSS…S ( X 个 S )。</p>
</li>
<li><p>如果 A = A’, B = B’，则 AB = A’B’ 例如，因为 3(A) = AAA, 2(B) = BB，所以 3(A)C2(B) = AAACBB，而 2(3(A)C)2(B) = AAACAAACBB</p>
</li>
</ol>
<p>给一个字符串，求它的最短折叠。例如 AAAAAAAAAABABABCCD 的最短折叠为：9(A)3(AB)CCD。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>用 $d[i][j]$​ 表示 $i∼j$ 这个区间内最小的长度。</p>
<p>首先，可以把 $i∼j$ 这个区间的字符串拆成 2 部分处理。</p>
<p>然后，还要判断区间内能否折叠，再次更新</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string st;</span><br><span class="line"><span class="type">int</span> n,m[<span class="number">110</span>],f[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> len)</span><span class="comment">//检查字符串能否折叠</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(st[i]!=st[(i-l)%len+l]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;st;</span><br><span class="line">    n=st.<span class="built_in">size</span>();</span><br><span class="line">    st=<span class="string">&#x27; &#x27;</span>+st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) m[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&lt;=<span class="number">99</span>;i++) m[i]=<span class="number">2</span>;</span><br><span class="line">    m[<span class="number">100</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=i+l<span class="number">-1</span>;j&lt;=n;i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)<span class="comment">//区间DP常规迭代</span></span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)<span class="comment">//判断折叠情况进行更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len=k-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l%len!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i,j,len)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+<span class="number">2</span>+m[l/len]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.4 树形动态规划题解</title>
    <url>/luogu4-4-problems/</url>
    <content><![CDATA[<h1 id="Part-4-4-树形动态规划题解"><a href="#Part-4-4-树形动态规划题解" class="headerlink" title="Part 4.4 树形动态规划题解"></a>Part 4.4 树形动态规划题解</h1><h2 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h2><h3 id="题目链接：没有上司的舞会-洛谷"><a href="#题目链接：没有上司的舞会-洛谷" class="headerlink" title="题目链接：没有上司的舞会 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>某大学有 n 个职员，编号为 $1…n$ 。</p>
<p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p>
<p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$​ ，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p>
<p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>树形dp的一类经典模型，对类似于大盗阿福的状态机模型，考虑每个点，如果过不选，则对于其子节点，选与不选均可，取其决策最大值，若选，则由子节点不选的状态转移而来</p>
<p>$dp[u][0]$ 表示结点 $u$ 不选时的最大值，$dp[u][1]$ 表示结点 $u$ 选择时的最大值</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,root,val[<span class="number">6005</span>],dp[<span class="number">6006</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">6006</span>],e[<span class="number">6006</span>],ne[<span class="number">6005</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">6006</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val[u]&gt;<span class="number">0</span>) dp[u][<span class="number">1</span>]+=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        st[a]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!st[i]) root=i;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1040-加分二叉树"><a href="#P1040-加分二叉树" class="headerlink" title="P1040 加分二叉树"></a>P1040 加分二叉树</h2><h3 id="题目链接：-NOIP2003-提高组-加分二叉树-洛谷"><a href="#题目链接：-NOIP2003-提高组-加分二叉树-洛谷" class="headerlink" title="题目链接：[NOIP2003 提高组] 加分二叉树 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1040">[NOIP2003 提高组] 加分二叉树 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为 $(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：</p>
<p>$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。</p>
<p>若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p>
<p>试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出</p>
<ol>
<li><p>$\text{tree}$ 的最高加分。</p>
</li>
<li><p>$\text{tree}$ 的前序遍历。</p>
</li>
</ol>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>树形dp，但是思路类似于区间dp，$dp[i][j]$ 表示从 $i$ 到 $j$ 的最大值，大区间由小区间更新而来，枚举断点 $k$ 时，我们将 $k$ 点作为根节点进行计算即可</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">35</span>],dp[<span class="number">35</span>][<span class="number">35</span>],root[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root[l][r]);</span><br><span class="line">    <span class="built_in">dfs</span>(l,root[l][r]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r) &#123;dp[l][r]=a[l];root[l][r]=l;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">                    <span class="keyword">if</span>(k==l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[k+<span class="number">1</span>][r]+dp[l][l]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[k+<span class="number">1</span>][r]+dp[l][l];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k==r)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[l][k<span class="number">-1</span>]+dp[r][r]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[l][k<span class="number">-1</span>]+dp[r][r];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k]&gt;dp[l][r])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[l][r]=dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k];</span><br><span class="line">                            root[l][r]=k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1122-最大子树和"><a href="#P1122-最大子树和" class="headerlink" title="P1122 最大子树和"></a>P1122 最大子树和</h2><h3 id="题目链接：最大子树和-洛谷"><a href="#题目链接：最大子树和-洛谷" class="headerlink" title="题目链接：最大子树和 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1122">最大子树和 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N−1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>$dp[u]$ 表示结点 $u$ 及其子树的最大权值和，在 dfs 遍历时记录最大值即可</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma=<span class="number">-1e9</span>,w[<span class="number">17000</span>],dp[<span class="number">17000</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">17000</span>],e[<span class="number">34000</span>],ne[<span class="number">34000</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">17000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u]=w[u];</span><br><span class="line">    st[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u]+=<span class="built_in">max</span>(<span class="number">0</span>,dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ma=<span class="built_in">max</span>(ma,dp[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ma);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1273-有线电视网"><a href="#P1273-有线电视网" class="headerlink" title="P1273 有线电视网"></a>P1273 有线电视网</h2><h3 id="题目链接：有线电视网-洛谷"><a href="#题目链接：有线电视网-洛谷" class="headerlink" title="题目链接：有线电视网 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1273">有线电视网 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。</p>
<p>从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。</p>
<p>现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。</p>
<p>写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>误区警告，多出来的钱可以摊给其他路线。</p>
<p>树上分组背包，但是该题所求并非获利最大，而是至多能选多少个物品，故跑完树上分组背包后需再次遍历 dp 数组，求得合法最大值</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,val[<span class="number">3005</span>],dp[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">3005</span>],e[<span class="number">3005</span>],ne[<span class="number">3005</span>],w[<span class="number">3005</span>],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;=n-m+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[u][<span class="number">1</span>]=val[u];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">dfs</span>(v);</span><br><span class="line">        sum+=t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=k) dp[u][j]=<span class="built_in">max</span>(dp[u][j],dp[u][j-k]+dp[v][k]-w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t;i&lt;=n-m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;r);</span><br><span class="line">            <span class="built_in">add</span>(i,k,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2014-选课"><a href="#P2014-选课" class="headerlink" title="P2014 选课"></a>P2014 选课</h2><h3 id="题目链接：-CTSC1997-选课-洛谷"><a href="#题目链接：-CTSC1997-选课-洛谷" class="headerlink" title="题目链接：[CTSC1997] 选课 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2014">[CTSC1997] 选课 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 M 门课程学习，问他能获得的最大学分是多少？</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>树上分组背包模板题</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,val[<span class="number">305</span>],dp[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">305</span>],e[<span class="number">305</span>],ne[<span class="number">305</span>],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                dp[u][j]=<span class="built_in">max</span>(dp[u][j],dp[u][j-k]+dp[v][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;val[i]);</span><br><span class="line">        <span class="built_in">add</span>(u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[<span class="number">0</span>][m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2585-三色二叉树"><a href="#P2585-三色二叉树" class="headerlink" title="P2585 三色二叉树"></a>P2585 三色二叉树</h2><h3 id="题目链接：-ZJOI2006-三色二叉树-洛谷"><a href="#题目链接：-ZJOI2006-三色二叉树-洛谷" class="headerlink" title="题目链接：[ZJOI2006]三色二叉树 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2585">[ZJOI2006]三色二叉树 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：</p>
<p>$$<br>S=<br>\begin{cases}<br>0&amp; \text表示该树没有子节点\<br>1S_1&amp; 表示该树有一个节点，S_1 为其子树的二叉树序列\<br>2S_1S_2&amp; 表示该树由两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列<br>\end{cases}<br>$$</p>
<p>例如，下图所表示的二叉树可以用二叉树序列 $S=\texttt{21200110}$ 来表示。</p>
<p><img src="https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png" alt="haha.png"></p>
<p>你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中<strong>最多和最少</strong>有多少个点能够被染成绿色。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>状态表示类似于没有上司的舞会，有三种颜色，还要求解最大最小，故状态表示为三维，</p>
<p>$dp[u][0/1/2][0/1]$ 表示结点 $u$ 的颜色以及其记录的最大最小，注意建树</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> now,idx=<span class="number">2</span>,tree[<span class="number">500005</span>][<span class="number">2</span>],dp[<span class="number">500005</span>][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[now]-<span class="string">&#x27;0&#x27;</span>==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[u][<span class="number">0</span>]=idx++;</span><br><span class="line">        tree[u][<span class="number">1</span>]=idx++;</span><br><span class="line">        now++;</span><br><span class="line">        <span class="built_in">build</span>(tree[u][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">build</span>(tree[u][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[now]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[u][<span class="number">0</span>]=idx++;</span><br><span class="line">        now++;</span><br><span class="line">        <span class="built_in">build</span>(tree[u][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        now++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(tree[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">dfs</span>(tree[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> l=tree[u][<span class="number">0</span>],r=tree[u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(tree[u][<span class="number">1</span>])</span><br><span class="line">    &#123;    </span><br><span class="line">        dp[u][<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">1</span>][<span class="number">0</span>]+dp[r][<span class="number">2</span>][<span class="number">0</span>],dp[l][<span class="number">2</span>][<span class="number">0</span>]+dp[r][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">0</span>][<span class="number">0</span>]+dp[r][<span class="number">2</span>][<span class="number">0</span>],dp[l][<span class="number">2</span>][<span class="number">0</span>]+dp[r][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">2</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">0</span>][<span class="number">0</span>]+dp[r][<span class="number">1</span>][<span class="number">0</span>],dp[l][<span class="number">1</span>][<span class="number">0</span>]+dp[r][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">0</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">1</span>][<span class="number">1</span>]+dp[r][<span class="number">2</span>][<span class="number">1</span>],dp[l][<span class="number">2</span>][<span class="number">1</span>]+dp[r][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">0</span>][<span class="number">1</span>]+dp[r][<span class="number">2</span>][<span class="number">1</span>],dp[l][<span class="number">2</span>][<span class="number">1</span>]+dp[r][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">2</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">1</span>][<span class="number">1</span>]+dp[r][<span class="number">0</span>][<span class="number">1</span>],dp[l][<span class="number">0</span>][<span class="number">1</span>]+dp[r][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[u][<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">1</span>][<span class="number">0</span>],dp[l][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">0</span>][<span class="number">0</span>],dp[l][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">2</span>][<span class="number">0</span>]+=<span class="built_in">min</span>(dp[l][<span class="number">1</span>][<span class="number">0</span>],dp[l][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">0</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">1</span>][<span class="number">1</span>],dp[l][<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">0</span>][<span class="number">1</span>],dp[l][<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">2</span>][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[l][<span class="number">1</span>][<span class="number">1</span>],dp[l][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])),<span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3047-Nearby-Cows-G"><a href="#P3047-Nearby-Cows-G" class="headerlink" title="P3047 Nearby Cows G"></a>P3047 Nearby Cows G</h2><h3 id="题目链接：-USACO12FEB-Nearby-Cows-G-洛谷"><a href="#题目链接：-USACO12FEB-Nearby-Cows-G-洛谷" class="headerlink" title="题目链接：[USACO12FEB]Nearby Cows G - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3047">[USACO12FEB]Nearby Cows G - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>给你一棵 $n$ 个点的树，点带权，对于每个节点求出距离它不超过 $k$ 的所有节点权值和 $m_i$​</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>换根 dp 模型题，每个结点维护其向下遍历的值以及向上遍历的值，两部分相结合就得到了这个点周围 ( 作为根 ) 的信息</p>
<h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,val[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> up[<span class="number">100005</span>][<span class="number">21</span>],down[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">100005</span>],e[<span class="number">200005</span>],ne[<span class="number">200005</span>],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_down</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) down[u][i]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs_down</span>(j,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;=k;r++)</span><br><span class="line">            down[u][r]+=down[j][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_up</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;=k;r++)</span><br><span class="line">            <span class="keyword">if</span>(r&gt;=<span class="number">2</span>) up[j][r]+=down[u][r<span class="number">-1</span>]+up[u][r<span class="number">-1</span>]-down[j][r<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">else</span> up[j][r]+=down[u][r<span class="number">-1</span>]+up[u][r<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs_up</span>(j,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="built_in">dfs_down</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs_up</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,up[i][k]+down[i][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3698-小Q的棋盘"><a href="#P3698-小Q的棋盘" class="headerlink" title="P3698 小Q的棋盘"></a>P3698 小Q的棋盘</h2><h3 id="题目链接：-CQOI2017-小Q的棋盘-洛谷"><a href="#题目链接：-CQOI2017-小Q的棋盘-洛谷" class="headerlink" title="题目链接：[CQOI2017]小Q的棋盘 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3698">[CQOI2017]小Q的棋盘 - 洛谷</a></h3><h3 id="题面：-7"><a href="#题面：-7" class="headerlink" title="题面："></a>题面：</h3><p>小 Q 正在设计一种棋类游戏。</p>
<p>在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 V 个格点，编号为 0,1,2 … , V− 1，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。</p>
<p>小 Q 现在想知道，当棋子从格点 0 出发，移动 N 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。</p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> hd[maxn], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = &#123; t,hd[f] &#125;;</span><br><span class="line">    hd[f] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f,<span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=last; i++)</span><br><span class="line">        dp[u][i][<span class="number">0</span>] = dp[u][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = hd[u]; i; i = e[i].nxt) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].t;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u,last<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = last; j &gt;=<span class="number">1</span>; j--) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j<span class="number">-1</span>; k &gt;=<span class="number">0</span>; k--) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不回来,可以有两种方式松弛,1是走这个孩子回来+走之前的孩子不回来</span></span><br><span class="line">                <span class="comment">//2是走这个孩子不回来+走之前的孩子回来</span></span><br><span class="line">                dp[u][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[u][j][<span class="number">1</span>], dp[u][j - k - <span class="number">1</span>][<span class="number">0</span>] + dp[v][k][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k + <span class="number">2</span>)</span><br><span class="line">                &#123;   <span class="comment">//回来的情况要多用两条边用来走去儿子和从儿子回到自身</span></span><br><span class="line">                    dp[u][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[u][j][<span class="number">1</span>], dp[u][j - k - <span class="number">2</span>][<span class="number">1</span>] + dp[v][k][<span class="number">0</span>]);</span><br><span class="line">                    <span class="comment">//回来就前面儿子回来+当前儿子回来的最大</span></span><br><span class="line">                    dp[u][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[u][j][<span class="number">0</span>], dp[u][j - k - <span class="number">2</span>][<span class="number">0</span>] + dp[v][k][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xf3</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>,u,v; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[<span class="number">0</span>][m][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a>P5658 括号树</h2><h3 id="题目链接：-CSP-S2019-括号树-洛谷"><a href="#题目链接：-CSP-S2019-括号树-洛谷" class="headerlink" title="题目链接：[CSP-S2019] 括号树 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5658">[CSP-S2019] 括号树 - 洛谷</a></h3><h3 id="题面：-8"><a href="#题面：-8" class="headerlink" title="题面："></a>题面：</h3><p>小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1$ ∼ $n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \leq u \leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u &lt; u$）号结点。</p>
<p>小 Q 发现这个树的每个结点上<strong>恰有</strong>一个括号，可能是<code>(</code> 或<code>)</code>。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。</p>
<p>显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\leq i\leq n$）求出，$s_i$ 中有多少个<strong>互不相同的子串</strong>是<strong>合法括号串</strong>。</p>
<p>这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \times k_i$ 的异或和，即：<br>$(1 \times k_1)\ \text{xor}\ (2 \times k_2)\ \text{xor}\ (3 \times k_3)\ \text{xor}\ \cdots\ \text{xor}\ (n \times k_n)$</p>
<p>其中 $xor$ 是位异或运算。</p>
<p>本题中<strong>合法括号串</strong>的定义如下：</p>
<ol>
<li><code>()</code> 是合法括号串。</li>
<li>如果 <code>A</code> 是合法括号串，则 <code>(A)</code> 是合法括号串。</li>
<li>如果 <code>A</code>，<code>B</code> 是合法括号串，则 <code>AB</code> 是合法括号串。</li>
</ol>
<p>本题中<strong>子串</strong>与<strong>不同的子串</strong>的定义如下：</p>
<ol>
<li>字符串 <code>S</code> 的子串是 <code>S</code> 中<strong>连续</strong>的任意个字符组成的字符串。<code>S</code> 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l, r)$（$1 \leq l \leq r \leq |S |$，$|S |$ 表示 S 的长度）。</li>
<li><code>S</code> 的两个子串视作不同<strong>当且仅当</strong>它们在 <code>S</code> 中的位置不同，即 $l$ 不同或 $r$ 不同。</li>
</ol>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3><h2 id="P2607-骑士"><a href="#P2607-骑士" class="headerlink" title="P2607 骑士"></a>P2607 骑士</h2><h3 id="题目链接：-ZJOI2008-骑士-洛谷"><a href="#题目链接：-ZJOI2008-骑士-洛谷" class="headerlink" title="题目链接：[ZJOI2008] 骑士 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2607">[ZJOI2008] 骑士 - 洛谷</a></h3><h3 id="题面：-9"><a href="#题面：-9" class="headerlink" title="题面："></a>题面：</h3><p>战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。</p>
<p>为了描述战斗力，我们将骑士按照 1 至 n 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。</p>
<h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><p>基环树 dp 的模型题，其解决方案是先找到环，然后以环上相邻两点为根节点分别跑一次 “美有上司的舞会” ，并将较优结果加入答案</p>
<h3 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">ll n,sum,rt,val[N],dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx,fa[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=<span class="literal">true</span>;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,fa);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;tt %d %d %d %d\n&quot;,u,fa,dp[u][0],dp[u][1]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(st[fa[u]]) rt=u;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>,&amp;val[i],&amp;u);</span><br><span class="line">        <span class="built_in">add</span>(u,i);</span><br><span class="line">        fa[i]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(rt,rt);</span><br><span class="line">            ll res=dp[rt][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(fa[rt],fa[rt]);</span><br><span class="line">            sum+=<span class="built_in">max</span>(res,dp[fa[rt]][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4395-Gem-气垫车"><a href="#P4395-Gem-气垫车" class="headerlink" title="P4395 Gem 气垫车"></a>P4395 Gem 气垫车</h2><h3 id="题目链接：-BOI2003-Gem-气垫车-洛谷"><a href="#题目链接：-BOI2003-Gem-气垫车-洛谷" class="headerlink" title="题目链接：[BOI2003]Gem 气垫车 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4395">[BOI2003]Gem 气垫车 - 洛谷</a></h3><h3 id="题面：-10"><a href="#题面：-10" class="headerlink" title="题面："></a>题面：</h3><p>给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数</p>
<p>唯一的限制条件是相临的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。</p>
<h3 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-10"><a href="#代码：-10" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,ma,dp[<span class="number">10005</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">10005</span>],e[<span class="number">20005</span>],ne[<span class="number">20005</span>],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ma;i++) dp[u][i]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ma;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mi=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ma;k++)</span><br><span class="line">                <span class="keyword">if</span>(k==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> mi=<span class="built_in">min</span>(mi,dp[v][k]);</span><br><span class="line">            dp[u][j]+=mi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    ma=<span class="built_in">log</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ma;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dp[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3177-树上染色"><a href="#P3177-树上染色" class="headerlink" title="P3177 树上染色"></a>P3177 树上染色</h2><h3 id="题目链接：-HAOI2015-树上染色-洛谷"><a href="#题目链接：-HAOI2015-树上染色-洛谷" class="headerlink" title="题目链接：[HAOI2015] 树上染色 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3177">[HAOI2015] 树上染色 - 洛谷</a></h3><h3 id="题面：-11"><a href="#题面：-11" class="headerlink" title="题面："></a>题面：</h3><p>有一棵点数为 n 的树，树边有边权。给你一个在 0∼n 之内的正整数 k ，你要在这棵树中选择 k 个点，将其染成黑色，并将其他 的 n−k 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。</p>
<h3 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-11"><a href="#代码：-11" class="headerlink" title="代码："></a>代码：</h3><h2 id="P4516-潜入行动"><a href="#P4516-潜入行动" class="headerlink" title="P4516 潜入行动"></a>P4516 潜入行动</h2><h3 id="题目链接：-JSOI2018-潜入行动-洛谷"><a href="#题目链接：-JSOI2018-潜入行动-洛谷" class="headerlink" title="题目链接：[JSOI2018] 潜入行动 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4516">[JSOI2018] 潜入行动 - 洛谷</a></h3><h3 id="题面：-12"><a href="#题面：-12" class="headerlink" title="题面："></a>题面：</h3><p>母舰可以看成是一棵 n 个节点、$n−1$ 条边的<strong>无向树</strong>，树上的节点用 $1,2,⋯,n$ 编号。<code>JYY</code> 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。</p>
<p>如果在节点 u 上安装监听设备，则 <code>JYY</code> 能够监听与 u <strong>直接相邻</strong>所有的节点的通信。换言之，如果在节点 u 安装监听设备，则对于树中每一条边 $(u,v)$ ，节点 v 都会被监听。特别注意<strong>放置在节点 u 的监听设备并不监听 u 本身的通信</strong>，这是 <code>JYY</code> 特别为了防止外星人察觉部署的战术。</p>
<p><code>JYY</code> 的特工一共携带了 k 个监听设备，现在 <code>JYY</code> 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上<strong>所有节点</strong>的通信都被监听？为了避免浪费，<strong>每个节点至多只能安装一个监听设备，且监听设备必须被用完</strong>。</p>
<h3 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h3><p>计数 dp </p>
<p>设 <code>dp[x][i][0/1][0/1]</code> 表示以 x 为根的子树中共放了i个监听装置，其中 x 点放没放装置，x点有没有被监听到的方案数（在以x为根的子树中除x外的其它结点都被监听到了）</p>
<p>不难看出这是一个树上背包，树上背包的转移套路是</p>
<p><code>dp[x][i+j]=combine(dp[x][i],dp[v][j])</code>，其中 v 是 x 的子节点</p>
<ul>
<li><p>如果 x 没被监听，那么 v 一定不能放装置，因此 <code>dp[x][i+j][0][0]=∑dp[x][i][0][0]∗dp[v][j][0][1]</code></p>
</li>
<li><p>如果 x 没被监听但是放了装置，x 侧的状态一定是dp[x][i][1][0]，v 是否被监听无所谓但是一定不能放装置，因此 <code>dp[x][i+j][1][0]=∑dp[x][i][1][0]∗(dp[v][j][0][0]+dp[v][j][0][1])</code></p>
</li>
<li><p>如果 x 没放装置但是被监听了，这时候要分情况：</p>
<p>x 侧的状态是 <code>dp[x][i][0][1]</code>，这时候 x 已经被监听了，v 放不放装置都无所谓，但是必须保证 v 是被监听的，所以贡献是 <code>dp[x][i][0][1]∗(dp[v][j][0][1]+dp[v][j][1][1])</code></p>
<p>x 侧的状态是 <code>dp[x][i][0][0]</code>，这时候监听 x 的重任就要交给 v 了，同时 v 自己必须是被监听的，所以贡献是 <code>dp[x][i][0][0]∗dp[v][j][1][1]</code></p>
<p>因此 <code>dp[x][i+j][0][1]=∑(dp[x][i][0][1]∗(dp[v][j][0][1]+dp[v][j][1][1])+dp[x][i][0][0]∗dp[v][j][1][1])</code></p>
</li>
<li><p>如果 x 既放了装置又被监听，同样要分两种情况：</p>
<p>x 侧的状态是 <code>dp[x][i][1][0]</code>，需要让 v 来监听 x ，但是 v 是否被监听无所谓，因为 x 上放了装置可以保证v被监听，所以贡献是 <code>dp[x][i][1][0]∗(dp[v][j][1][0]+dp[v][j][1][1])</code></p>
<p>x 侧的状态是 <code>dp[x][i][1][1]</code>，这时候 x 的所有要求都满足了，v 怎么样都行，贡献是 <code>dp[x][i][1][1]∗(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1])</code></p>
<p>因此 <code>dp[x][i+j][1][1]=∑(dp[x][i][1][0]∗(dp[v][j][1][0]+dp[v][j][1][1])+dp[x][i][1][1]∗(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1]))</code></p>
</li>
</ul>
<h3 id="代码：-12"><a href="#代码：-12" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,size[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">105</span>][<span class="number">2</span>][<span class="number">2</span>],tmp[<span class="number">105</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">100005</span>],e[<span class="number">200005</span>],ne[<span class="number">200005</span>],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">op</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    b%=mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(a+b)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u]=dp[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[u][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(size[u],k); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[j][<span class="number">0</span>][<span class="number">0</span>] = dp[u][j][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            dp[u][j][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            tmp[j][<span class="number">0</span>][<span class="number">1</span>] = dp[u][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            dp[u][j][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            tmp[j][<span class="number">1</span>][<span class="number">0</span>] = dp[u][j][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[u][j][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            tmp[j][<span class="number">1</span>][<span class="number">1</span>] = dp[u][j][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[u][j][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(size[u],k);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;=<span class="built_in">min</span>(size[v],k-j);r++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[u][j+r][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">0</span>][<span class="number">0</span>],<span class="number">1ll</span> * tmp[j][<span class="number">0</span>][<span class="number">0</span>] * dp[v][r][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][j+r][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">0</span>][<span class="number">1</span>],<span class="number">1ll</span> * tmp[j][<span class="number">0</span>][<span class="number">1</span>] * (dp[v][r][<span class="number">0</span>][<span class="number">1</span>] + dp[v][r][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">                dp[u][j+r][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">0</span>][<span class="number">1</span>],<span class="number">1ll</span> * tmp[j][<span class="number">0</span>][<span class="number">0</span>] * dp[v][r][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[u][j+r][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">1</span>][<span class="number">0</span>],<span class="number">1ll</span> * tmp[j][<span class="number">1</span>][<span class="number">0</span>] * (dp[v][r][<span class="number">0</span>][<span class="number">0</span>] + dp[v][r][<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">                dp[u][j+r][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">1</span>][<span class="number">1</span>],<span class="number">1ll</span> * tmp[j][<span class="number">1</span>][<span class="number">0</span>] * (dp[v][r][<span class="number">1</span>][<span class="number">0</span>] + dp[v][r][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">                dp[u][j+r][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">op</span>(dp[u][j+r][<span class="number">1</span>][<span class="number">1</span>],<span class="number">1ll</span> * tmp[j][<span class="number">1</span>][<span class="number">1</span>] * (<span class="number">1ll</span> * dp[v][r][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1ll</span> * dp[v][r][<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1ll</span> * dp[v][r][<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1ll</span> * dp[v][r][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(dp[<span class="number">1</span>][k][<span class="number">0</span>][<span class="number">1</span>] + dp[<span class="number">1</span>][k][<span class="number">1</span>][<span class="number">1</span>]) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1453-城市环路"><a href="#P1453-城市环路" class="headerlink" title="P1453 城市环路"></a>P1453 城市环路</h2><h3 id="题目链接：P1453-城市环路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#题目链接：P1453-城市环路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="题目链接：P1453 城市环路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1453">P1453 城市环路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h3 id="题面：-13"><a href="#题面：-13" class="headerlink" title="题面："></a>题面：</h3><p>整个城市可以看做一个 n 个点，n 条边的单圈图(保证图连通)，唯一的环便是绕城的环路。保证环上任意两点有且只有 2 条简单路径互通。图中的其它部分皆隶属城市郊区。</p>
<p>现在，有一位名叫 Jim 的同学想在 B 市开店，但是任意一条边的 2 个点不能同时开店，每个点都有一定的人流量，第 $i$ 个点的人流量是 $p_i$​ ，在该点开店的利润就等于 $p_i​×k$，其中 k 是一个常数。</p>
<p>Jim 想尽量多的赚取利润，请问他应该在哪些地方开店？</p>
<h3 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h3><p>又是一道基环树 dp ，解题思路与本篇 骑士 一题相同</p>
<h3 id="代码：-13"><a href="#代码：-13" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n,rt1,rt2;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> h[N],e[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">2</span>],idx,p[N];</span><br><span class="line"><span class="type">double</span> sum,dp[N][<span class="number">2</span>],k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;tt %d %d %d %d\n&quot;,u,fa,dp[u][0],dp[u][1]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);p[i]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(u),pb=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) &#123;rt1=u,rt2=v;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        p[pa]=pb;</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line">    <span class="built_in">dfs</span>(rt1,<span class="number">-1</span>);</span><br><span class="line">    sum=dp[rt1][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(rt2,<span class="number">-1</span>);</span><br><span class="line">    sum=<span class="built_in">max</span>(sum,dp[rt2][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum*k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.3 区间动态规划</title>
    <url>/luogu4-3/</url>
    <content><![CDATA[<h1 id="Part-4-3-区间动态规划"><a href="#Part-4-3-区间动态规划" class="headerlink" title="Part 4.3 区间动态规划"></a>Part 4.3 区间动态规划</h1><h2 id="区间-dp"><a href="#区间-dp" class="headerlink" title="区间 dp"></a>区间 dp</h2><p>区间动态规划是线性动态规划的拓展，它在分阶段划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法（例：$f[i][j]=f[i][k]+f[k+1][j]$）</p>
<p>区间类动态规划的特点：</p>
<ul>
<li>合并：即将两个或多个部分进行整合。</li>
<li>特征：能将问题分解成为两两合并的形式。</li>
<li>求解：对整个问题设最优值，枚举合并点，将问题分解成为左右两个部分，最后将左右两个部分的最优值进行合并得到原问题的最优值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)<span class="comment">//遍历区间长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)<span class="comment">//遍历左端点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r=l+len<span class="number">-1</span>;<span class="comment">//确定右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)<span class="comment">//状态转移</span></span><br><span class="line">            dp[l][r]=<span class="built_in">operate</span>(dp[l][r],dp[l][k]+d[k+<span class="number">1</span>][r]+value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.4 树形动态规划</title>
    <url>/luogu4-4/</url>
    <content><![CDATA[<h1 id="Part-4-4-树形动态规划"><a href="#Part-4-4-树形动态规划" class="headerlink" title="Part 4.4 树形动态规划"></a>Part 4.4 树形动态规划</h1><h2 id="树形dp–有依赖的背包"><a href="#树形dp–有依赖的背包" class="headerlink" title="树形dp–有依赖的背包"></a>树形dp–有依赖的背包</h2><p>可以将每个子结点以及其子树看作是一组物品，要选择物品需选择其父节点，通过背包的方式循环体积分配策略进行更新，对于森林，可以尝试建立虚拟源点合并为一棵树</p>
<p>$dp[u][j]$ 表示结点 $u$ 选择 $j$ 个子节点 ( 包括 $u$ ) 的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                dp[u][j]=<span class="built_in">max</span>(dp[u][j],dp[u][j-k]+dp[v][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h2><p>基于树上dp的基本模型，题目初始不给出根节点，需要遍历每一个根节点，达到某一个根节点的最佳情况。</p>
<p>暴力的思路是循环每个节点作为根节点，同时在遍历整个树，时间复杂度是 $O(n^2)$</p>
<p>换根dp 就是将时间复杂度降到 $O(n)$，在根结点切换时，直接通过一些已经计算过的数据在$O(1)$ 就能得到另一个根的结果。</p>
<p><strong>换根dp一般分为三个步骤</strong><br>1、先指定一个根节点<br>2、一次向下dfs 统计子树内的节点对当前节点的贡献<br>3、一次向上dfs 统计父亲节点对当前节点的贡献并合并统计最终答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span><span class="comment">//向下遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">down_dfs</span>(v,u);</span><br><span class="line">        down[u][condition]=<span class="built_in">operate</span>(down[u][condition],down[v][condition]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span><span class="comment">//向上遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        up[v][condition]=<span class="built_in">operate</span>(up[u][conditon],down[u][condition],down[v][condition]);</span><br><span class="line">        <span class="built_in">up_dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><p>众所周知树的性质，即对于一个有 $n$ 个节点的树，必定保证有 $n-1$ 条边（无向边）。反过来，对于一个由 $n-1$ 条无向边组成的连通图，必定是一棵树。据此，明显的，对于一个有 $n$ 个结点 $n$ 条边的无向连通图，必定是在一棵树上的任意两个节点之间连一条边构成的。我们把 $n$ 个节点 $n$ 条边的无向<strong>连通</strong>图，就称为<strong>基环树</strong>。</p>
<p>基环树的关键就是找到环，可以先把环当作这个无根树的 “根” ，也就是把环当成一个点（先不管它），这样一颗基环树就变成了一个普通的树，然后我们先按照解决普通树的方法对“根” 的所有子树依次处理求解答案，最后在单独对环上所有的点进行操作求解最终答案即可。</p>
<h3 id="基环树找环的两种方式"><a href="#基环树找环的两种方式" class="headerlink" title="基环树找环的两种方式"></a>基环树找环的两种方式</h3><h4 id="处理无向图"><a href="#处理无向图" class="headerlink" title="处理无向图"></a>处理无向图</h4><p>采取拓扑排序的方式，将入度为 1 的点逐个入队，然后拓扑遍历，最后入度仍然  &gt;= 2的点就是环上的点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i];</span><br><span class="line">            <span class="keyword">if</span>(in[v]&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                in[v]--;</span><br><span class="line">                <span class="keyword">if</span>(in[v]==<span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理有向图"><a href="#处理有向图" class="headerlink" title="处理有向图"></a>处理有向图</h4><p>在输入数据时记录结点的父亲，通过遍历结点的父亲，如果访问到了自身，则该节点在环上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_cir</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[fa[u]]) point=u;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">check_cir</span>(fa[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数dp"><a href="#计数dp" class="headerlink" title="计数dp"></a>计数dp</h2>]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章 导数和图像</title>
    <url>/calculus/calculus11/</url>
    <content><![CDATA[<h1 id="第11章-导数和图像"><a href="#第11章-导数和图像" class="headerlink" title="第11章 导数和图像"></a>第11章 导数和图像</h1><p>全局最大(小)值 或 绝对最大(小)值<br>局部最大(小)值 或 相对最大(小)值<br><strong>最大值与最小值定理</strong>：如果 $f$ 在 $[a,b]$ 上连续，那么 $f$ 在 $[a,b]$ 上至少有一个最大值和一个最小值<br><strong>极值定理</strong>：假设函数 $f$ 定义在开区间 $(a,b)$ 内，并且点 $c$ 在 $(a,b)$ 区间内，如果点 $c$ 为函数的局部最大值或最小值，那么点 $c$ 一定为该函数的临界点，也就是说，$f’(c)=0$ 或 $f’(c)$ 不存在，此定理适用于开区间<br>在一个开区间内的局部最大值和最小值只有可能出现在临界点，但临界点未必一定是局部最大值或局部最小值，例如 $f(x)=x^3$<br><strong>罗尔定理</strong>：假设函数 $f$ 在闭区间 $[a,b]$ 内连续，在开区间 $(a,b)$ 内可导，如果 $f(a)=f(b)$，那么在开区间 $(a,b)$ 内至少存在一点 $c$，使得 $f’(c)=0$<br>罗尔定理应用的例子：假设有一个函数 $f$ 满足 $f’(x)&gt;0$，则该函数一定满足水平线检验</p>
<ul>
<li>证明：首先假设 $f$ 不满足水平线检验，那么一定有一条水平线 $y=L$，它与图像相交两次或者更多，假设这些交点中的两点横坐标为 $a$ 和 $b$，则有 $f(a)=f(b)=L$，由于 $f(a)=f(b)$，所以可以使用罗尔定理，由定理可得在 $a$ 和 $b$ 之间一定存在一点 $c$ 使得 $f’(c)=0$，这与条件相悖，故证明该函数满足水平线检验</li>
</ul>
<p><strong>中值定理</strong>：假设函数 $f$ 在闭区间 $[a,b]$ 内连续，在开区间 $(a,b)$ 内可导，那么在开区间 $(a,b)$ 内至少有一点 $c$ 使得 $f’(c)=\frac{f(b)-f(a)}{b-a}$<br>中值定理应用的例子：假设有一个函数，对于所有的实数 $x$ 处处可导并且 $f’(x)&gt;4$，证明这个函数 $y=f(x)$ 的图像与线性函数 $y=3x-2$ 最多只有一个交点</p>
<ul>
<li>证明：如果点 $(x,y)$ 是同时满足函数 $y=f(x)$ 和线性函数 $y=3x-2$ 的点，一定会有 $f(x)=3x-2$，运用反证法，假设交点不止一个，任选其中两个，并分配记号 $a$ 和 $b$，使得 $a&lt;b$，由于他们是交点，有 $f(a)=3a-2$ 和 $f(b)=3b-2$，又由于该函数对于所有实数都处处可导且连续，根据中值定理，在开区间 $(a,b)$ 内一定有一点 $c$ 使得 $f’(c)=\frac{f(b)-f(a)}{b-a}$ 代入 $f(a)=3a-2$ 和 $f(b)=3b-2$，可得 $f’(c)=\frac{f(3b-2)-f(3a-2)}{b-a}=\frac{3(b-a)}{b-a}=3$ 与条件中 对于所有 $x$，$f’(x)&gt;4$ 相悖，因此最多只能有一个交点</li>
</ul>
<p>中值定理的推论</p>
<ul>
<li>如果对于在定义域 $(a,b)$ 内的所有 $x$，都有 $f’(x)=0$，那么函数 $f$ 在开区间 $(a,b)$ 内为常数函数</li>
<li>如果对于任意实数 $x$ 都有 $f’(x)=g’(x)$，那么有 $f(x)=g(x)+C$ ( $C$ 为常数)</li>
</ul>
<p>二阶导数在区间内始终为正，则函数在该区间内是凹向上的<br>二阶导数在区间内始终为负，则函数在该区间内是凹向下<br>如果 $x=c$ 点是函数 $f$ 的拐点，则有 $f’’(c)=0$<br>如果 $f’’(c)=0$，$c$ 点不一定是函数 $f$ 的拐点，例如 $f(x)=x^4$</p>
<p>对导数为零点的分类<br>假设有一个函数 $f$ 以及数 $c$ 使得 $f’(c)=0$，即 $x=c$ 处切线为水平的，有三种常见的可能性：$x=c$ 可能为局部最大值；也可能为局部最小值；还可能为水平拐点<br>留白，待补图<br>使用一次导数进行判断</p>
<ul>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号由正变负，那么 $c$ 点为局部最大值</li>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号由负变正，那么 $c$ 点为局部最小值</li>
<li>如果从左往右通过 $c$ 点，$f’(x)$ 的符号不发生变化，那么 $c$ 点为水平拐点</li>
</ul>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 函数、图像和直线</title>
    <url>/calculus/calculus1/</url>
    <content><![CDATA[<h1 id="第一章-函数、图像和直线"><a href="#第一章-函数、图像和直线" class="headerlink" title="第一章 函数、图像和直线"></a>第一章 函数、图像和直线</h1><p>定义域，函数输入的取值范围<br>值域，函数输出的可能值组成的集合<br>上域，函数输出的可能值范围，$上域 \supset 值域$<br>垂线检验，判断是否为函数<br>反函数，$f^{-1}$ 和 $f$ 互为反函数<br>水平线检验，判断是否有反函数<br>反函数与原函数以 $y=x$ 为对称轴<br>函数复合，书写为$f(x)=h(g(x)),f=h \circ g$，即 f 是 g 与 h 的<strong>复合</strong><br>偶函数具有镜面对称性，$f(x)=f(-x)$<br>奇函数具有原点对称性，$f(-x)=-f(x)$<br>只有一个函数是既奇又偶的，即$f(x)=0$<br>两个奇函数之积是偶函数<br>两偶函数之积仍为偶函数<br>奇函数和偶函数之积是奇函数<br>形如 $f(x)=mx+b$ 的函数叫做线性函数，其图像为直线，直线斜率是m<br>确定两点即可确定线性函数的图像<br>线性函数 y 轴的截距为 b ，x 轴截距为 $y=0$ 时自变量 x 的值<br>知道斜率和一个点就可以确定一条直线<br>点斜式：$如果已知直线通过点(x_0,y_0),斜率为m,则它的方程为 y-y_0=m(x-x_0)$<br>如果你知道两个确定点，就可以求出斜率，进而得到直线方程<br>$如果一条直线通过点(x_1,y_1)和(x_2,y_2),则它的斜率等于 \frac{y_2-y_1}{x_2-x_1}$<br>多项式，以 x 的非负次幂为基本项同实数做乘法并将有限个这样的项相加得到<br>每项中所乘实数称作系数，最大的幂指数 n （该项系数不为 0）叫作多项式的次数<br>次数为 n 的多项式的数学通式为<br>$p(x)=a_nx^n+a_{n-1}x^{n-1}+\dots+a_2x^2+a_1x+a_0$<br>其中 $a_n$ 为 $x^n$ 的系数， $a_{n-1}$ 为 $x^{n-1}$ 的系数，以此类推，直到最后一项 $1$ 的系数为 $a_0$<br>多项式图像左右两端的走势是由最高次数的项的系数决定的，该系数叫作<strong>首项系数</strong>，我们只需考虑首项系数正负以及多项式次数的奇偶就能判断图像两端的走势，有四种情况<br>此处留白，图片待补<br>次数为 2 的多项式又叫二次函数<br>一般写作 $p(x)=ax^2+bx+c$<br>我们可以通过判别式的符号确定二次函数有几个实数解，通常我们用希腊字母 $\Delta$ 来表示判别式 $\Delta=b^2-4ac$ ，若 $\Delta ＞ 0$，有两个不同的解，若 $\Delta = 0$，只有一个解， 若$\Delta ＜ 0$，则实数范围内无解，对于前两种情况，有解时，解为$\frac{-b \pm \sqrt{b^2-4ac}}{2a}$<br>二次函数配方<br>举例一枚：考虑二次函数 $2x^2-3x+10$</p>
<ul>
<li>第一步，把二项式系数提出，多项式变为 $2(x^2-\frac{3}{2}x+5)$</li>
<li>第二步，配方，根据完全平方公式，我们通过 x 的系数 $- \frac{3}{2}$ 除以 2，再平方得到配方数 $\frac{9}{16}$，此时括号内式子可变为 $x^2- \frac{3}{2}x+ \frac{9}{16}+5- \frac{9}{16}$</li>
<li>第三步，使用完全平方公式，括号内式子变为 $(x- \frac{3}{4})^2+5- \frac{9}{16}$ ，最后恢复系数得到 $2(x- \frac{3}{4})^2+\frac{71}{8}$</li>
</ul>
<p>有理函数，形如 $\frac{p(x)}{q(x)}$，其中 p 和 q 为多项式的函数，叫作有理函数<br>指数函数，$y=b^x(b&gt;0)$<br>对数函数，$y=log_b(x)$<br>指数函数与对数函数互为反函数<br>$|x-y|$ 是数轴上 x 和 y两点间的距离</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 反函数和反三角函数</title>
    <url>/calculus/calculus10/</url>
    <content><![CDATA[<h1 id="第十章-反函数和反三角函数"><a href="#第十章-反函数和反三角函数" class="headerlink" title="第十章 反函数和反三角函数"></a>第十章 反函数和反三角函数</h1><p>使用导数证明反函数存在，满足水平线检验的图像必定是具有严格单调性的，故如果 $f$ 在其定义域 $(a,b)$ 上可导且满足以下条件中的任意一条，则 $f$ 有反函数</p>
<ul>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x) &gt;0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)&lt;0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)\geqslant0$ 且对于有限个数的 $x$，$f’(x)=0$</li>
<li>对于所有的在 $(a,b)$ 中的 $x$，$f’(x)\leqslant0$ 且对于有限个数的 $x$，$f’(x)=0$</li>
<li>如果其定义域是 $[a,b]、[a,b)、(a,b]$ 的形式，且 $f$ 在整个定义域上连续，那么如果 $f$满足上述条件中的任意一条，它仍然具有反函数</li>
<li>*函数导数值为零的点数有限，否则不满足水平线检验，区间需连续，否则结论不成立</li>
</ul>
<p>反函数的导数，如果 $y=f^{-1}(x)$，则 $\frac{dy}{dx}=\frac{1}{f’(y)}$<br>如果用 $x$ 来表达所有项，那么必须用 $f^{-1}(x)$ 替换 $y$，得到 $\frac{d}{dx}(f^{-1}(x))=\frac{1}{f’(f^{-1}(x))}$<br>原函数处处可导，其反函数不一定处处可导</p>
<p>例子一枚：<br>$f(x)=x^2(x-5)^3$，并且其定义域为 $[2,\infty)$，$f(4)=-16$，计算 $(f^{-1})’(-16)$</p>
<ul>
<li>$y=f^{-1}(x)$</li>
<li>$\frac{dy}{dx}=\frac{1}{f’(y)}=\frac{1}{5y(y-5)^2(y-2)}$</li>
<li>$\frac{dy}{dx}=\frac{1}{5(4)(4-5)^2(4-2)}=\frac{1}{40}$</li>
</ul>
<p>反三角函数，由限制三角函数区间得到<br>$\frac{d}{dx}arcsin(x)=\frac{1}{\sqrt{1-x^2}}$，其中 $-1&lt;x&lt;1$<br>$arcsin$ 是奇函数；其定义域为 $[-1,1]$，值域为 $[-\frac{π}{2},\frac{π}{2}]$<br>$\frac{d}{dx}arccos(x)=-\frac{1}{\sqrt{1-x^2}}$，其中 $-1&lt;x&lt;1$<br>$arccos$ 既不是奇函数也不是偶函数；其定义域为 $[-1,1]$，值域为 $[0,π]$<br>$arcsin$ 和 $arccos$ 的导数互为相反数，即 $\frac{d}{dx}(arcsin(x)+arccos(x))=0$<br>因此通过微积分证明了以下恒等式：<br>$arcsin(x)+arccos(x)=\frac{π}{2}$<br>微积分和几何学殊途同归！！！</p>
<p>对于所有的实数 $x$，$\frac{d}{dx}arctan(x)=\frac{1}{1+x^2}$<br>$arctan$ 是奇函数；其定义域是 $R$，值域为 $(-\frac{π}{2},\frac{π}{2})$<br>$\lim\limits_{x \rightarrow \infty}arctan(x)=\frac{π}{2}$<br>$\lim\limits_{x \rightarrow -\infty}arctan(x)=-\frac{π}{2}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arcsec(x)=\frac{π}{2}$<br>$\lim\limits_{x \rightarrow -\infty}arcsec(x)=\frac{π}{2}$<br>对于 $x&gt;1$ 或 $x&lt;-1$，$\frac{d}{dx}arcsec(x)=\frac{1}{|x|\sqrt{x^2-1}}$<br>$arcsec$ 既不是奇函数也不是偶函数；其定义域是 $(-\infty,-1] \cup [1,\infty)$ 且值域是 $[0,π] \setminus {\frac{π}{2}}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arccsc(x)=0$<br>$\lim\limits_{x \rightarrow -\infty}arccsc(x)=0$<br>对于 $x&gt;1$ 或 $x&lt;-1$，$\frac{d}{dx}arccsc(x)=-\frac{1}{|x|\sqrt{x^2-1}}$<br>$arccsc$ 是奇函数；其定义域为 $(-\infty,-1] \cup [1,\infty)$ 且值域是 $[-\frac{π}{2},\frac{π}{2}] \setminus {0}$</p>
<p>$\lim\limits_{x \rightarrow \infty}arccot(x)=0$<br>$\lim\limits_{x \rightarrow -\infty}arccot(x)=π$<br>对于所有的实数 $x$，$\frac{d}{dx}arccot(x)=-\frac{1}{1+x^2}$<br>$arccot$ 既不是奇函数也不是偶函数；其定义域为 $R$ 且值域是 $(0,π)$</p>
<p>以上留白，待补图例和反函数求导证明</p>
<p>$cosh^{-1}$ 既不是奇函数也不是偶函数；其定义域是 $[1,\infty)$ 且值域是 $[0,\infty)$<br>$sinh^{-1}$ 是奇函数；其定义域和值域都是 $R$</p>
<p>留白，待补图例</p>
<p>对于 $x&gt;1$，$\frac{d}{dx}cosh^{-1}(x)=\frac{1}{\sqrt{x^2-1}}$<br>对于所有的实数 $x$，$\frac{d}{dx}sinh^{-1}(x)=\frac{1}{\sqrt{x^2+1}}$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章 绘制函数图像</title>
    <url>/calculus/calculus12/</url>
    <content><![CDATA[<h1 id="第12章-绘制函数图像"><a href="#第12章-绘制函数图像" class="headerlink" title="第12章 绘制函数图像"></a>第12章 绘制函数图像</h1>]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章 最优化和线性化</title>
    <url>/calculus/calculus13/</url>
    <content><![CDATA[<h1 id="第13章-最优化和线性化"><a href="#第13章-最优化和线性化" class="headerlink" title="第13章 最优化和线性化"></a>第13章 最优化和线性化</h1><p><strong>最优化</strong>，往往是指对于某个我们关心的特定变量，使其在区间内最大化或最小化<br>解决最优化问题的一般方法：</p>
<ul>
<li>识别出所有你可能用到的变量，并确定你试图最大化或最小化的目标变量</li>
<li>确定各个变量的定义域范围</li>
<li>写出关联起不同变量的各个方程</li>
<li>努力通过方程消去其他变量，使得目标变量可以表示为只关于一个变量的函数</li>
<li>对上述函数关于那个变量求导，找出临界点</li>
<li>求出目标变量在临界点及端点所对应的值，得到最大值和最小值</li>
<li>得到结论</li>
</ul>
<p><strong>线性化</strong>，留白</p>
<p>估算或近似计算一个难以计算的数的基本策略：</p>
<ul>
<li>写出主要公式：$f(x) \approx L(x) = f(a)+f’(a)(x-a)$</li>
<li>选择一个函数 $f$ 以及一个数 $x$，使得所求数等于 $f(x)$，同时选取一个接近于 $x$ 的 $a$，并使得 $f(a)$ 易于计算</li>
<li>对 $f$ 求导，计算 $f’(x)$</li>
<li>带入公式计算</li>
</ul>
<p>留白，待补关于误差的讨论</p>
<p><strong>牛顿法</strong>，假设 $a$，是对方程 $f(x)=0$ 的解的一个近似，如果令 $b=a-\frac{f(a)}{f’(a)}$，则在很多情况下，$b$ 是个比 $a$ 更好的近似<br>牛顿法失效的四种情况</p>
<ul>
<li>$f’(a)$ 的值接近于 $0$</li>
<li>如果 $f(x)=0$ 有不止一个解，可能得到的并非所预测的那个解</li>
<li>近似可能变得越来越糟</li>
<li>可能陷入循环</li>
</ul>
<p>留白，待补上述情况图例</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章 洛必达法则</title>
    <url>/calculus/calculus14/</url>
    <content><![CDATA[<h1 id="第14章-洛必达法则"><a href="#第14章-洛必达法则" class="headerlink" title="第14章 洛必达法则"></a>第14章 洛必达法则</h1><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h2><p><strong>洛必达法则</strong>，如果 $f(a)=g(a)=0$，那么 $\lim\limits_{x \rightarrow a}\frac{f(x)}{g(x)}=\lim\limits_{x \rightarrow a}\frac{f’(x)}{g’(x)}$，假设等式右端的极限存在，且当 $x$ 趋于但不等于 $a$ 时，$g’(x)$ 不为 $0$</p>
<h3 id="类型-A-：-frac-0-0-或-frac-pm-infty-pm-infty"><a href="#类型-A-：-frac-0-0-或-frac-pm-infty-pm-infty" class="headerlink" title="类型 $A$：$\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$"></a>类型 $A$：$\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{x^3} \ (\frac{0}{0})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{x^3}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{3x^2}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{6x}=\frac{1}{6}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=\frac{1}{6}$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \infty}\frac{3x^2+7x}{2x^2-5} \ (\frac{\infty}{\infty})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{3x^2+7x}{2x^2-5}\overset{l’H}{=}\lim\limits_{x \rightarrow \infty}\frac{6x+7}{4x}=\lim\limits_{x \rightarrow \infty}(\frac{6}{4}+\frac{7}{4x})=\frac{3}{2}$</li>
</ul>
<p>例子三枚：$\lim\limits_{x \rightarrow 0^+}\frac{csc(x)}{1-ln(x)}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}\frac{csc(x)}{1-ln(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{-csc(x)cot(x)}{-\frac{1}{x}}=\lim\limits_{x \rightarrow 0^+}xcsc(x)cot(x)=\lim\limits_{x \rightarrow 0^+}\frac{x}{sin(x)}\frac{1}{tan(x)}=\infty$</li>
</ul>
<p><strong>只有形如 $\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$ 不定式才能使用洛必达法则</strong></p>
<h3 id="类型-B1-：-pm-infty-infty"><a href="#类型-B1-：-pm-infty-infty" class="headerlink" title="类型 $B1$：$\pm(\infty-\infty)$"></a>类型 $B1$：$\pm(\infty-\infty)$</h3><p>转化为类型 $A$ 求解，经常采取通分的手段进行转化，仅在能将原始表达式转化为两式之比时才能考虑使用洛必达法则<br>例子一枚：$\lim\limits_{x \rightarrow 0}(\frac{1}{sin(x)}-\frac{1}{x})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}(\frac{1}{sin(x)}-\frac{1}{x})=\lim\limits_{x \rightarrow 0}\frac{x-sin(x)}{xsin(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{sin(x)+xcos(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{sin(x)}{cos(x)+cos(x)-xsin(x)}=\frac{0}{2}=0$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})=\lim\limits_{x \rightarrow \infty}(\sqrt{x+ln(x)}-\sqrt{x})×\frac{\sqrt{x+ln(x)}+\sqrt{x}}{\sqrt{x+ln(x)}+\sqrt{x}}=\lim\limits_{x \rightarrow \infty}\frac{x+ln(x)-x}{\sqrt{x+ln(x)}+\sqrt{x}}=\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{\sqrt{x+ln(x)}+\sqrt{x}}\overset{l’H}{=}\lim\limits_{x \rightarrow \infty}\frac{\frac{1}{x}}{\frac{1+\frac{1}{x}}{2\sqrt{x+ln(x)}}+\frac{1}{2\sqrt{x}}}=\lim\limits_{x \rightarrow \infty}\frac{1}{\frac{x+1}{2\sqrt{x+ln(x)}}+\frac{\sqrt{x}}{2}}=0$</li>
</ul>
<h3 id="类型-B2-：-0-×-pm-infty"><a href="#类型-B2-：-0-×-pm-infty" class="headerlink" title="类型 $B2$：$(0 × \pm\infty)$"></a>类型 $B2$：$(0 × \pm\infty)$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0^+}xln(x)$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}xln(x)=\lim\limits_{x \rightarrow 0^+}\frac{ln(x)}{\frac{1}{x}}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{\frac{1}{x}}{-\frac{1}{x^2}}=\lim\limits_{x \rightarrow 0^+}(-x)=0$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow \frac{π}{2}}(x-\frac{\pi}{2})tan(x)$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \frac{π}{2}}(x-\frac{\pi}{2})tan(x)=\lim\limits_{x \rightarrow \frac{π}{2}}\frac{x-\frac{\pi}{2}}{cot(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow \frac{\pi}{2}}\frac{1}{(-csc^2(x))}=\frac{1}{-1}=-1$</li>
</ul>
<h3 id="类型-C-：-1-pm-infty-0-0-或-infty-0"><a href="#类型-C-：-1-pm-infty-0-0-或-infty-0" class="headerlink" title="类型 $C$：$(1^{\pm\infty},0^0 或 \infty^0)$"></a>类型 $C$：$(1^{\pm\infty},0^0 或 \infty^0)$</h3><p>例子一枚：$\lim\limits_{x \rightarrow 0^+}x^{sin(x)}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0^+}ln(x^{sin(x)})=\lim\limits_{x \rightarrow 0^+}sin(x)ln(x)=\lim\limits_{x \rightarrow 0^+}\frac{ln(x)}{csc(x)}\overset{l’H}{=}\lim\limits_{x \rightarrow 0^+}\frac{\frac{1}{x}}{-csc(x)cot(x)}=\lim\limits_{x \rightarrow 0^+}-\frac{sin(x)}{x}×tan(x)=-1\times0=0$</li>
<li>$\lim\limits_{x \rightarrow 0^+}x^{sin(x)}=e^0=1$</li>
</ul>
<p>例子二枚：$\lim\limits_{x \rightarrow 0}(1+3tan(x))^{\frac{1}{x}}$</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}ln((1+3tan(x))^{\frac{1}{x}})=\lim\limits_{x \rightarrow 0}\frac{1}{x}ln(1+3tan(x))=\lim\limits_{x \rightarrow 0}\frac{ln(1+3tan(x))}{x}\overset{l’H}{=}\lim\limits_{x \rightarrow 0}\frac{\frac{3sec^2(x)}{1+3tan(x)}}{1}=\frac{3(1)^2}{1+3(0)}=3$</li>
<li>$\lim\limits_{x \rightarrow 0}(1+3tan(x))^{\frac{1}{x}}=e^3$</li>
</ul>
<h3 id="洛必达法则类型总结"><a href="#洛必达法则类型总结" class="headerlink" title="洛必达法则类型总结"></a>洛必达法则类型总结</h3><ul>
<li><strong>类型A</strong>，如果极限是分式形式，且该分式为形如 $\frac{0}{0}$ 或 $\frac{\pm\infty}{\pm\infty}$ 的不定式时，可以使用洛必达法则 $\lim\limits_{x \rightarrow a}\frac{f(x)}{g(x)}=\lim\limits_{x \rightarrow a}\frac{f’(x)}{g’(x)}$ 在求导的过程中，不要使用商的求导法则，同时为求解新的极限，可能需要再次使用洛必达法则</li>
<li><strong>类型B1</strong>，如果是求差的极限，如 $\lim\limits_{x \rightarrow a}(f(x)-g(x))$，该形式为 $\pm(\infty-\infty)$，可使用通分或者同时乘以除以一个共轭表达式从而转化为类型A进行求解</li>
<li><strong>类型B2</strong>，如果所求极限是乘积的形式，如 $\lim\limits_{x \rightarrow a}f(x)g(x)$，该形式为 $(0 × \pm\infty)$，则选择两个因式中较简单的那个取倒数，将它移至分母(尽量不要选对数做分母，将它留在分子)，将其转化为类型A进行求解</li>
<li><strong>类型C</strong>，如果极限为指数的形式，并且该指数的底数和指数部分都包含变量，例如$\lim\limits_{x \rightarrow a}f(x)^{g(x)}$，我们先取其对数，然后转化为已知易解的形式进行求解</li>
</ul>
<h2 id="关于极限的总结"><a href="#关于极限的总结" class="headerlink" title="关于极限的总结"></a>关于极限的总结</h2>]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第15章 积分</title>
    <url>/calculus/calculus15/</url>
    <content><![CDATA[<h1 id="第15章-积分"><a href="#第15章-积分" class="headerlink" title="第15章 积分"></a>第15章 积分</h1><p>$\sum$ 求和符号<br>过渡章</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第16章 定积分</title>
    <url>/calculus/calculus16/</url>
    <content><![CDATA[<h1 id="第16章-定积分"><a href="#第16章-定积分" class="headerlink" title="第16章 定积分"></a>第16章 定积分</h1><p>留白，待补图积分简例</p>
<p><strong>定积分</strong>，$\displaystyle\int^b_af(x)dx$，读作“函数 $f(x)$ 对于 $x$ 从 $a$ 到 $b$ 的积分”，表达式 $f(x)$ 叫作<strong>被积函数</strong>，$a$ 和 $b$ 说明两条垂线在哪，也叫 <strong>积分极限</strong> 或者 <strong>积分端点</strong>，$dx$ 说明 $x$ 是水平轴的变量，$x$ 是虚拟变量.</p>
<p>如果函数 $f$ 为有界函数并在区间 $[a,b]$ 上有有限个不连续点，那么函数 $f$ 是可积的.</p>
<p>$\displaystyle\int_a^bf(x)dx$ 是由曲线 $y=f(x)$，两条垂线 $x=a$ 和 $x=b$，以及 $x$ 轴所围成的有向面积(平方单位)</p>
<ul>
<li>$\displaystyle\int_b^af(x)dx=-\displaystyle\int_a^bf(x)dx$</li>
<li>$\displaystyle\int_a^af(x)dx=0$</li>
<li>$\displaystyle\int_a^bf(x)dx=\displaystyle\int_a^cf(x)dx+\displaystyle\int_c^bf(x)dx$</li>
<li>$\displaystyle\int_a^bCf(x)dx=C\displaystyle\int_a^bf(x)dx$</li>
<li>$\displaystyle\int_a^b(f(x)+g(x))dx=\displaystyle\int_a^bf(x)dx+\displaystyle\int_a^bg(x)dx$</li>
</ul>
<p>如果对于在区间 $[a,b]$ 内所有的 $x$ 都有 $f(x)\leqslant g(x)$，那么就有 $\displaystyle\int_a^bf(x)dx\leqslant\displaystyle\int_a^bg(x)dx$</p>
<p>如果对于在 $[a,b]$ 区间内的所有 $x$ 有 $m \leqslant f(x) \leqslant M$，那么 $m(b-a) \leqslant \displaystyle\int_a^bf(x)dx \leqslant M(b-a)$</p>
<p>可积函数 $f$ 的平均值定义为：函数 $f$ 在区间 $[a,b]$ 内的平均值 = $\frac{1}{b-a}\displaystyle\int_a^bf(x)dx$</p>
<p><strong>积分的中值定理</strong>，如果函数 $f$ 在闭区间 $[a,b]$ 上连续，那么在开区间 $(a,b)$ 内总有一点 $c$，满足 $f(c)=\frac{1}{b-a}\displaystyle\int_a^bf(x)dx$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第17章 微积分基本定理</title>
    <url>/calculus/calculus17/</url>
    <content><![CDATA[<h1 id="第17章-微积分基本定理"><a href="#第17章-微积分基本定理" class="headerlink" title="第17章 微积分基本定理"></a>第17章 微积分基本定理</h1><h2 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h2><p><strong>微积分的第一基本定理</strong>：如果函数 $f$ 在闭区间 $[a,b]$ 上是连续的，定义 $F$ 为 $F(x)=\displaystyle\int_a^xf(t)dt,x \in [a,b]$ 则 $F$ 在开区间 $(a,b)$ 内是可导函数，而且 $F’(x)=f(x)$<br>简而言之，可以总结为 $\frac{d}{dx}\int_a^xf(t)dt=f(x)$<br><strong>微积分的第二基本定理</strong>：如果函数 $f$ 在闭区间 $[a,b]$ 上是连续的，$F$ 是 $f$ 的任意一个反导数(关于 $x$)，那么有 $\displaystyle\int_a^bf(x)dx=F(b)-F(a)$<br>在实践中，通常写成 $F(x)\big|_a^b=F(b)-F(a)$</p>
<p>例子：$\displaystyle\int_{\frac{\pi}{6}}^{\frac{\pi}{2}}cos(x)dx=sin(x)\big|_{\frac{\pi}{6}}^{\frac{\pi}{2}}=sin(\frac{\pi}{2})-sin(\frac{\pi}{6})=1-\frac{1}{2}=\frac{1}{2}$</p>
<p>$\displaystyle\int f(x)dx$，表示函数 $f$ 的反导数的集合</p>
<p>如果 $\frac{d}{dx}F(x)=f(x)$，那么 $\displaystyle\int f(x)dx=F(x)+C$</p>
<p>通过有无积分上下限区分定积分和不定积分</p>
<ul>
<li>定积分，如 $\displaystyle\int_a^bf(x)dx$ 是一个数.其表示由曲线 $y=f(x)$、$x$ 轴以及垂线 $x=a$ 和 $x=b$ 所围成面积</li>
<li>不定积分，如 $\displaystyle\int f(x)dx$，是一个函数的集合，这个集合由函数 $f$ 的所有反导数(关于 $x$)组成</li>
</ul>
<p>不定积分的两个性质，如果 $f$ 和 $g$ 是可积的，$c$ 是一个常数，这时<br>$\int (f(x)+g(x))dx=\int f(x)dx+\int g(x)dx$<br>$\int cf(x)dx=c \int f(x)dx$</p>
<p>微分和导数是相反的运算</p>
<h2 id="怎样解决问题：微积分的第一基本定理"><a href="#怎样解决问题：微积分的第一基本定理" class="headerlink" title="怎样解决问题：微积分的第一基本定理"></a>怎样解决问题：微积分的第一基本定理</h2><p>$\frac{d}{dx}\int_a^xf(t)dt=f(x)$</p>
<h3 id="变形1：变量是积分下限"><a href="#变形1：变量是积分下限" class="headerlink" title="变形1：变量是积分下限"></a>变形1：变量是积分下限</h3><p>将上限与下限互换，再在新的积分前面加个负号<br>例：$\displaystyle\frac{d}<br>{dx}\int_x^7t^3cos(tln(t))dt$<br>解：$\displaystyle\frac{d}<br>{dx}\int_x^7t^3cos(tln(t))dt\ =\frac{d}{dx}(-\int_7^xt^3cos(tln(t))dt)\ =-x^3cos(xln(x))$</p>
<h3 id="变形2：积分上限是一个函数"><a href="#变形2：积分上限是一个函数" class="headerlink" title="变形2：积分上限是一个函数"></a>变形2：积分上限是一个函数</h3><p>使用链式求导法则<br>例：$\displaystyle\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt$<br>解：先设置这个积分为 $y$<br>$\displaystyle y=\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt$<br>要计算 $\frac{dy}{dx}$，因为 $y$ 是一个关于 $x^2$ 的函数，而非直接关于 $x$，所以我们设置 $u=x^2$<br>$\displaystyle y=\frac{d}{dx}\int_0^utan^{-1}(t^7+3t)dt$<br>根据链式求导法则，<br>$\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$<br>根据微积分第一基本定理，<br>$\displaystyle\frac{dy}{du}=tan^{-1}(u^7+3u)\ \frac{du}{dx}=2x$<br> 用 $x^2$ 替换 $u$，可得答案<br>$\displaystyle\frac{d}{dx}\int_0^{x^2}tan^{-1}(t^7+3t)dt=2xtan^{-1}(x^{14}+3x^2)$</p>
<h3 id="变形3：积分上下限都为函数"><a href="#变形3：积分上下限都为函数" class="headerlink" title="变形3：积分上下限都为函数"></a>变形3：积分上下限都为函数</h3><p>用一个常数将这个积分分成两个部分，然后求解<br>例：$\displaystyle\frac{d}{dx}\int_{x^5}^{x^6}ln(t^2-sin(t)+7)dt$<br>解：</p>
<p>$\begin{aligned}<br>&amp;\ \ \ \ \ \displaystyle\frac{d}{dx}\int_{x^5}^{x^6}ln(t^2-sin(t)+7)dt\\&amp;=\frac{d}{dx}(\int_{x^5}^{0}ln(t^2-sin(t)+7)dt+\int_{0}^{x^6}ln(t^2-sin(t)+7)dt)\\&amp;=\frac{d}{dx}(-\int_{0}^{x^5}ln(t^2-sin(t)+7)dt+\int_{0}^{x^6}ln(t^2-sin(t)+7)dt)\\&amp;=-5x^4ln(x^{10}-sin(x^5)+7)+6x^5ln(x^{12}-sin(x^6)+7)<br>\end{aligned}$</p>
<h3 id="变形4：极限伪装成导数"><a href="#变形4：极限伪装成导数" class="headerlink" title="变形4：极限伪装成导数"></a>变形4：极限伪装成导数</h3><p>例：$\displaystyle\lim\limits_{h \rightarrow 0}\frac{1}{h}\int_x^{x+h}log_3(cos^6(t)+2)dt$<br>解：</p>
<p>$\begin{aligned}<br>&amp;\ \ \ \ \ \displaystyle\lim\limits_{h \rightarrow 0}\frac{1}{h}\int_x^{x+h}log_3(cos^6(t)+2)dt\\&amp;=\lim\limits_{h \rightarrow 0}\frac{F(x+h)-F(x)}{h}\\&amp;=\frac{d}{dx}\int_a^xlog_3(cos^6(t)+2)dt\\&amp;=log_3(cos^6(x)+2)<br>\end{aligned}$</p>
<h2 id="怎样解决问题：微积分的第二基本定理"><a href="#怎样解决问题：微积分的第二基本定理" class="headerlink" title="怎样解决问题：微积分的第二基本定理"></a>怎样解决问题：微积分的第二基本定理</h2><p>留白，待补图<br>例子</p>
<p>微积分第一基本定理的证明</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 极限导论</title>
    <url>/calculus/calculus3/</url>
    <content><![CDATA[<h1 id="第三章-极限导论"><a href="#第三章-极限导论" class="headerlink" title="第三章 极限导论"></a>第三章 极限导论</h1><p>极限，$\lim\limits_{x \rightarrow 0}$<br>通常双侧极限在 $x=a$ 处存在，仅当左极限和右极限在 $x=a$ 处都存在且相等。用数学语言描述为：$\lim\limits_{x \rightarrow a^-}f(x)=L$ 且 $\lim\limits_{x \rightarrow a^+}f(x)=L$ 等价于 $\lim\limits_{x \rightarrow a}f(x)=L$<br>若左极限和右极限不相等，那么双侧极限不存在，缩写“DNE”不存在<br>关于“垂直渐近线”的正式定义<br>“$f$ 在 $x=a$ 处有一条垂直渐近线”说的是，$\lim\limits_{x \rightarrow a^+}f(x)$ 和 $\lim\limits_{x \rightarrow a^-}f(x)$，其中至少有一个极限是 $\infty$ 或 $-\infty$<br>关于“水平渐进线”的定义<br>“$f$ 在 $y=L$ 处有一条右侧水平渐近线”意味着 $\lim\limits_{x \rightarrow \infty}f(x)=L$<br>“$f$ 在 $y=M$ 处有一条左侧水平渐近线”意味着 $\lim\limits_{x \rightarrow -\infty}f(x)=M$<br>水平渐近线的可能数为0、1、2<br>垂直渐近线可以有很多条<br>一个函数可能与水平渐近线相交，例如 $y=\frac{sin(x)}{x},x＞3$<br>三明治定理（夹逼定理）<br>如果对于所有在 a 附近的 x 都有 $g(x) \leqslant f(x) \leqslant h(x)$，且 $\lim\limits_{x \rightarrow a}g(x)=\lim\limits_{x \rightarrow a}h(x)=L$，则 $\lim\limits_{x \rightarrow a}f(x)=L$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 三角学回顾</title>
    <url>/calculus/calculus2/</url>
    <content><![CDATA[<h1 id="第二章-三角学回顾"><a href="#第二章-三角学回顾" class="headerlink" title="第二章 三角学回顾"></a>第二章 三角学回顾</h1><ul>
<li>$正弦函数sin(\theta)$</li>
<li>$余弦函数cos(\theta)$</li>
<li>$正切函数tan(\theta)$</li>
<li>$余割函数csc(\theta)=\frac{1}{sin(\theta)}$</li>
<li>$正割函数sec(\theta)=\frac{1}{cos(\theta)}$</li>
<li>$余切函数cot(\theta)=\frac{1}{tan(\theta)}$</li>
</ul>
<p>毕达哥拉斯定理（勾股定理）：$在一个直角三角形中，直角边的平方之和等于斜边的平方，即a^2+b^2=c^2$<br>ASTC 方法判断各象限内三角函数的符号<br>三角函数的图像<br>留白，此处待补三角函数图像<br>三角函数的奇偶性，$sin(x)、tan(x)、cot(x)，及csc(x)都是x的奇函数，cos(x)和sec(x)都是x的偶函数$<br>三角恒等式<br>$tan(x)=\frac{sin(x)}{cos(x)}，cot(x)=\frac{cos(x)}{sin(x)}$<br>$cos^2(x)+sin^2(x)=1$（毕达哥拉斯定理）<br>$1+tan^2(x)=sec^2(x)$<br>$cot^2(x)+1=csc^2(x)$<br>$三角函数(x)=co-三角函数(\frac{π}{2}-x)$<br>例：</p>
<ul>
<li>$sin(x)=cos(\frac{π}{2}-x)$</li>
<li>$tan(x)=cot(\frac{π}{2}-x)$</li>
<li>$sec(x)=csc(\frac{π}{2}-x)$</li>
<li>$cos(x)=sin(\frac{π}{2}-x)$</li>
<li>$cot(x)=tan(\frac{π}{2}-x)$</li>
<li>$csc(x)=sec(\frac{π}{2}-x)$</li>
</ul>
<p>角的和<br>$sin(A+B)=sin(A)cos(B)+cos(A)sin(B)$<br>$cos(A+B)=cos(A)cos(B)-sin(A)sin(B)$</p>
<p>倍角公式<br>$sin(2x)=2sin(x)cos(x)$<br>$cos(2x)=2cos^2(x)-1=1-2sin^2(x)$</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第18章 积分的方法 I</title>
    <url>/calculus/calculus18/</url>
    <content><![CDATA[<h1 id="第18章-积分的方法-I"><a href="#第18章-积分的方法-I" class="headerlink" title="第18章 积分的方法 I"></a>第18章 积分的方法 I</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><p>例子一枚：$\displaystyle\int x^2cos(x^3)dx$</p>
<ul>
<li>设 $t=x^3$，考虑用 $t$ 替代表达式中的每一个 $x$</li>
<li>$cos(x^3)$ 变为 $cos(t)$；因为 $t=x^3$，所以有 $\frac{dt}{dx}=3x^2$，将 $dx$ 移到等式右侧，有 $dt=3x^2dx$，等式两端同时除以 $3$ 得 $\frac{1}{3}dt=x^2dx$</li>
<li>$\displaystyle\int x^2cos(x^3)dx=\int cos(x^3)(x^2dx)=\int cos(t)(\frac{1}{3}dt)=\frac{1}{3}\int cos(t)dt=\frac{1}{3}sin(t)+C$</li>
<li>最后用 $x^3$ 替代 $t$ 即可</li>
<li>$\displaystyle\int x^2cos(x^3)dx=\frac{1}{3}sin(x^3)+C$</li>
</ul>
<p>如果 $f$ 是可导函数，那么 $\displaystyle\int \frac{f’(x)}{f(x)}dx=ln|f(x)|+C$</p>
<p>关于计算 $\sqrt[n]{ax+b}$ 这种类型的积分，我们有一个非常好的方法.可以简单地设 $\sqrt[n]{ax+b}$，在求 $dt$ 之前先两边同时 $n$ 次方，所以： 在换掉 $\sqrt[n]{ax+b}$ 之前，设 $t=\sqrt[n]{ax+b}$ 并对等式 $t^n=ax+b$ 两端求导<br>例：$\displaystyle\int x\sqrt[5]{3x+2}dx$</p>
<ul>
<li>设 $t=\sqrt[5]{3x+2}$</li>
<li>等式两端 $5$ 次方，得 $t^5=3x+2$</li>
<li>对新等式两端同时求导，得 $5t^4\frac{dt}{dx}=3$</li>
<li>进一步变形，得 $dx=\frac{5}{3}t^4dt$</li>
<li>写出关于$x$ 的表达式：$x=\frac{1}{3}(t^5-2)$</li>
<li>$\displaystyle\int x\sqrt[5]{3x+2}dx=\int \frac{1}{3}(t^5-2)(t)×\frac{5}{3}t^4dt$</li>
<li>$\displaystyle\frac{5}{9}\int (t^{10}-2t^5)dt=\frac{5}{99}t^{11}-\frac{5}{27}t^6+C$</li>
<li>再回到以 $x$ 为变量的积分：用 $t=(3x+2)^{\frac{1}{5}}$ 再替换得 $ \frac{5}{99}(3x+2)^{\frac{11}{5}}-\frac{5}{27}(3x+2)^{\frac{6}{5}}+C$</li>
</ul>
<p>对于<strong>不定积分</strong>，用 $t$ 和 $dt$ 分别表示带有 $x$ 的表达式和 $dx$，然后再求这个新的用 $t$ 表达的积分，最后再换回到 $x$<br>对于<strong>定积分</strong>，用 $t$ 和 $dt$ 分别表示带有 $x$ 的表达式和 $dx$，并且也要把积分上下限换为与 $t$ 相关，这时计算这个新的积分.当然也可以先求不定积分，再将积分上下限分别代入进行求解</p>
<p>如果 $u$ 和 $v$ 是关于 $x$ 的函数，则有 $\frac{d}{dx}(uv)=v\frac{du}{dx}+u\frac{dv}{dx}$<br>重写这个等式，然后两边同时再对 $x$ 求积分，得到 $\displaystyle\int u\frac{dv}{dx}dx=\int \frac{d}{dx}(uv)dx-\int v\frac{du}{dx}dx$<br>等式右侧的第一项是函数 $uv$ 导数的反导数，故证明 $\displaystyle\int u\frac{dv}{dx}dx=uv-\int v\frac{du}{dx}dx$<br>这就是分部积分公式</p>
<p>分部积分公式的简写形式，用 $dv$ 替代 $\frac{dv}{dx}dx$，用 $du$ 替代 $\frac{du}{dx}dx$，得到公式 $\displaystyle\int udv=uv-\int vdu$<br>该公式仅仅是简写形式</p>
<p>例子一枚：$\displaystyle\int xe^xdx$</p>
<ul>
<li>考虑使用分部积分法首先要得到 $\displaystyle\int udv$ 形式的积分</li>
<li>设 $u=x$，$dv=e^xdx$</li>
<li>这时我们有 $\displaystyle\int xe^xdx=\int udv$</li>
<li>然后考虑找到 $du$ 和 $v$</li>
<li>由于 $u=x$，所以 $du=dx$</li>
<li>关于 $v$，我们有 $dv=e^xdx$，同时对等式两侧求积分，$\displaystyle\int dv=\int e^xdx$，得到 $v=e^x$</li>
<li>采用分部积分法：<br>$\begin{aligned}<br>\int u\ \ \ dv\ \ &amp;=uv-\int vdu\\<br>\int x\ \overbrace{e^xdx}&amp;=xe^x-\int e^xdx<br>\end{aligned}$</li>
<li>$\displaystyle\int xe^xdx=xe^x-e^x+C$</li>
</ul>
<p>例子二枚：$\displaystyle\int x^2sin(x)dx$</p>
<ul>
<li>设 $u=x^2$，并且 $dv=sin(x)dx$</li>
<li>可以得到：<br>$\ \ u=x^2\ \ \ \ \ \ \ \ \ \ \ \ v=-cos(x)$<br>$du=2xdx\ \ \ \ \ dv=sin(x)dx$</li>
<li>使用分部积分法：<br>$\begin{aligned}<br>\int u\ \ \ \ \ \ \ dv\ \ \ \ \ \ &amp;=u\ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ -\int \ \ \ \ \ \ v\ \ \ \ \ \ \ \ du\\ \int x^2\overbrace{sin(x)dx}&amp;=x^2\overbrace{(-cos(x))}-\int \overbrace{-cos(x)}\overbrace{2xdx}\\&amp;=-x^2cos(x)+\int cos(x) \cdot 2xdx<br>\end{aligned}$</li>
<li>求解等式右侧的积分</li>
<li>假设 $U=x$ 并且 $dV=cos(x)dx$</li>
<li>可以得到：<br>$\ \ U=x\ \ \ \ \ \ \ \ \ V=sin(x)$<br>$dU=dx\ \ \ \ \ dV=cos(x)dx$</li>
<li>再次使用分部积分法：<br>$\begin{aligned}<br>\int U\ \ \ \ \ dV\ \ \ \ \ &amp;=U\ \ \ \ V\ \ \ \ -\int \ \ \ \ V\ \ \ \ dU\\ \int x\ \overbrace{cos(x)dx}&amp;=x\ sin(x)-\int sin(x)dx<br>\end{aligned}$</li>
<li>已知 $\displaystyle\int sin(x)dx=-cos(x)+C$，所以有 $\displaystyle\int xcos(x)dx=xsin(x)+cos(x)+C$</li>
<li>将这些结果代入原始表达式，得：<br>$\int x^2sin(x)dx=-x^2cos(x)+2xsin(x)+2cos(x)+C$</li>
</ul>
<p>求解有理函数的积分，计算积分 $$\int \frac{p(x)}{q(x)}dx$$</p>
<ul>
<li>第一步 <strong>先看分子分母最高项的次数，如有必要请做多项式除法</strong>，查看分子的次数是否小于分母次数.如果是，则进入第二步，否则做一个多项式除法，然后进入第二步</li>
<li>第二步 <strong>对分母进行因式分解</strong>，使用二次公式或猜想一个根，然后再做除法，以便因式分解被积函数的分母</li>
<li>第三步 <strong>分部</strong>，分别写出带有未知常数的“分部”，写下一个形如：被积函数=分部 的等式</li>
<li>第四步 <strong>计算常数的值</strong>，把方程的两边同时乘以分母，通过任一方法计算常数的值：(a) 换掉 $x$ 的值；(b) 系数相等法；或者结合使用 (a) 和 (b) 两种方法</li>
<li>第五步 <strong>分解分母为线性项次幂的积分</strong>，求解分母是线性函数次幂的积分；答案将会是对数形式或该线性项的负次幂</li>
<li>第六步 <strong>对分母是二次函数的被积函数求积分</strong>，对于分母是二次函数且不能因式分解的被积函数求积分，先配方，然后换元，再把它尽可能分解为两个积分，前者会涉及对数，而第二个会涉及正切函数的反函数，如果仅仅有一个积分，它可能是对数形式又可能是正切函数的反函数形式，这个公式通常是十分实用的：$\displaystyle\int \frac{1}{t^2+a^2}dt=\frac{1}{a}tan^{-1}\big(\frac{t}{a}\big)+C$</li>
</ul>
<p>例子</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 求解多项式的极限问题</title>
    <url>/calculus/calculus4/</url>
    <content><![CDATA[<h1 id="第四章-求解多项式的极限问题"><a href="#第四章-求解多项式的极限问题" class="headerlink" title="第四章 求解多项式的极限问题"></a>第四章 求解多项式的极限问题</h1><h2 id="求解-x-rightarrow-a-时的有理函数的极限"><a href="#求解-x-rightarrow-a-时的有理函数的极限" class="headerlink" title="求解 $x \rightarrow a$ 时的有理函数的极限"></a>求解 $x \rightarrow a$ 时的有理函数的极限</h2><ul>
<li>将 $x=a$ 代入表达式</li>
<li>如果能得到合理值，则此值为所求极限行，否则进行下一步</li>
<li>尝试进行因式分解，删除公因子后得到新表达式，扩大定义域后再次将 $x=a$ 代入进行计算</li>
<li>若求解后答案出现分母为 0 分子不为 0时，则有四种情况可能出现，同时在 $x=a$ 处会有一条垂直渐近线</li>
</ul>
<p>留白，待补图解</p>
<p>补充：立方差公式<br>$a^3-b^3=(a-b)(a^2+ab+b^2)$</p>
<h2 id="求解-x-rightarrow-a-时的平方根的极限"><a href="#求解-x-rightarrow-a-时的平方根的极限" class="headerlink" title="求解 $x \rightarrow a$ 时的平方根的极限"></a>求解 $x \rightarrow a$ 时的平方根的极限</h2><ul>
<li>首先尝试代入表达式求解</li>
<li>如果出现 $\frac{0}{0}$ 的不定式，考虑分子分母同时乘以分子的共轭表达式，即配方使分子可以使用完全平方公式，然后进行化简，再次求解</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的有理函数的极限"><a href="#求解-x-rightarrow-infty-时的有理函数的极限" class="headerlink" title="求解 $x \rightarrow \infty$ 时的有理函数的极限"></a>求解 $x \rightarrow \infty$ 时的有理函数的极限</h2><p>重要的多项式性质：当 x 很大时，首项决定一切。例如 $p(x)=3x^3-1000x^2+5x-7$，同时设 $p_L(x)=3x^3$，即 p 的首项，当 x 变得非常非常大时，$p(x)$ 和 $p_L(x)$ 会相对地非常接近，即 $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=1$<br>留白，待补为什么写成相比趋近于1，而非极限相同<br>证明结论： $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=1$</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p_L(x)}=\lim\limits_{x \rightarrow \infty}\frac{3x^3-1000x^2+5x-7}{3x^3}$</li>
<li>$\lim\limits_{x \rightarrow \infty}(\frac{3x^3}{3x^3}-\frac{1000x^2}{3x^3}+\frac{5x}{3x^3}-\frac{7}{3x^3})=\lim\limits_{x \rightarrow \infty}(1-\frac{1000}{3x}+\frac{5}{3x^2}-\frac{7}{3x^3})$</li>
<li>定理：对于任意的 $n&gt;0$ ，只要 C 是常数，就有 $\lim\limits_{x \rightarrow \infty}\frac{C}{x^n}=0$</li>
<li>$\lim\limits_{x \rightarrow \infty}(\frac{3x^3}{3x^3}-\frac{1000x^2}{3x^3}+\frac{5x}{3x^3}-\frac{7}{3x^3})=\lim\limits_{x \rightarrow \infty}(1-\frac{1000}{3x}+\frac{5}{3x^2}-\frac{7}{3x^3})=1-0+0-0=1$</li>
</ul>
<p>总结：$\lim\limits_{x \rightarrow \infty}\frac{p(x)}{p(x)的首项}=1$，此方法适用于任意的多项式</p>
<p>一般的方法为 $\frac{p(x)}{p(x)的首项}×(p(x)的首项)$,对于每一个多项式都这样做，实例应用：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}=\lim\limits_{x \rightarrow \infty}\frac{\frac{x-8x^4}{-8x^4}×(-8x^4)}{\frac{7x^4+5x^3+2000x^2-6}{7x^4}×(7x^4)}=\lim\limits_{x \rightarrow \infty}\frac{-8x^4}{7x^4}=\frac{-8}{7}$</li>
</ul>
<p>一般地，考虑极限 $\lim\limits_{x \rightarrow \infty}\frac{p(x)}{q(x)}$，<br>其中 p 和 q 为多项式，我们可以判断</p>
<ul>
<li>如果 p 的次数等于 q 的次数，则极限是有限的且非零</li>
<li>如果 p 的次数大于 q 的次数，则极限是 $\infty$ 或 $-\infty$</li>
<li>如果 p 的次数小于 q 的次数，则极限是 0</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的多项式型函数的极限"><a href="#求解-x-rightarrow-infty-时的多项式型函数的极限" class="headerlink" title="求解 $x \rightarrow \infty$ 时的多项式型函数的极限"></a>求解 $x \rightarrow \infty$ 时的多项式型函数的极限</h2><p>整体求解逻辑如之前提到的技巧类似<br>例子一枚：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \infty}\frac{\sqrt{4x^6-5x^5}-2x^3}{\sqrt[3]{27x^6+8x}}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{\sqrt{4x^6-5x^5}-2x^3}{\sqrt[3]{27x^6+8x}}×\frac{\sqrt{4x^6-5x^5}+2x^3}{\sqrt{4x^6-5x^5}+2x^3}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{(4x^6-5x^5)-(2x^3)^2}{\sqrt[3]{27x^6+8x}(\sqrt{4x^6-5x^5}+2x^3)}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{-5x^5}{(\frac{\sqrt[3]{27x^6+8x}}{\sqrt[3]{27x^6}}×(3x^2))(\frac{\sqrt{4x^6-5x^5}+2x^3}{4x^3}×(4x^3))}$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{1}{(\frac{\sqrt[3]{27x^6+8x}}{\sqrt[3]{27x^6}})(\frac{\sqrt{4x^6-5x^5}+2x^3}{4x^3})}×\frac{-5x^5}{(3x^2)(4x^3)}$</li>
<li>$\frac{-5}{12}$</li>
</ul>
<h2 id="求解-x-rightarrow-infty-时的有理函数的极限-1"><a href="#求解-x-rightarrow-infty-时的有理函数的极限-1" class="headerlink" title="求解 $x \rightarrow -\infty$ 时的有理函数的极限"></a>求解 $x \rightarrow -\infty$ 时的有理函数的极限</h2><p>基本求解逻辑与以上思路相近<br>补充总结：<br>如果 $x＜0$，并且想写 $\sqrt[n]{x^{某次幂}}=x^m$，那么需要在 $x^m$ 之前加一个负号的唯一情形是，n 是偶的而 m 是奇的</p>
<h2 id="求解包含绝对值的函数的极限"><a href="#求解包含绝对值的函数的极限" class="headerlink" title="求解包含绝对值的函数的极限"></a>求解包含绝对值的函数的极限</h2><p>分段处理</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 连续性和可导性</title>
    <url>/calculus/calculus5/</url>
    <content><![CDATA[<h1 id="第五章-连续性和可导性"><a href="#第五章-连续性和可导性" class="headerlink" title="第五章 连续性和可导性"></a>第五章 连续性和可导性</h1><p>关于在一点处连续：如果 $\lim\limits_{x \rightarrow a}f(x)=f(a)$，函数 f 在点 $x=a$ 处连续，若函数在某点连续，须明确以下三条成立</p>
<ul>
<li>双侧极限 $\lim\limits_{x \rightarrow a}f(x)$ 存在，且是有限的</li>
<li>函数在点 $x=a$ 处有定义，即 $f(a)$ 存在，且是有限的</li>
<li>$\lim\limits_{x \rightarrow a}f(x)=f(a)$</li>
</ul>
<p>关于区间上的连续性，需要区间中所有的点都连续，若区间为闭区间，则两端点需满足单侧连续性</p>
<p>一个连续函数的常数倍是连续的<br>两个连续函数做加减乘以及复合运算也会得到一个连续函数。当用一个连续函数除以另一个连续函数时，除了分母为零的点外，商函数处处连续。</p>
<p>介值定理：如果 f 在 $[a,b]$ 上连续，并且 $f(a)&lt;0$ 且 $f(b)&gt;0$，那么在区间 $(a,b)$ 上至少有一点 c ，使得 $f(c)=0$，代之以 $f(a)&gt;0$ 且 $f(b)&lt;0$，同样成立</p>
<p>一个区间是连续的，则在此区间内必然有极大极小值</p>
<p>导数，记作 $f’=\frac{dy}{dx}$</p>
<p>对导数再次求导得到的导数称为二阶导，写作 $f’’$</p>
<p>二阶导数，记作 $f’’=\frac{d^2y}{dx^2}$<br>高阶导数，记作 $f^{(n)}(x)$</p>
<p>若导数存在，那么左右导数都存在且等于导数值<br>存在不可导的连续函数，不存在不连续的可导函数<br>如果一个函数 $f$ 在 $x$ 上可导，那么它在 $x$ 上连续</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 隐函数求导和相关变化率</title>
    <url>/calculus/calculus8/</url>
    <content><![CDATA[<h1 id="第八章-隐函数求导和相关变化率"><a href="#第八章-隐函数求导和相关变化率" class="headerlink" title="第八章 隐函数求导和相关变化率"></a>第八章 隐函数求导和相关变化率</h1><p><strong>隐函数的求导</strong></p>
<ul>
<li>在原始方程中，对一切求导并使用链式求导法则、乘积法则、以及商法则进行化简</li>
<li>如果求的是特定值的斜率，则么先代入 x 和 y 的已知值，整理求出 $\frac{dy}{dx}$</li>
</ul>
<p><strong>隐函数求二次导</strong>，是在一次导的情况下再对每一项做一次求导运算，得到结果中可能有一阶导数，记得代入计算即可</p>
<p><strong>相关变化率</strong>，量 $Q$ 的变化率是 $Q$ 关于时间的导数，也就是说，如果 $Q$ 是某个量，那么 $Q$ 的变化率是 $\frac{dQ}{dt}$</p>
<p>求解相关变化率问题的一般方法</p>
<ul>
<li>读题，识别出所有的量并注意到哪一个量是你需要对其求相关变化率的</li>
<li>写出一个关联所有量的方程(有时可能不止一个方程)</li>
<li>对剩余的方程关于时间 t 做隐函数求导，对每一个方程两边添加一个 $\frac{d}{dt}$，得到一个或多个关联起各个变化率的方程</li>
<li>最后将所有已知值代入所有方程中做替换，联立求解方程得到所求解的变化率</li>
</ul>
<p>留白，待补例题 n 个</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 三角函数的极限和导数</title>
    <url>/calculus/calculus7/</url>
    <content><![CDATA[<h1 id="第七章-三角函数的极限和导数"><a href="#第七章-三角函数的极限和导数" class="headerlink" title="第七章 三角函数的极限和导数"></a>第七章 三角函数的极限和导数</h1><p>学会判断极限中实际上是大数还是小数<br>重要的公式</p>
<ul>
<li>$\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=1$</li>
<li>$\lim\limits_{x \rightarrow 0}cos(x)=1$</li>
<li>$\lim\limits_{x \rightarrow 0}\frac{tan(x)}{x}=1$</li>
<li>$\lim\limits_{x \rightarrow 0}\frac{1-cos(x)}{x}=0$</li>
<li>$\lim\limits_{x \rightarrow \infty}\frac{sin(x)}{x}=0$ (三明治定理证明)</li>
<li>学会换元求解</li>
<li>学会借助 $-1 \leq sin(x) \leq 1$ 以及 $-1 \leq cos(x) \leq 1$ 的不等式拓展，从而通过求出多项式型的极限，进而使用三明治定理，求出含三角函数的极限</li>
<li>对于任意的正指数 $\alpha$ :$\lim\limits_{x \rightarrow \infty}\frac{sin(任何东西)}{x^\alpha}=0$</li>
</ul>
<p>$sin(x)$ 表现的像 x，仅在乘积或商的语境中才成立，除了常数函数 0 本身，没有任何函数表现得像 0</p>
<p>面对 $x \rightarrow a$ 的极限，而 $a \neq 0$ 时，有一个很好的的一般原则，那就是用 $t = x - a$ 作替换，将问题转化为 $t \rightarrow 0$<br>例子一枚：</p>
<ul>
<li>$\lim\limits_{x \rightarrow \frac{π}{2}}\frac{cos(x)}{x-\frac{π}{2}}$</li>
<li>$\lim\limits_{t \rightarrow 0}\frac{cos(t+\frac{π}{2})}{t}$</li>
<li>三角恒等式 $cos(\frac{π}{2}-x)=sin(x)$</li>
<li>$cos(\frac{π}{2}+t)=sin(-t)=-sin(t)$</li>
<li>$\lim\limits_{t \rightarrow 0}\frac{-sin(t)}{t}=-1$</li>
</ul>
<p>重要证明 $\lim\limits_{x \rightarrow 0}\frac{sin(x)}{x}=1$</p>
<ul>
<li>$\frac{sin(x)}{2} &lt; \frac{x}{2} &lt; \frac{tan(x)}{2}$</li>
<li>$sin(x) &lt; x &lt; tan(x),0 &lt; x &lt; \frac{π}{2}$</li>
<li>$\frac{1}{sin(x)} &gt; \frac{1}{x} &gt; \frac{cos(x)}{sin(x)}$</li>
<li>$cos(x) &lt; \frac{sin(x)}{x} &lt; 1$</li>
<li>运用三明治定理证明左右极限</li>
</ul>
<p>留白，待补三角函数求导总结</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 求解微分问题</title>
    <url>/calculus/calculus6/</url>
    <content><![CDATA[<h1 id="第六章-求解微分问题"><a href="#第六章-求解微分问题" class="headerlink" title="第六章 求解微分问题"></a>第六章 求解微分问题</h1><p>使用导数的定义求导，即 $f’(x)=\lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}$<br>留白，待补微分求导图<br>乘积法则版本1：如果 $h(x)=f(x)g(x)$，那么 $h’(x)=f’(x)g(x)+f(x)g’(x)$<br>乘积法则版本2：如果 $y=uv$，则 $\frac{dy}{dx}=v\frac{du}{dx}+u\frac{dv}{dx}$<br>乘积法则(三个变量)：如果 $y=uvw$，那么 $\frac{dy}{dx}=\frac{du}{dx}vw+u\frac{dv}{dx}w+uv\frac{dw}{dx}$<br>商法则(版本1)：如果 $h(x)=\frac{f(x)}{g(x)}$，那么 $h’(x)=\frac{f’(x)g(x)-f(x)g’(x)}{(g(x))^2}$<br>商法则(版本2)：如果 $y=\frac{u}{v}$，那么 $\frac{dy}{dx}=\frac{v\frac{du}{dx}-u\frac{dv}{dx}}{v^2}$<br>链式求导法则求复合函数的导数<br>链式求导法则(版本1)：如果 $h(x)=f(g(x))$，那么 $h’(x)=f’(g(x))g’(x)$<br>链式求导法则(版本2)：如果 $y$ 是 $u$ 的函数，并且 $u$ 是 $x$ 的函数，那么 $\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$<br>极限可能是伪装的导数</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 指数函数和对数函数</title>
    <url>/calculus/calculus9/</url>
    <content><![CDATA[<h1 id="第九章-指数函数和对数函数"><a href="#第九章-指数函数和对数函数" class="headerlink" title="第九章 指数函数和对数函数"></a>第九章 指数函数和对数函数</h1><h2 id="指数法则"><a href="#指数法则" class="headerlink" title="指数法则"></a>指数法则</h2><ul>
<li>$b^0=1$ 任意非零数的零次幂是 $1$</li>
<li>$b^1=b$ 一个数的一次幂正好是该数本身</li>
<li>$b^xb^y=b^{x+y}$ 当将两个底数相同的幂相乘时，将指数相加</li>
<li>$\frac{b^x}{b^y}=b^{x-y}$ 当将两个底数相同的幂相除时，将分子的指数减去分母的指数</li>
<li>$(b^x)^y=b^{xy}$ 当取幂的幂时，将指数相乘</li>
</ul>
<p>$log_b(y)$ 是为了得到 $y$ 你必须将底数 $b$ 提升的幂次，即 $b^{log_b(y)}=y$</p>
<p>指数函数和对数函数为反函数</p>
<p>对数的指数就是原始的数，即 $log_b(b^x)=x$ (对于任意的实数 $x$ 及 $b&gt;1$)</p>
<h2 id="对数法则"><a href="#对数法则" class="headerlink" title="对数法则"></a>对数法则</h2><ul>
<li>$log_b(1)=0$</li>
<li>$log_b(b)=1$</li>
<li>$log_b(xy)=log_b(x)+log_b(y)$ 乘积的对数是对数的和</li>
<li>$log_b(\frac{x}{y})=log_b(x)-log_b(y)$ 商的对数是对数的差</li>
<li>$log_b(x^y)=ylog_b(x)$ 对数将指数移至对数之前，该方法中，$y$ 可以是任意的实数</li>
<li>换底法则，对于任意的底数 $b&gt;1$ 和 $c&gt;1$ 及任意的数 $x&gt;0$，$log_b(x)=\frac{log_c(x)}{log_c(b)}$，这意味着，所有的不同底数的对数函数其实是互为常数倍的，即 $log_b(x)=Klog_c(x)$</li>
</ul>
<p>留白，待补相关证明(*)</p>
<p>底数为 $e$ 的对数称为自然对数</p>
<p>留白，待补关于 $\lim\limits_{h \rightarrow 0^-}(1+rh)^{\frac{1}{h}}$ 的左极限证明</p>
<h2 id="关于-e-的公式"><a href="#关于-e-的公式" class="headerlink" title="关于 $e$ 的公式"></a>关于 $e$ 的公式</h2><ul>
<li>$\lim\limits_{n \rightarrow \infty}(1+\frac{x}{n})^n=e^x$</li>
<li>$\lim\limits_{h \rightarrow 0}(1+xh)^{\frac{1}{h}}=e^x$</li>
<li>$\lim\limits_{n \rightarrow \infty}(1+\frac{1}{n})^n=e$</li>
<li>$\lim\limits_{h \rightarrow 0}(1+h)^{\frac{1}{h}}=e$</li>
</ul>
<p>令 $g(x)=log_b(x)$，对 $g$ 求导</p>
<ul>
<li>根据导数定义，<br>$\begin{aligned}<br>g’(x) &amp;=\lim\limits_{h \rightarrow 0}\frac{g’(x+h)-g(x)}{h}\<br>&amp;=\lim\limits_{h \rightarrow 0}\frac{log_b(x+h)-log_b(x)}{h}\<br>&amp;=\lim\limits_{h \rightarrow 0}\frac{1}{h}log_b(\frac{x+h}{x})\<br>&amp;=\lim\limits_{h \rightarrow 0}log_b(1+\frac{h}{x})^{\frac{1}{h}}\<br>&amp;=log_b(e^{\frac{1}{x}})<br>\end{aligned}$</li>
<li>$\frac{d}{dx}log_b(x)=\frac{1}{x}log_b(e)$</li>
<li>若设 $b=e$，那么就能得到以 $e$ 为底的对数的导数了，即 $\ \frac{d}{dx}log_e(x)=\frac{1}{x}log_e(e)=\frac{1}{x}$</li>
</ul>
<p>得到重要公式</p>
<ul>
<li>$\frac{d}{dx}ln(x)=\frac{1}{x}$</li>
<li>$\frac{d}{dx}log_b(x)=\frac{1}{xln(b)}$$(log_b(e)=\frac{log_e(e)}{log_e(b)}=\frac{1}{ln(b)})$</li>
</ul>
<p>推导指数函数导数 $y=b^x$</p>
<ul>
<li>$y=b^x$</li>
<li>$x=log_b(y)$</li>
<li>对上述公式关于 $y$ 求导</li>
<li>$\frac{dx}{dy}=\frac{1}{yln(b)}$</li>
<li>根据链式求导法则，可上下颠倒得到</li>
<li>$\frac{dy}{dx}=yln(b)$</li>
<li>由于 $y=b^x$，故证明以下公式</li>
<li>$\frac{d}{dx}(b^x)=b^xln(b)$</li>
<li>特别地，$\frac{d}{dx}(e^x)=e^x$</li>
</ul>
<p>$\lim\limits_{h \rightarrow 0}\frac{e^h-1}{h}=1$<br>证明：</p>
<ul>
<li>根据极限定义 $\ \lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}=f’(x)$</li>
<li>变为 $\lim\limits_{h \rightarrow 0}\frac{e^{x+h}-e^x}{h}=e^x$</li>
<li>用 $0$ 替换 $x$ 即可得到 $\lim\limits_{h \rightarrow 0}\frac{e^h-1}{h}=1$</li>
</ul>
<p>求解 $\lim\limits_{h \rightarrow 0}\frac{ln(1+h)}{h}$</p>
<ul>
<li>这是一个导数伪装的极限</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{f(x+h)-f(x)}{h}=f’(x)$</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{ln(x+h)-ln(x)}{h}=\frac{1}{x}$</li>
<li>将 $x=1$ 代入，并得到</li>
<li>$\lim\limits_{h \rightarrow 0}\frac{ln(1+h)-ln(1)}{h}=1$</li>
<li>结论 $\lim\limits_{h \rightarrow 0}\frac{ln(1+h)}{h}=1$</li>
</ul>
<p>例子一枚：</p>
<ul>
<li>求解 $\lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{5h^2}$</li>
<li>$\ \ \ \ \lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{5h^2}\ =\lim\limits_{h \rightarrow 0}\frac{ln(1-7h^2)}{-7h^2}×\frac{-7h^2}{5h^2}\ =\frac{-7}{5}$</li>
</ul>
<p>$\lim\limits_{x \rightarrow \infty}e^x=\infty$<br>$\lim\limits_{x \rightarrow -\infty}e^x=0$</p>
<p>指数函数增长迅速，$\lim\limits_{x \rightarrow \infty}\frac{x^n}{e^x}=0$<br>其中 $x^n$ 可替换为多项式型函数，$e^x$ 可替换为指数为大的、正的多项式型指数函数，陈述依然成立</p>
<p>$\lim\limits_{x \rightarrow \infty}ln(x)=\infty$</p>
<p>对数函数增长缓慢，不管 $a$ 有多小，如果 $a&gt;0$，$\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{x^a}=0$<br>其中 $ln(x)$ 可替换为任何正的多项式型的对数函数，$x^a$ 可替换为具有正的幂次的多项式型函数，陈述依然成立</p>
<p>对数函数和指数函数互为反函数，如果你取 $\frac{ln(x)}{x^a}$，并用 $e^t$ 替换 $x$，那么你会得到<br>$\lim\limits_{x \rightarrow \infty}\frac{ln(x)}{x^a}=\lim\limits_{t \rightarrow \infty}\frac{ln(e^t)}{(e^t)^a}=\lim\limits_{t \rightarrow \infty}\frac{t}{e^{at}}=0$<br>这样就证明了指数函数增长迅速这一事实会自动导出对数函数增长缓慢这一结论</p>
<p>求解极限 $\lim\limits_{x \rightarrow 0^+}xln(x)$</p>
<ul>
<li>首先考虑我们直接代入，因为 $ln(0)$ 不存在，所以不能这样求解</li>
<li>我们用 $\frac{1}{t}$ 替换 $x$，于是当 $x \rightarrow 0^+$ 时，可以得到 $t \rightarrow \infty$，因此有</li>
<li>$\lim\limits_{x \rightarrow 0^+}xln(x)=\lim\limits_{t \rightarrow \infty}\frac{1}{t}ln(\frac{1}{t})$</li>
<li>$ln(\frac{1}{t})=ln(1)-ln(t)=-ln(t)$</li>
<li>$\lim\limits_{t \rightarrow \infty}\frac{1}{t}ln(\frac{1}{t})=\lim\limits_{t \rightarrow \infty}\frac{-ln(t)}{t}=0$</li>
<li>由于对数函数增长缓慢，故极限是0</li>
<li>技巧：用 $\frac{1}{t}$ 替换 $x$ 可以将对数函数在 $0$ 附近的行为转换为在 $\infty$ 附近的行为</li>
</ul>
<p>对数函数在 $0$ 附近“增长缓慢”：不管 $a$ 有多小，如果 $a&gt;0$，$\lim\limits_{x \rightarrow 0^+}x^aln(x)=0$<br>其中 $x^a$ 可替换为任何多项式型函数，$ln(x)$ 的底数可替换为任意其他大于 1 的底数，陈述依然成立</p>
<p>对形如 $f(x)^{g(x)}$ 的函数关于 $x$ 求导</p>
<ul>
<li>设 $y$ 是想要求导的 $x$ 的函数<br>$y=f(x)^{g(x)}$</li>
<li>对等号两边取对数，右边的指数 $g$得以移动下来<br>$ln(y)=ln(f(x)^{g(x)})=g(x)ln(f(x))$</li>
<li>对等号两边关于 $x$ 做隐函数求导</li>
<li>用 $f(x)^{g(x)}$ 替换 $y$，求出 $\frac{dy}{dx}$，完成求解</li>
</ul>
<p>学会使用取对数求导</p>
<ul>
<li>$\frac{d}{dx}(x^a)=ax^{a-1}$</li>
<li>证明<br>$\begin{aligned}<br>y&amp;=x^a\<br>ln(y)&amp;=aln(x)\<br>\frac{1}{y}\frac{dy}{dx}&amp;=\frac{a}{x}\<br>\frac{dy}{dx}&amp;=\frac{ay}{x}\<br>\frac{dy}{dx}&amp;=\frac{ax^a}{x}\<br>\frac{dy}{dx}&amp;=ax^{a-1}<br>\end{aligned}$</li>
</ul>
<p>如果 $\frac{dy}{dx}=ky$，那么 $y=Ae^{kx}$，其中 $A$ 为某个常数</p>
<p>指数增长方程：$P(t)=P_0e^{kt}$<br>其中 $P_0$是初始的总数，$k$ 是增长常数</p>
<h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><p>双曲余弦函数 $cosh(x)=\frac{e^x+e^{-x}}{2}$<br>双曲正弦函数 $sinh(x)=\frac{e^x-e^{-x}}{2}$</p>
<ul>
<li>$cosh^2(x)=(\frac{e^x+e^{-x}}{2})^2=\frac{e^{2x}+e^{-2x}+2}{4}$</li>
<li>$sinh^2(x)=(\frac{e^x-e^{-x}}{2})^2=\frac{e^{2x}+e^{-2x}-2}{4}$</li>
<li>$cosh^2(x)-sinh^2(x)=1$</li>
</ul>
<p>$\frac{d}{dx}sinh(x)=cosh(x)$<br>$\frac{d}{dx}cosh(x)=sinh(x)$</p>
<ul>
<li>$\frac{d}{dx}sinh(x)=\frac{d}{dx}(\frac{e^x-e^{-x}}{2})=\frac{e^x+e^{-x}}{2}=cosh(x)$</li>
<li>$\frac{d}{dx}cosh(x)=\frac{d}{dx}(\frac{e^x+e^{-x}}{2})=\frac{e^x-e^{-x}}{2}=sinh(x)$</li>
</ul>
<p>留白，待补双曲函数图像</p>
<p>关于双曲函数的导数</p>
<ul>
<li>$\frac{d}{dx}sinh(x)=cosh(x)$</li>
<li>$\frac{d}{dx}cosh(x)=sinh(x)$</li>
<li>$\frac{d}{dx}tanh(x)=sech^2(x)$</li>
<li>$\frac{d}{dx}sech(x)=-sech(x)tanh(x)$</li>
<li>$\frac{d}{dx}csch(x)=-csch(x)coth(x)$</li>
<li>$\frac{d}{dx}coth(x)=-csch^2(x)$</li>
</ul>
]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数学笔记</tag>
        <tag>普林斯顿微积分读本</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.11 数位统计类动态规划题解</title>
    <url>/luogu4-11-problems/</url>
    <content><![CDATA[<h1 id="Part-4-11-数位统计类动态规划题解"><a href="#Part-4-11-数位统计类动态规划题解" class="headerlink" title="Part 4.11 数位统计类动态规划题解"></a>Part 4.11 数位统计类动态规划题解</h1><h2 id="P2602-数字计数"><a href="#P2602-数字计数" class="headerlink" title="P2602 数字计数"></a>P2602 数字计数</h2><h3 id="题目链接：-ZJOI2010-数字计数-洛谷"><a href="#题目链接：-ZJOI2010-数字计数-洛谷" class="headerlink" title="题目链接：[ZJOI2010] 数字计数 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2602">[ZJOI2010] 数字计数 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码 (digit) 各出现了多少次。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>状态记录：前导0，当前位置数码数量</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> dig,ll sum,<span class="type">bool</span> lead0,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0&amp;&amp;dp[pos][sum]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">    ll ans=<span class="number">0</span>,end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,dig,sum+((lead0||i)&amp;&amp;i==dig),lead0||i,limit&amp;&amp;(i==end));</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0) dp[pos][sum]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x,<span class="type">int</span> dig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,dig,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,<span class="built_in">solve</span>(r,i)-<span class="built_in">solve</span>(l<span class="number">-1</span>,i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2657-windy-数"><a href="#P2657-windy-数" class="headerlink" title="P2657 windy 数"></a>P2657 windy 数</h2><h3 id="题目链接：-SCOI2009-windy-数-洛谷"><a href="#题目链接：-SCOI2009-windy-数-洛谷" class="headerlink" title="题目链接：[SCOI2009] windy 数 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2657">[SCOI2009] windy 数 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>状态记录：前导零，前一个位数</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> lead0,<span class="type">int</span> pre,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lead0&amp;&amp;!limit&amp;&amp;dp[pos][pre]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead0&amp;&amp;<span class="built_in">abs</span>(pre-i)&lt;<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,lead0||i,i,limit&amp;&amp;i==end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lead0&amp;&amp;!limit) dp[pos][pre]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4124-手机号码"><a href="#P4124-手机号码" class="headerlink" title="P4124 手机号码"></a>P4124 手机号码</h2><h3 id="题目链接：-CQOI2016-手机号码-洛谷"><a href="#题目链接：-CQOI2016-手机号码-洛谷" class="headerlink" title="题目链接：[CQOI2016]手机号码 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4124">[CQOI2016]手机号码 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>工具需要检测的号码特征有两个：号码中要出现至少 3 个相邻的相同数字；号码中不能同时出现 8 和 4。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。</p>
<p>手机号码一定是 11 位数，前不含前导的 0。工具接收两个数 L 和 R，自动统计出 [L,R] 区间内所有满足条件的号码数量。L 和 R 也是 11 位的手机号码。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>状态记录：前前一位数，前一位数，整体是否符合要求，是否出现四，是否出现八</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">15</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> ppre,<span class="type">int</span> pre,<span class="type">bool</span> st,<span class="type">bool</span> four,<span class="type">bool</span> eight,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(eight&amp;&amp;four) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> st;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[pos][ppre][pre][st][four][eight]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[pos][ppre][pre][st][four][eight];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,pre,i,(st||(i==ppre&amp;&amp;i==pre)),(four||i==<span class="number">4</span>),(eight||i==<span class="number">8</span>),(limit&amp;&amp;i==end));</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][ppre][pre][st][four][eight]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos!=<span class="number">11</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a[pos];i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,i,<span class="number">0</span>,i==<span class="number">4</span>,i==<span class="number">8</span>,i==a[pos]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4999-烦人的数学作业"><a href="#P4999-烦人的数学作业" class="headerlink" title="P4999 烦人的数学作业"></a>P4999 烦人的数学作业</h2><h3 id="题目链接：烦人的数学作业-洛谷"><a href="#题目链接：烦人的数学作业-洛谷" class="headerlink" title="题目链接：烦人的数学作业 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4999">烦人的数学作业 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>给出一个区间$ L $~$ R $，求$ L $到$ R $区间内<strong>每个数的数字和</strong>，如123这个数的数字和为1+2+3=6。</p>
<p>（$ 1 \leq L \leq R \leq 10^2 $）</p>
<p>同学们纷纷做出来了，Mr.G一看这最后一题跟摆设没区别了呀，于是他迅速修改了题目，把范围定得非常非常大，且有$ T $组数据，将最终的答案mod $ 10^9+7 $。</p>
<p>（$ 1 \leq L \leq R \leq 10^{18} $）<br>（$ 1 \leq T \leq 20  $）</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>数字计数问题做一遍加和</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> dig,ll sum,<span class="type">bool</span> lead0,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0&amp;&amp;dp[pos][sum]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">    ll ans=<span class="number">0</span>,end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,dig,sum+((lead0||i)&amp;&amp;i==dig),lead0||i,limit&amp;&amp;(i==end));</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0) dp[pos][sum]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x,<span class="type">int</span> dig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,dig,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        (ans+=((((<span class="built_in">solve</span>(r,i)-<span class="built_in">solve</span>(l<span class="number">-1</span>,i)+mod)%mod)*i)%mod+mod)%mod)%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">cal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 4.11 数位统计类动态规划</title>
    <url>/luogu4-11/</url>
    <content><![CDATA[<h1 id="Part-4-11-数位统计类动态规划"><a href="#Part-4-11-数位统计类动态规划" class="headerlink" title="Part 4.11 数位统计类动态规划"></a>Part 4.11 数位统计类动态规划</h1><h2 id="数位dp-–-记忆化搜索模板"><a href="#数位dp-–-记忆化搜索模板" class="headerlink" title="数位dp – 记忆化搜索模板"></a>数位dp – 记忆化搜索模板</h2><p> 求出在给定区间[A,B]内，符合条件f(i)的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关</p>
<p>由于数是按位dp，<strong>数的大小对复杂度的影响很小</strong></p>
<p>从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。</p>
<p>对于[l,r]区间问题，我们一般把他转化为两次数位dp,即找[0,r]和[0,l−1]两段，再将结果相减就得到了我们需要的[l,r]dfs</p>
<p><strong>记忆化搜索dfs需要哪些参量</strong>？</p>
<ol>
<li><p>首先是数位dp基本的量数字位数pos，记录答案的st，最高位限制limit（这个后面会讲）</p>
</li>
<li><p>我们还需要一个判断判断前导0的标记lead（这个后面也会讲）</p>
</li>
<li><p>由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定），所以一般在dfs()中也要记录前一位或前几位数pre方便比较。</p>
</li>
<li><p>除此之外还可以传进更多参量以区分状态，视题意而定。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> st,...,<span class="type">bool</span> lead0,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//pos表示当前遍历位置，st表示上一层状态，lead0表示有无前导零，limit表示是否到达极值</span></span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0&amp;&amp;dp[pos][st]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][st];<span class="comment">//记忆化</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,end=limit?a[pos]:<span class="number">9</span>;<span class="comment">//确定遍历范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        <span class="keyword">if</span>(condition) <span class="keyword">continue</span>;<span class="comment">//不满足条件的状态跳过</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,st,...,lead0||i,limit&amp;&amp;i==end);</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][st]=ans;<span class="comment">//记忆化</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//划分数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,...,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 6.1 位运算题解</title>
    <url>/luogu6-1-problems/</url>
    <content><![CDATA[<h1 id="Part-6-1-位运算题解"><a href="#Part-6-1-位运算题解" class="headerlink" title="Part 6.1 位运算题解"></a>Part 6.1 位运算题解</h1><h2 id="P5657-格雷码"><a href="#P5657-格雷码" class="headerlink" title="P5657 格雷码"></a>P5657 格雷码</h2><h3 id="题目链接：-CSP-S2019-格雷码-洛谷"><a href="#题目链接：-CSP-S2019-格雷码-洛谷" class="headerlink" title="题目链接：[CSP-S2019] 格雷码 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5657">[CSP-S2019] 格雷码 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间<strong>恰好</strong>有一位<strong>不同</strong>，特别地，第一个串与最后一个串也算作相邻。</p>
<p>所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。</p>
<p>$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：</p>
<ol>
<li>1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。</li>
<li>$n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按<strong>顺序</strong>排列，再在每个串前加一个前缀 0 构成。</li>
<li>$n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按<strong>逆序</strong>排列，再在每个串前加一个前缀 1 构成。</li>
</ol>
<p>综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。</p>
<p>现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=a,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>!=<span class="number">0</span>) ans*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="built_in">qpow</span>(<span class="number">2</span>,i);</span><br><span class="line">        ll mid=(res<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=mid) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);k=res<span class="number">-1</span>-k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5514-永夜的报应"><a href="#P5514-永夜的报应" class="headerlink" title="P5514 永夜的报应"></a>P5514 永夜的报应</h2><h3 id="题目链接：-MtOI2019-永夜的报应-洛谷"><a href="#题目链接：-MtOI2019-永夜的报应-洛谷" class="headerlink" title="题目链接：[MtOI2019]永夜的报应 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5514">[MtOI2019]永夜的报应 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>辉夜手里有 n 个非负整数 a1​,a2​⋯an​，她希望智慧的你来帮忙。</p>
<ul>
<li>你需要将这些数分成若干组，满足 n 个数中的每一个数都恰好被分到了一个组中，且每一组至少包含一个数。</li>
</ul>
<p>定义一组数的权值为该组内所有数的<strong>异或和</strong>。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        sum^=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu6.1 位运算</title>
    <url>/luogu6-1/</url>
    <content><![CDATA[<p>异或是不进位的加法</p>
<p>当a第i位为0，b第i位为0时，第i位在加/异或下的答案：0+0=0 0^0=0</p>
<p>当a第i位为0，b第i位为1时，第i位在加/异或下的答案：0+1=1 0^1=1</p>
<p>当a第i位为1，b第i位为0时，第i位在加/异或下的答案：1+0=1 1^0=1</p>
<p>当a第i位为1，b第i位为1时，第i位在加/异或下的答案：1+1=2 1^1=0</p>
<p>可以发现，前3种不管是加还是异或答案都相同，只有在第四种情况下，异或的答案小于加的答案</p>
<p>所以得出 a^b&lt;=a+b的结论</p>
]]></content>
  </entry>
  <entry>
    <title>Part 7.1 链表题解</title>
    <url>/luogu7-1-problems/</url>
    <content><![CDATA[<h1 id="Part-7-1-链表题解"><a href="#Part-7-1-链表题解" class="headerlink" title="Part 7.1 链表题解"></a>Part 7.1 链表题解</h1><h2 id="P1996-约瑟夫问题"><a href="#P1996-约瑟夫问题" class="headerlink" title="P1996 约瑟夫问题"></a>P1996 约瑟夫问题</h2><h3 id="题目链接：约瑟夫问题-洛谷"><a href="#题目链接：约瑟夫问题-洛谷" class="headerlink" title="题目链接：约瑟夫问题 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1996">约瑟夫问题 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>n 个人围成一圈，从第一个人开始报数,数到 m 的人出列，再由下一个人重新从 1 开始报数，数到 m 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>模拟链表删除即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,nxt[<span class="number">105</span>],before[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;nxt[i]=i+<span class="number">1</span>;before[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">    nxt[n]=<span class="number">1</span>;before[<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cnt=<span class="number">0</span>;n;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">            nxt[before[i]]=nxt[i];</span><br><span class="line">            before[nxt[i]]=before[i];</span><br><span class="line">            n--;cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1160-队列安排"><a href="#P1160-队列安排" class="headerlink" title="P1160 队列安排"></a>P1160 队列安排</h2><h3 id="题目链接：队列安排-洛谷"><a href="#题目链接：队列安排-洛谷" class="headerlink" title="题目链接：队列安排 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1160">队列安排 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：</p>
<ol>
<li><p>先将 $1$ 号同学安排进队列，这时队列中只有他一个人；</p>
</li>
<li><p>$2-N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；</p>
</li>
<li><p>从队列中去掉 $M(M&lt;N)$ 个同学，其他同学位置顺序不变。</p>
</li>
</ol>
<p>在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>模拟链表插入即可</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,beg=<span class="number">1</span>,nxt[<span class="number">100005</span>],before[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,t,dir;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;dir);</span><br><span class="line">        <span class="keyword">if</span>(t==beg&amp;&amp;dir==<span class="number">0</span>) beg=i;</span><br><span class="line">        <span class="keyword">if</span>(dir)</span><br><span class="line">        &#123;</span><br><span class="line">            before[nxt[t]]=i;</span><br><span class="line">            nxt[i]=nxt[t];</span><br><span class="line">            before[i]=t;</span><br><span class="line">            nxt[t]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nxt[before[t]]=i;</span><br><span class="line">            before[i]=before[t];</span><br><span class="line">            before[t]=i;</span><br><span class="line">            nxt[i]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t;i&lt;m;i++)</span><br><span class="line">        &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);st[t]=<span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=beg;i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.1 链表</title>
    <url>/luogu7-1/</url>
    <content><![CDATA[<h1 id="Part-7-1-链表"><a href="#Part-7-1-链表" class="headerlink" title="Part 7.1 链表"></a>Part 7.1 链表</h1><p>数组模拟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val[N],next[N],before[N];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu7.10</title>
    <url>/luogu7-10/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.10-problems</title>
    <url>/luogu7-10-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.11-problems</title>
    <url>/luogu7-11-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.12-problems</title>
    <url>/luogu7-12-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.11</title>
    <url>/luogu7-11/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.12</title>
    <url>/luogu7-12/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.13</title>
    <url>/luogu7-13/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.13-problems</title>
    <url>/luogu7-13-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.14-problems</title>
    <url>/luogu7-14-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.14</title>
    <url>/luogu7-14/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Part 7.2 栈</title>
    <url>/luogu7-2/</url>
    <content><![CDATA[<h1 id="Part-7-2-栈"><a href="#Part-7-2-栈" class="headerlink" title="Part 7.2 栈"></a>Part 7.2 栈</h1><p>stack</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>运用栈的知识，在一个栈内维护数据的单调性进而求解元素的左右大小边界问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p[i]=<span class="number">0</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[s.<span class="built_in">top</span>()]&lt;=a[i]) &#123;s.<span class="built_in">pop</span>();<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">break</span>;&#125;<span class="comment">//保证数据单调性</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=<span class="number">0</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.2 栈题解</title>
    <url>/luogu7-2-problems/</url>
    <content><![CDATA[<h1 id="Part-7-2-栈题解"><a href="#Part-7-2-栈题解" class="headerlink" title="Part 7.2 栈题解"></a>Part 7.2 栈题解</h1><h2 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a>P1449 后缀表达式</h2><h3 id="题目链接：后缀表达式-洛谷"><a href="#题目链接：后缀表达式-洛谷" class="headerlink" title="题目链接：后缀表达式 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1449">后缀表达式 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。如：3*(5-2)+7 对应的后缀表达式为：3.5.2.-*7.+@。在该式中，<code>@</code> 为表达式的结束符号。<code>.</code> 为操作数的结束符号。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,cur=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) cur=cur*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>) &#123;st.<span class="built_in">push</span>(cur);cur=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            a=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            b=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(b-a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            a=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            b=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(b+a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            a=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            b=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(b*a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            a=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            b=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(b/a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;@&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1981-表达式求值"><a href="#P1981-表达式求值" class="headerlink" title="P1981 表达式求值"></a>P1981 表达式求值</h2><h3 id="题目链接：-NOIP2013-普及组-表达式求值-洛谷"><a href="#题目链接：-NOIP2013-普及组-表达式求值-洛谷" class="headerlink" title="题目链接：[NOIP2013 普及组] 表达式求值 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1981">[NOIP2013 普及组] 表达式求值 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>一行，为需要你计算的表达式，表达式中只包含数字、加法运算符 “+” 和乘法运算符 “×”，且没有括号，所有参与运算的数字均为 0 到 231−1 之间的整数。</p>
<p>输入数据保证这一行只有 0−9、+、× 这 12种字符。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">stack &lt;<span class="type">int</span>&gt; x;<span class="comment">//一个存数字并在最后把它们相加的栈</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;a;<span class="comment">//先输入一个数，以后符号+数字输入</span></span><br><span class="line">    <span class="type">int</span> m=<span class="number">10000</span>;</span><br><span class="line">    a=a%m;<span class="comment">//必须的操作</span></span><br><span class="line">    x.<span class="built_in">push</span>(a);<span class="comment">//压入栈中</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;c&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)<span class="comment">//将*之前的数字与*之后的数字积存入</span></span><br><span class="line">        &#123;</span><br><span class="line">            a=x.<span class="built_in">top</span>();</span><br><span class="line">            x.<span class="built_in">pop</span>();</span><br><span class="line">            x.<span class="built_in">push</span>(a*b%m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//将b存入</span></span><br><span class="line">            x.<span class="built_in">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        a+=x.<span class="built_in">top</span>();</span><br><span class="line">        a%=m;</span><br><span class="line">        x.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.3 队列</title>
    <url>/luogu7-3/</url>
    <content><![CDATA[<h1 id="Part-7-3-队列"><a href="#Part-7-3-队列" class="headerlink" title="Part 7.3 队列"></a>Part 7.3 队列</h1><p>queue</p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.3 队列题解</title>
    <url>/luogu7-3-problems/</url>
    <content><![CDATA[<h1 id="Part-7-3-队列题解"><a href="#Part-7-3-队列题解" class="headerlink" title="Part 7.3 队列题解"></a>Part 7.3 队列题解</h1><h2 id="P1540-机器翻译"><a href="#P1540-机器翻译" class="headerlink" title="P1540 机器翻译"></a>P1540 机器翻译</h2><h3 id="题目链接：-NOIP2010-提高组-机器翻译-洛谷"><a href="#题目链接：-NOIP2010-提高组-机器翻译-洛谷" class="headerlink" title="题目链接：[NOIP2010 提高组] 机器翻译 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1540">[NOIP2010 提高组] 机器翻译 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入 M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p>
<p>假设一篇英语文章的长度为 N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m,n,cnt,siz;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(st[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz&lt;m) &#123;q.<span class="built_in">push</span>(x);siz++;st[x]=<span class="literal">true</span>;cnt++;&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[q.<span class="built_in">front</span>()]=<span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            st[x]=<span class="literal">true</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.4 并查集题解</title>
    <url>/luogu7-4-problems/</url>
    <content><![CDATA[<h1 id="Part-7-4-并查集题解"><a href="#Part-7-4-并查集题解" class="headerlink" title="Part 7.4 并查集题解"></a>Part 7.4 并查集题解</h1><h2 id="P1111-修复公路"><a href="#P1111-修复公路" class="headerlink" title="P1111 修复公路"></a>P1111 修复公路</h2><h3 id="题目链接：修复公路-洛谷"><a href="#题目链接：修复公路-洛谷" class="headerlink" title="题目链接：修复公路 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1111">修复公路 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>给出A地区的村庄数N，和公路数M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p[<span class="number">100005</span>],siz[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,date;</span><br><span class="line">&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.date&lt;e2.date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].date);</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(e[i].u),pb=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">        p[pa]=pb;</span><br><span class="line">        siz[pb]+=siz[pa];</span><br><span class="line">        <span class="keyword">if</span>(siz[pb]==n) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e[i].date);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3958-奶酪"><a href="#P3958-奶酪" class="headerlink" title="P3958 奶酪"></a>P3958 奶酪</h2><h3 id="题目链接：-NOIP2017-提高组-奶酪-洛谷"><a href="#题目链接：-NOIP2017-提高组-奶酪-洛谷" class="headerlink" title="题目链接：[NOIP2017 提高组] 奶酪 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3958">[NOIP2017 提高组] 奶酪 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。</p>
<p>现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。</p>
<p>位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?</p>
<p>空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：</p>
<p>$$<br>\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}<br>$$</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll h,r;</span><br><span class="line"><span class="type">int</span> n,p[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;e[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; down,up;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>,&amp;n,&amp;h,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].z);</span><br><span class="line">            p[i]=i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(e[i].z)&lt;=r) down.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(e[i].z-h)&lt;=r) up.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(j);</span><br><span class="line">                <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">                ll x1=e[i].x,x2=e[j].x,y1=e[i].y,y2=e[j].y,z1=e[i].z,z2=e[j].z;</span><br><span class="line">                <span class="keyword">if</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)&lt;=<span class="number">4</span>*r*r)   </span><br><span class="line">                    p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;up.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;down.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pa=<span class="built_in">find</span>(up[i]),pb=<span class="built_in">find</span>(down[j]);</span><br><span class="line">                <span class="keyword">if</span>(pa==pb) &#123;ok=<span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        up.<span class="built_in">clear</span>();down.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4185-MooTube-G"><a href="#P4185-MooTube-G" class="headerlink" title="P4185 MooTube G"></a>P4185 MooTube G</h2><h3 id="题目链接：P4185-MooTube-G"><a href="#题目链接：P4185-MooTube-G" class="headerlink" title="题目链接：P4185 MooTube G"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4185">P4185 MooTube G</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>在业余时间，Farmer John 创建了一个新的视频共享服务，他将其命名为 MooTube。在 MooTube 上，Farmer John 的奶牛可以录制，分享和发现许多有趣的视频。他的奶牛已经发布了 N 个视频（1≤N≤105），为了方便将其编号为 1…N 。然而，FJ 无法弄清楚如何帮助他的奶牛找到他们可能喜欢的新视频。</p>
<p>FJ 希望为每个 MooTube 视频创建一个“推荐视频”列表。这样，奶牛将被推荐与他们已经观看过的视频最相关的视频。</p>
<p>FJ 设计了一个“相关性”度量标准，顾名思义，它确定了两个视频相互之间的相关性。他选择 N−1 对视频并手动计算其之间的相关性。然后，FJ 将他的视频建成一棵树，其中每个视频是节点，并且他手动将 N−1 对视频连接。为了方便，FJ 选择了 N−1 对，这样任意视频都可以通过一条连通路径到达任意其他视频。 FJ 决定将任意一对视频的相关性定义为沿此路径的任何连接的最小相关性。</p>
<p>Farmer John 想要选择一个 K 值，以便在任何给定的 MooTube 视频旁边，推荐所有其他与该视频至少有 K 相关的视频。然而，FJ 担心会向他的奶牛推荐太多的视频，这可能会分散他们对产奶的注意力！因此，他想设定适当的 K 值。 Farmer John希望得到您的帮助，回答有关 K 值的推荐视频的一些问题。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>离线处理查询，将关系排序，按照查询方式，从大到小合并即可</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,q,ans[<span class="number">100005</span>],p[<span class="number">100005</span>],siz[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,k;</span><br><span class="line">&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.k&gt;e2.k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,k,idx;</span><br><span class="line">&#125;ask[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(nod e1,nod e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.k&gt;e2.k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ask[i].k,&amp;ask[i].u),ask[i].idx=i;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+n,cmp1);<span class="built_in">sort</span>(ask+<span class="number">1</span>,ask+<span class="number">1</span>+q,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,cur=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mi=ask[i].k;</span><br><span class="line">        <span class="keyword">for</span>(;cur&lt;n;cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[cur].k&lt;mi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(e[cur].u),pb=<span class="built_in">find</span>(e[cur].v);</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">            p[pa]=pb;siz[pb]+=siz[pa];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].idx]=siz[<span class="built_in">find</span>(ask[i].u)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2024-食物链"><a href="#P2024-食物链" class="headerlink" title="P2024 食物链"></a>P2024 食物链</h2><h3 id="题目链接：-NOI2001-食物链-洛谷"><a href="#题目链接：-NOI2001-食物链-洛谷" class="headerlink" title="题目链接：[NOI2001] 食物链 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2024">[NOI2001] 食物链 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。</p>
<p>现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。</p>
<p>有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：</p>
<ul>
<li>第一种说法是 <code>1 X Y</code>，表示 $X$ 和 $Y$ 是同类。</li>
<li>第二种说法是 <code>2 X Y</code>，表示 $X$ 吃 $Y$。</li>
</ul>
<p>此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p>
<ul>
<li>当前的话与前面的某些真的话冲突，就是假话；</li>
<li>当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；</li>
<li>当前的话表示 $X$ 吃 $X$，就是假话。</li>
</ul>
<p>你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>对于具有传递性的关系，可以采取维护距离的方式记录种类</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,ans,p[<span class="number">100005</span>],d[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        p[x]=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;n||y&gt;n||(x==y&amp;&amp;op==<span class="number">2</span>)) ans++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(x),pb=<span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb&amp;&amp;d[x]-d[y]) ans++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[pa]=pb;</span><br><span class="line">                    d[pa]=(-d[x]+d[y]+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb&amp;&amp;(d[x]-d[y]+<span class="number">3</span>)%<span class="number">3</span>!=<span class="number">2</span>) ans++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[pa]=pb;</span><br><span class="line">                    d[pa]=(-d[x]+<span class="number">2</span>+d[y]+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1197-星球大战"><a href="#P1197-星球大战" class="headerlink" title="P1197 星球大战"></a>P1197 星球大战</h2><h3 id="题目链接：-JSOI2008-星球大战-洛谷"><a href="#题目链接：-JSOI2008-星球大战-洛谷" class="headerlink" title="题目链接：[JSOI2008] 星球大战 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1197">[JSOI2008] 星球大战 - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。</p>
<p>现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>思路与本篇中 P4185 有类似的处理方式，即删边难处理，可以逆序采用建边的方式解决问题</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,k,p[<span class="number">400005</span>],broken[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">400005</span>],e[<span class="number">400005</span>],ne[<span class="number">400005</span>],idx=<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,u,v;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="type">int</span> cnt=n-k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        broken[i]=x;</span><br><span class="line">        st[x]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=e[i],v=e[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(st[u]||st[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(u),pb=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">        p[pa]=pb;cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    broken[k+<span class="number">1</span>]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=broken[i];</span><br><span class="line">        st[u]=<span class="literal">false</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=h[u];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[j];</span><br><span class="line">            <span class="keyword">if</span>(st[u]||st[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(u),pb=<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">            p[pa]=pb;cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        broken[i]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,broken[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1196-银河英雄传说"><a href="#P1196-银河英雄传说" class="headerlink" title="P1196 银河英雄传说"></a>P1196 银河英雄传说</h2><h3 id="题目链接：-NOI2002-银河英雄传说-洛谷"><a href="#题目链接：-NOI2002-银河英雄传说-洛谷" class="headerlink" title="题目链接：[NOI2002] 银河英雄传说 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1196">[NOI2002] 银河英雄传说 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 <code>M i j</code>，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  </p>
<p>然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。</p>
<p>在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：<code>C i j</code>。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p>
<p>作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> p[<span class="number">30005</span>],d[<span class="number">30005</span>],siz[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x]=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30001</span>;i++) p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;i,&amp;j);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(j);</span><br><span class="line">            p[pa]=pb;</span><br><span class="line">            d[pa]=siz[pb];</span><br><span class="line">            siz[pb]+=siz[pa];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(i),pb=<span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(pa!=pb) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">abs</span>(d[i]-d[j])<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1955-程序自动分析"><a href="#P1955-程序自动分析" class="headerlink" title="P1955 程序自动分析"></a>P1955 程序自动分析</h2><h3 id="题目链接：-NOI2015-程序自动分析-洛谷"><a href="#题目链接：-NOI2015-程序自动分析-洛谷" class="headerlink" title="题目链接：[NOI2015] 程序自动分析 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1955">[NOI2015] 程序自动分析 - 洛谷</a></h3><h3 id="题面：-6"><a href="#题面：-6" class="headerlink" title="题面："></a>题面：</h3><p>考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如 $x_i=x_j$ 或 $x_i\neq x_j$ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p>
<p>现在给出一些约束满足问题，请分别对它们进行判定。</p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>相等具有传递性，而不等关系则不具有，故先将所有相等关系处理，然后再查询不等关系</p>
<h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,op;</span><br><span class="line">&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.op&gt;e2.op;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].op);</span><br><span class="line">            p[e[i].x]=e[i].x;p[e[i].y]=e[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(e[i].x),pb=<span class="built_in">find</span>(e[i].y);</span><br><span class="line">            <span class="keyword">if</span>(e[i].op)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb)</span><br><span class="line">                &#123;</span><br><span class="line">                    ok=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.4 并查集</title>
    <url>/luogu7-4/</url>
    <content><![CDATA[<h1 id="Part-7-4-并查集"><a href="#Part-7-4-并查集" class="headerlink" title="Part 7.4 并查集"></a>Part 7.4 并查集</h1><p>并查集是一种树型的数据结构,用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示。 并查集也被称为不相交集数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//压缩路径查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>维护结点到父节点的关系值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//更新到父节点的权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x]=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.5 堆题解</title>
    <url>/luogu7-5-problems/</url>
    <content><![CDATA[<h1 id="Part-7-5-堆题解"><a href="#Part-7-5-堆题解" class="headerlink" title="Part 7.5 堆题解"></a>Part 7.5 堆题解</h1><h2 id="P3378-堆"><a href="#P3378-堆" class="headerlink" title="P3378 堆"></a>P3378 堆</h2><h3 id="题目链接：【模板】堆-洛谷"><a href="#题目链接：【模板】堆-洛谷" class="headerlink" title="题目链接：【模板】堆 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3378">【模板】堆 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>给定一个数列，初始为空，请支持下面三种操作：</p>
<ol>
<li>给定一个整数 x，请将 x 加入到数列中。</li>
<li>输出数列中最小的数。</li>
<li>删除数列中最小的数（如果有多个数最小，只删除 1 个）。</li>
</ol>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,op;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;<span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1168-中位数"><a href="#P1168-中位数" class="headerlink" title="P1168 中位数"></a>P1168 中位数</h2><h3 id="题目链接：中位数-洛谷"><a href="#题目链接：中位数-洛谷" class="headerlink" title="题目链接：中位数 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1168">中位数 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>给出一个长度为$N$的非负整数序列$A_i$，对于所有$1 ≤ k ≤ (N + 1) / 2$，输出$A_1, A_1 \sim A_3, …,A_1 \sim A_{2k - 1}$的中位数。即前$1,3,5,…$个数的中位数。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; sml;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; big;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,mid;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;mid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;mid) sml.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span> big.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sml.<span class="built_in">size</span>()!=big.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">if</span>(big.<span class="built_in">size</span>()&gt;sml.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    sml.<span class="built_in">push</span>(mid);</span><br><span class="line">                    mid=big.<span class="built_in">top</span>();</span><br><span class="line">                    big.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    big.<span class="built_in">push</span>(mid);</span><br><span class="line">                    mid=sml.<span class="built_in">top</span>();</span><br><span class="line">                    sml.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1090-合并果子"><a href="#P1090-合并果子" class="headerlink" title="P1090 合并果子"></a>P1090 合并果子</h2><h3 id="题目链接：-NOIP2004-提高组-合并果子-USACO06NOV-Fence-Repair-G-洛谷"><a href="#题目链接：-NOIP2004-提高组-合并果子-USACO06NOV-Fence-Repair-G-洛谷" class="headerlink" title="题目链接：[NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1090">[NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
<p>例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll cnt;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; sml;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        sml.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sml.<span class="built_in">size</span>()!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t1,t2,t3;</span><br><span class="line">        t1=sml.<span class="built_in">top</span>();sml.<span class="built_in">pop</span>();</span><br><span class="line">        t2=sml.<span class="built_in">top</span>();sml.<span class="built_in">pop</span>();</span><br><span class="line">        t3=t1+t2;sml.<span class="built_in">push</span>(t3);</span><br><span class="line">        cnt+=t3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.5 堆</title>
    <url>/luogu7-5/</url>
    <content><![CDATA[<h1 id="Part-7-5-堆"><a href="#Part-7-5-堆" class="headerlink" title="Part 7.5 堆"></a>Part 7.5 堆</h1><p>priority_queue  </p>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.6 ST表题解</title>
    <url>/luogu7-6-problems/</url>
    <content><![CDATA[<h1 id="Part-7-6-ST表题解"><a href="#Part-7-6-ST表题解" class="headerlink" title="Part 7.6 ST表题解"></a>Part 7.6 ST表题解</h1><h2 id="P3865-【模板】ST-表"><a href="#P3865-【模板】ST-表" class="headerlink" title="P3865 【模板】ST 表"></a>P3865 【模板】ST 表</h2><h3 id="题面链接：【模板】ST-表-洛谷"><a href="#题面链接：【模板】ST-表-洛谷" class="headerlink" title="题面链接：【模板】ST 表 - 洛谷"></a>题面链接：<a href="https://www.luogu.com.cn/problem/P3865">【模板】ST 表 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间内数字的最大值。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>倍增的思想，动态规划的做法，ST表/RMQ 的模板题，</p>
<p>$dp[i][j]$ 表示左端点为 $i$ 长度为 $2^j$ 的区间内记录的最大值（最小值、GCD 、… ）</p>
<p>$O(nlogn)$ 的预处理 ，$O(1)$ 的查询</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,w[<span class="number">2000005</span>],dp[<span class="number">2000005</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">22</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!j) dp[i][j]=w[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,len,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        len=r-l+<span class="number">1</span>;</span><br><span class="line">        k=<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[l][k],dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2251-质量检测"><a href="#P2251-质量检测" class="headerlink" title="P2251 质量检测"></a>P2251 质量检测</h2><h3 id="题目链接：质量检测-洛谷"><a href="#题目链接：质量检测-洛谷" class="headerlink" title="题目链接：质量检测 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2251">质量检测 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min{A_1, A_2, … A_m}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $… 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。请你尽快求出 $Q$ 序列。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>关于最小值的 RMQ 问题</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,w[<span class="number">1000005</span>],dp[<span class="number">1000005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">21</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!j) dp[i][j]=w[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+m<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">log</span>(m)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(dp[i][k],dp[i+m-(<span class="number">1</span>&lt;&lt;k)][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1816-忠诚"><a href="#P1816-忠诚" class="headerlink" title="P1816 忠诚"></a>P1816 忠诚</h2><h3 id="题目链接：忠诚-洛谷"><a href="#题目链接：忠诚-洛谷" class="headerlink" title="题目链接：忠诚 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1816">忠诚 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>财主把每次的账目按 1,2,3… 编号，然后不定时的问管家问题，问题是这样的：在 a 到 b 号账中最少的一笔是多少？为了让管家没时间作假，他总是一次问多个问题。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>区间最小值问题</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,w[<span class="number">100005</span>],dp[<span class="number">100005</span>][<span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">18</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!j) dp[i][j]=w[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,len,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        len=r-l+<span class="number">1</span>;</span><br><span class="line">        k=<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">min</span>(dp[l][k],dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1198-JSOI2008-最大数"><a href="#P1198-JSOI2008-最大数" class="headerlink" title="P1198 [JSOI2008] 最大数"></a>P1198 [JSOI2008] 最大数</h2><h3 id="题目链接：-JSOI2008-最大数-洛谷"><a href="#题目链接：-JSOI2008-最大数-洛谷" class="headerlink" title="题目链接：[JSOI2008] 最大数 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1198">[JSOI2008] 最大数 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>现在请求你维护一个数列，要求提供以下两种操作：</p>
<p>1、 查询操作。</p>
<p>语法：<code>Q L</code></p>
<p>功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。</p>
<p>限制：L不超过当前数列的长度。(L&gt;0)</p>
<p>2、 插入操作。</p>
<p>语法：<code>A n</code></p>
<p>功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。</p>
<p>限制：n是整数（可能为负数）并且在长整范围内。</p>
<p>注意：初始时数列是空的，没有一个数。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[<span class="number">200001</span>],f[<span class="number">200001</span>][<span class="number">21</span>],t,D;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//用change函数来进行修改</span></span><br><span class="line">    f[u][<span class="number">0</span>]=a[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;u-(<span class="number">1</span>&lt;&lt;i)&gt;=<span class="number">0</span>;i++) f[u][i]=<span class="built_in">max</span>(f[u][i<span class="number">-1</span>],f[u-(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> t=<span class="built_in">log</span>(y-x+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> K=t;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[y][K],f[x+(<span class="number">1</span>&lt;&lt;K)<span class="number">-1</span>][K]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;m,&amp;D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;  <span class="comment">//根据题面的操作，注意细节。</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            a[++n]=(x+t)%D;</span><br><span class="line">            <span class="built_in">change</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> L; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;L);</span><br><span class="line">            ll ans;</span><br><span class="line">            <span class="keyword">if</span> (L==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[n]);</span><br><span class="line">                t=a[n]; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">find</span>(n-L+<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans); t=ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2880-USACO07JAN-Balanced-Lineup-G"><a href="#P2880-USACO07JAN-Balanced-Lineup-G" class="headerlink" title="P2880 [USACO07JAN] Balanced Lineup G"></a>P2880 [USACO07JAN] Balanced Lineup G</h2><h3 id="题目链接：-USACO07JAN-Balanced-Lineup-G-洛谷"><a href="#题目链接：-USACO07JAN-Balanced-Lineup-G-洛谷" class="headerlink" title="题目链接：[USACO07JAN] Balanced Lineup G - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P2880">[USACO07JAN] Balanced Lineup G - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>第一行两个数 $n,q$ 。接下来 n 行，每行一个数 $h_i$​ 。</p>
<p>再接下来 q 行，每行两个整数 a 和 b，表示询问第 a 头牛到第 b 头牛里的最高和最低的牛的身高差。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>同 P1816 和 P3865</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,w[<span class="number">50005</span>],dpa[<span class="number">50005</span>][<span class="number">17</span>],dpi[<span class="number">50005</span>][<span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">17</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!j) &#123;dpi[i][j]=w[i];dpa[i][j]=w[i];&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                dpa[i][j]=<span class="built_in">max</span>(dpa[i][j<span class="number">-1</span>],dpa[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">                dpi[i][j]=<span class="built_in">min</span>(dpi[i][j<span class="number">-1</span>],dpi[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,len,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        len=r-l+<span class="number">1</span>;</span><br><span class="line">        k=<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dpa[l][k],dpa[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])-<span class="built_in">min</span>(dpi[l][k],dpi[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.6 ST表</title>
    <url>/luogu7-6/</url>
    <content><![CDATA[<h1 id="Part-7-6-ST表"><a href="#Part-7-6-ST表" class="headerlink" title="Part 7.6 ST表"></a>Part 7.6 ST表</h1><p>$dp[i][j]$ 表示左端点为 $i$ 长度为 $2^j$ 的区间内记录的最大值（最小值、GCD 、… ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!j) dp[i][j]=w[i];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.7 树状数组题解</title>
    <url>/luogu7-7-problems/</url>
    <content><![CDATA[<h1 id="Part-7-7-树状数组题解"><a href="#Part-7-7-树状数组题解" class="headerlink" title="Part 7.7 树状数组题解"></a>Part 7.7 树状数组题解</h1><h2 id="P3374-【模板】树状数组-1"><a href="#P3374-【模板】树状数组-1" class="headerlink" title="P3374 【模板】树状数组 1"></a>P3374 【模板】树状数组 1</h2><h3 id="题目链接：【模板】树状数组-1-洛谷"><a href="#题目链接：【模板】树状数组-1-洛谷" class="headerlink" title="题目链接：【模板】树状数组 1 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3374">【模板】树状数组 1 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ul>
<li><p>将某一个数加上 x</p>
</li>
<li><p>求出某区间每一个数的和</p>
</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>树状数组模板题，单点修改，区间查询</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="type">int</span> n,m,tree[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">add</span>(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(y)-<span class="built_in">ask</span>(x<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3368【模板】树状数组-2"><a href="#P3368【模板】树状数组-2" class="headerlink" title="P3368【模板】树状数组 2"></a>P3368【模板】树状数组 2</h2><h3 id="题目链接：【模板】树状数组-2-洛谷"><a href="#题目链接：【模板】树状数组-2-洛谷" class="headerlink" title="题目链接：【模板】树状数组 2 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3368">【模板】树状数组 2 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li><p>将某区间每一个数加上 $x$；</p>
</li>
<li><p>求出某一个数的值。</p>
</li>
</ol>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>树状数组模板题，区间修改，单点查询</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="type">int</span> n,m,tree[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">add</span>(i,x-last);</span><br><span class="line">        last=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> x,y,k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">            <span class="built_in">add</span>(x,k);</span><br><span class="line">            <span class="built_in">add</span>(y+<span class="number">1</span>,-k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1908-逆序对"><a href="#P1908-逆序对" class="headerlink" title="P1908 逆序对"></a>P1908 逆序对</h2><h3 id="题目链接：逆序对-洛谷"><a href="#题目链接：逆序对-洛谷" class="headerlink" title="题目链接：逆序对 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1908">逆序对 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>对于给定的一段正整数序列，逆序对就是序列中 $a_i​&gt;a_j$​ 且 $i&lt;j$ 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>离散化一下，按价值从大到小排序，排完序之后用树状数组维护，每次把这个数的位置加入到树状数组中，因为是排完序之后，所以之前加入的一定比后加入的大，然后在查询当前这个数前面位置的数，即逆序对的个数</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="type">int</span> n,tree[<span class="number">500005</span>],ranks[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,idx;</span><br><span class="line">&#125;a[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e1.val == e2.val)</span><br><span class="line">        <span class="keyword">return</span> e1.idx &lt; e2.idx;</span><br><span class="line">    <span class="keyword">return</span> e1.val&lt;e2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].val),a[i].idx=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ranks[a[i].idx]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(ranks[i],<span class="number">1</span>);</span><br><span class="line">        ans+=i-<span class="built_in">ask</span>(ranks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="P1966-NOIP2013-提高组-火柴排队"><a href="#P1966-NOIP2013-提高组-火柴排队" class="headerlink" title="P1966 [NOIP2013 提高组] 火柴排队"></a>P1966 [NOIP2013 提高组] 火柴排队</h2><h3 id="题目链接：-NOIP2013-提高组-火柴排队-洛谷"><a href="#题目链接：-NOIP2013-提高组-火柴排队-洛谷" class="headerlink" title="题目链接：[NOIP2013 提高组] 火柴排队 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1966">[NOIP2013 提高组] 火柴排队 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>有两盒火柴，每盒装有 $n$ 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：$ \sum (a_i-b_i)^2$</p>
<p>其中 $a_i$ 表示第一列火柴中第 $i$ 个火柴的高度，$b_i$ 表示第二列火柴中第  $i$ 个火柴的高度。</p>
<p>每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 $10^8-3$ 取模的结果。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>本质是求逆序对，是 a 和 b 的相对顺序进行求解</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">99999997</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="type">int</span> n,tree[<span class="number">500005</span>],ranks[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,idx;</span><br><span class="line">&#125;a[<span class="number">500005</span>],b[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e1.val == e2.val)</span><br><span class="line">        <span class="keyword">return</span> e1.idx &lt; e2.idx;</span><br><span class="line">    <span class="keyword">return</span> e1.val&lt;e2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) &#123;tree[i]+=k;tree[i]%=mod;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) &#123;res+=tree[i];res%=mod;&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].val),a[i].idx=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i].val),b[i].idx=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ranks[a[i].idx]=b[i].idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(ranks[i],<span class="number">1</span>);</span><br><span class="line">        ans+=i-<span class="built_in">ask</span>(ranks[i]);</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="P3605-Promotion-Counting-P"><a href="#P3605-Promotion-Counting-P" class="headerlink" title="P3605 Promotion Counting P"></a>P3605 Promotion Counting P</h2><h3 id="题目链接：-USACO17JAN-Promotion-Counting-P-洛谷"><a href="#题目链接：-USACO17JAN-Promotion-Counting-P-洛谷" class="headerlink" title="题目链接：[USACO17JAN]Promotion Counting P - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3605">[USACO17JAN]Promotion Counting P - 洛谷</a></h3><h3 id="题面：-4"><a href="#题面：-4" class="headerlink" title="题面："></a>题面：</h3><p>为了方便，把奶牛从 $1∼n$ 编号，把公司组织成一棵树，$1$ 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。</p>
<p>所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$​，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们我们把奶牛 $j$ 叫做 $i$ 的下属。</p>
<p>不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j​&gt;p_i$ ​。</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>节点 $u$ 的答案 $ans[u]$ = 遍历 $u$ 的子树后比 $val[u]$ 大的数量 - 遍历 $u$ 的子树前比 $val[u]$ 大的</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">99999997</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,INF=<span class="number">1e9</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; h[N],num;</span><br><span class="line"><span class="type">int</span> a[N],tr[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span>               <span class="comment">//树状数组模板</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x&amp;-x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;N;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span>                         <span class="comment">//dfs树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[u]=-(<span class="built_in">sum</span>(num.<span class="built_in">size</span>())-<span class="built_in">sum</span>(a[u]));    <span class="comment">//向ans[u]中加入之前就比u强的节点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:h[u]) <span class="built_in">dfs</span>(v);                 <span class="comment">//遍历u子树</span></span><br><span class="line">    ans[u]+=<span class="built_in">sum</span>(num.<span class="built_in">size</span>())-<span class="built_in">sum</span>(a[u]);      <span class="comment">//向ans[u]中加入遍历u子树后比u要强的节点个数</span></span><br><span class="line">    <span class="built_in">add</span>(a[u],<span class="number">1</span>);        <span class="comment">//这样ans[u]中记录的就是u子树中比u强的节点数了，最后再将a[u]加入树状数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],num.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)           <span class="comment">//建树（有向图即可）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        h[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());                    <span class="comment">//节点权值比较大，因此要离散化</span></span><br><span class="line">    num.<span class="built_in">erase</span>(<span class="built_in">unique</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>()),num.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>(),a[i])-num.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;       <span class="comment">//输出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1972-HH的项链"><a href="#P1972-HH的项链" class="headerlink" title="P1972 HH的项链"></a>P1972 HH的项链</h2><h3 id="题目链接：-SDOI2009-HH的项链-洛谷"><a href="#题目链接：-SDOI2009-HH的项链-洛谷" class="headerlink" title="题目链接：[SDOI2009] HH的项链 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P1972">[SDOI2009] HH的项链 - 洛谷</a></h3><h3 id="题面：-5"><a href="#题面：-5" class="headerlink" title="题面："></a>题面：</h3><p>HH 有一串由各种漂亮的贝壳组成的项链。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>离线处理区间</p>
<p><code>mp[i]</code>表示第<code>i</code>种贝壳在目前询问到的区间中<strong>最后</strong>出现的位置（也就是最右端）。变量<code>cur</code>指向的位置是<strong>尚未修改</strong>的区间的<strong>左端点</strong>，也就是<strong>已经修改</strong>区间<strong>右端点</strong>的后一个位置，方便定位未修改的区间。由于我们已经对询问的区间按右端点排好序，所以<code>cur</code>的值在不同时刻单调递增，直至末尾。</p>
<p>有了以上的信息之后就我们可以对区间进行修改了，主要维护两个操作：</p>
<ol>
<li>如果某元素<code>i</code>在之前已经出现过，那么将其<strong>以前最右端位置</strong>的前缀和−1，相当于忽略之前的位置。再在现在<code>i</code>的位置把前缀和+1，并更新<code>mp[i]</code>到当前位置。</li>
<li>如果某元素<code>i</code>在之前没有出现，那么直接修改当前位置前缀和即可，并更新<code>mp[i]</code>。</li>
</ol>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">99999997</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,idx;</span><br><span class="line">&#125;q[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node e1,node e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.r&lt;e2.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">1000005</span>],tree[<span class="number">1000005</span>],mp[<span class="number">1000005</span>],ans[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].idx=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=cur;j&lt;=q[i].r;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[a[j]]) <span class="built_in">add</span>(mp[a[j]],<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">            mp[a[j]]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=q[i].r+<span class="number">1</span>;</span><br><span class="line">        ans[q[i].idx]=<span class="built_in">ask</span>(q[i].r)-<span class="built_in">ask</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.7 树状数组</title>
    <url>/luogu7-7/</url>
    <content><![CDATA[<h1 id="Part-7-7-树状数组"><a href="#Part-7-7-树状数组" class="headerlink" title="Part 7.7 树状数组"></a>Part 7.7 树状数组</h1><h2 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tree[N];<span class="comment">//树状数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125; <span class="comment">//lowbit操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//单点修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.8 线段树题解</title>
    <url>/luogu7-8-problems/</url>
    <content><![CDATA[<h1 id="Part-7-8-线段树题解"><a href="#Part-7-8-线段树题解" class="headerlink" title="Part 7.8 线段树题解"></a>Part 7.8 线段树题解</h1><h2 id="P3372-【模板】线段树-1"><a href="#P3372-【模板】线段树-1" class="headerlink" title="P3372 【模板】线段树 1"></a>P3372 【模板】线段树 1</h2><h3 id="题目链接：【模板】线段树-1-洛谷"><a href="#题目链接：【模板】线段树-1-洛谷" class="headerlink" title="题目链接：【模板】线段树 1 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1 - 洛谷</a></h3><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数加上 k 。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,val);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum+=(tr[u].r-tr[u].l+<span class="number">1</span>)*k;</span><br><span class="line">        tr[u].add+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a>P3373 【模板】线段树 2</h2><h3 id="题目链接：【模板】线段树-2-洛谷"><a href="#题目链接：【模板】线段树-2-洛谷" class="headerlink" title="题目链接：【模板】线段树 2 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P3373">【模板】线段树 2 - 洛谷</a></h3><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>如题，已知一个数列，你需要进行下面三种操作：</p>
<ul>
<li><p>将某区间每一个数乘上 x</p>
</li>
<li><p>将某区间每一个数加上 x</p>
</li>
<li><p>求出某区间每一个数的和</p>
</li>
</ul>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,p,a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,mul,add;</span><br><span class="line">&#125;tr[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum*tr[u].mul+tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>))%p;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>].add=(tr[u].mul*tr[u&lt;&lt;<span class="number">1</span>].add+tr[u].add)%p;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>].mul=(tr[u].mul*tr[u&lt;&lt;<span class="number">1</span>].mul)%p;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum*tr[u].mul+tr[u].add*(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>))%p;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add=(tr[u].mul*tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+tr[u].add)%p;</span><br><span class="line">    tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mul=(tr[u].mul*tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mul)%p;</span><br><span class="line">    tr[u].mul=<span class="number">1</span>;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;</span><br><span class="line">    tr[u].mul=<span class="number">1</span>;</span><br><span class="line">    tr[u].add=<span class="number">0</span>;</span><br><span class="line">    tr[u].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=a[r];</span><br><span class="line">        tr[u].add=<span class="number">0</span>;</span><br><span class="line">        tr[u].mul=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,ll mul,ll add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=(tr[u].sum*mul+add*(tr[u].r-tr[u].l+<span class="number">1</span>))%p;</span><br><span class="line">        tr[u].add=(tr[u].add*mul+add)%p;</span><br><span class="line">        tr[u].mul=(tr[u].mul*mul)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r,mul,add);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,mul,add);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) &#123;res+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);res%=p;&#125;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) &#123;res+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);res%=p;&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,l,r,c,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,l,r,<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll ans=<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5490-【模板】扫描线"><a href="#P5490-【模板】扫描线" class="headerlink" title="P5490 【模板】扫描线"></a>P5490 【模板】扫描线</h2><h3 id="题目链接：【模板】扫描线-洛谷"><a href="#题目链接：【模板】扫描线-洛谷" class="headerlink" title="题目链接：【模板】扫描线 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P5490">【模板】扫描线 - 洛谷</a></h3><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>求 n 个四边平行于坐标轴的矩形的面积并。</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    ll x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    ll len;</span><br><span class="line">&#125; tr[N * <span class="number">8</span>];</span><br><span class="line">vector&lt;ll&gt; ys;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    ys.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        ll x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">        seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">    ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4588-TJOI2018-数学计算"><a href="#P4588-TJOI2018-数学计算" class="headerlink" title="P4588 [TJOI2018]数学计算"></a>P4588 [TJOI2018]数学计算</h2><h3 id="题目链接：-TJOI2018-数学计算-洛谷"><a href="#题目链接：-TJOI2018-数学计算-洛谷" class="headerlink" title="题目链接：[TJOI2018]数学计算 - 洛谷"></a>题目链接：<a href="https://www.luogu.com.cn/problem/P4588">[TJOI2018]数学计算 - 洛谷</a></h3><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>小豆现在有一个数 $x$，初始值为 1。小豆有 Q 次操作，操作有两种类型：</p>
<p><code>1 m</code>：将 $x$ 变为 $x×m$，并输出 $x$ $mod$ $M$</p>
<p><code>2 pos</code>：将 $x$ 变为 $x$ 除以第 pos 次操作所乘的数（保证第 pos 次操作一定为类型 1，对于每一个类型 1 的操作至多会被除一次），并输出 $x$ $mod$ $M$。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll mul;</span><br><span class="line">&#125; tr[<span class="number">400020</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].mul = (tr[u &lt;&lt; <span class="number">1</span>].mul * tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mul) % m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l; tr[u].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;tr[u].mul = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> pos, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == pos &amp;&amp; tr[u].r == pos)</span><br><span class="line">        tr[u].mul = val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, pos, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos, val);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, i, x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].mul);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, x, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].mul);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>洛谷题单</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Part 7.8 线段树</title>
    <url>/luogu7-8/</url>
    <content><![CDATA[<h1 id="Part-7-8-线段树"><a href="#Part-7-8-线段树" class="headerlink" title="Part 7.8 线段树"></a>Part 7.8 线段树</h1>]]></content>
      <categories>
        <category>知识点</category>
        <category>竞赛算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>知识点</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu7.9-problems</title>
    <url>/luogu7-9-problems/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>luogu7.9</title>
    <url>/luogu7-9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>kuangbin专题五 并查集</title>
    <url>/kb5/</url>
    <content><![CDATA[<h1 id="kuangbin专题五-并查集"><a href="#kuangbin专题五-并查集" class="headerlink" title="kuangbin专题五 并查集"></a>kuangbin专题五 并查集</h1><h2 id="Wireless-Network"><a href="#Wireless-Network" class="headerlink" title="Wireless Network"></a>Wireless Network</h2><p>考察基本并查集操作，注意复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; cod[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> n, d, p[<span class="number">1005</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;cod[i].x, &amp;cod[i].y); p[i] = i;&#125;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            <span class="keyword">if</span> (st[u]) <span class="keyword">continue</span>;</span><br><span class="line">            st[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (u == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> x1 = cod[u].x, x2 = cod[j].x, y1 = cod[u].y, y2 = cod[j].y;</span><br><span class="line">                <span class="keyword">if</span> ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) &lt;= d * d &amp;&amp; st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> pa = <span class="built_in">find</span>(u), pb = <span class="built_in">find</span>(j);</span><br><span class="line">                    <span class="keyword">if</span> (pa == pb) <span class="keyword">continue</span>;</span><br><span class="line">                    p[pa] = pb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (pa == pb) <span class="built_in">printf</span>(<span class="string">&quot;SUCCESS\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;FAIL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h2><p>变量 $siz[N]$ 维护并查集的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p[<span class="number">30005</span>],siz[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) p[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end,last;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;end);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,x;j&lt;=end;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> pa=<span class="built_in">find</span>(x),pb=<span class="built_in">find</span>(last);</span><br><span class="line">                    <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">                    p[pa]=pb;siz[pb]+=siz[pa];</span><br><span class="line">                &#125; </span><br><span class="line">                last=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pp=<span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,siz[pp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h2><p>计算连通块的数量 $cnt$ ，初始值为 $n$ , 每做一次合并 $cnt-1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="type">int</span> cnt=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(a),pb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">            p[pa]=pb;cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="How-Many-Answers-Are-Wrong"><a href="#How-Many-Answers-Are-Wrong" class="headerlink" title="How Many Answers Are Wrong"></a>How Many Answers Are Wrong</h2><p>维护带权并查集，将闭区间转化为开区间以避免重复，维护区间和的思想类似于前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m, p[<span class="number">200005</span>], d[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;p[i] = i;d[i]=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, dd;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;dd);</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(l - <span class="number">1</span>), pb = <span class="built_in">find</span>(r);</span><br><span class="line">            <span class="keyword">if</span> (pa == pb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[r] - d[l - <span class="number">1</span>] != dd) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[pb] = dd - d[r] + d[l - <span class="number">1</span>];</span><br><span class="line">                p[pb] = pa;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h2><p>维护三种关系的带权并查集，对 3 取模维护关系同类、吃、被吃</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, k, cnt, p[<span class="number">200005</span>], d[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        d[x]%=<span class="number">3</span>;</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;n||y&gt;n||(op==<span class="number">2</span>&amp;&amp;x==y)) cnt++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pa=<span class="built_in">find</span>(x),pb=<span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb&amp;&amp;d[x]-d[y]) cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[pa]=(-d[x]+d[y]+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">                    p[pa]=pb;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pa==pb&amp;&amp;(d[x]-d[y]+<span class="number">3</span>)%<span class="number">3</span>!=<span class="number">2</span>) cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[pa]=(-d[x]+d[y]+<span class="number">2</span>)%<span class="number">3</span>;</span><br><span class="line">                    p[pa]=pb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="True-Liars"><a href="#True-Liars" class="headerlink" title="* True Liars"></a>* True Liars</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 600</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> parent[MAXN], path[MAXN][MAXN], dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];      <span class="comment">//记录大集合的根节点为i的是第num[i]个大集合</span></span><br><span class="line"><span class="type">int</span> flag[MAXN][<span class="number">2</span>];  <span class="comment">//标记每个大集合中选中到最终结果的小集合</span></span><br><span class="line"><span class="type">int</span> cnt[MAXN][<span class="number">2</span>];  <span class="comment">//根节点为i时,分别记录两个小集合包含的人数</span></span><br><span class="line"><span class="type">int</span> relat[MAXN];</span><br><span class="line"><span class="comment">/* relation</span></span><br><span class="line"><span class="comment"> * relat=0/1。0表示i和根节点parent[i]相关联，即属于同一个小集合；1表示i和根节点不关联，即属于同一个大集合中的不同小集合*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != parent[x]) &#123;          <span class="comment">//此处的parent[x]是旧父</span></span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(parent[x]);  <span class="comment">// px是新父</span></span><br><span class="line">        relat[x] ^= relat[parent[x]];</span><br><span class="line">        <span class="comment">/* 由于路径压缩要将x的父亲节点直接指向根节点，即更改了x的父亲节点，所以要更新节点x和根节点的关系。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        parent[x] = px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于&quot;relat[x] ^= relat[parent[x]];&quot;异或解释：</span></span><br><span class="line"><span class="comment">    可以通过简单的分析得出:</span></span><br><span class="line"><span class="comment">        1.如果( relation[x和旧父]=0 &amp;&amp; relation[旧父和新父]=0 )或者(</span></span><br><span class="line"><span class="comment">relation[x和旧父]=1 &amp;&amp; relation[旧父和新父]=1 )，则 relation[x和新父]=0</span></span><br><span class="line"><span class="comment">        2.如果(relation[x和旧父]=1 &amp;&amp; relation[旧父和新父]=0 )或者(</span></span><br><span class="line"><span class="comment">relation[x和旧父]=0 &amp;&amp; relation[旧父和新父]=1 )，则 relation[x和新父]=1</span></span><br><span class="line"><span class="comment">    可以发现，最终relatino[x和新父] = relation[x和旧父] ^ relation[旧父和新父]</span></span><br><span class="line"><span class="comment">        即： relat[x] ^= relat[parent[x]];</span></span><br><span class="line"><span class="comment">对于下面的merge函数中的异或同理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;  <span class="comment">// d要么为0，要么为1</span></span><br><span class="line">    <span class="type">int</span> px = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> py = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">        parent[py] = px;</span><br><span class="line">        relat[py] = relat[x] ^ relat[y] ^ d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, p, q;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;p, &amp;q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m + p + q == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p + q; i++) &#123;  <span class="comment">//**初始话</span></span><br><span class="line">            relat[i] = <span class="number">0</span>;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="type">int</span> x, y, d = <span class="number">1</span>;</span><br><span class="line">            <span class="type">char</span> ch[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;x, &amp;y, ch);</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">                d = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">merge</span>(x, y, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));  <span class="comment">//**num存储集合个数并且给他们编号</span></span><br><span class="line">        <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="built_in">sizeof</span>(path));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p + q; i++) &#123;  <span class="comment">//**统计集合个数并且编号</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) &#123;</span><br><span class="line">                num[i] = ++tot;  <span class="comment">// tot连通块个数，num记录root=i的连通块的编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p + q;</span><br><span class="line">             i++) &#123;  <span class="comment">//**分别统计每个集合两种类的数目并存储到cnt中</span></span><br><span class="line">            cnt[num[<span class="built_in">find</span>(i)]][relat[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;        <span class="comment">// tot=2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = p + q; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// p+q=7</span></span><br><span class="line">                <span class="comment">//**dp[i][j]存储到第i个集合选择种类和为j的方法数</span></span><br><span class="line">                <span class="keyword">if</span> (j - cnt[i][<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]]) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">0</span>]];</span><br><span class="line">                    path[i][j] =</span><br><span class="line">                        cnt[i][<span class="number">0</span>];  <span class="comment">//**path数组记录路径，即选的是1还是0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - cnt[i][<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]]) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - cnt[i][<span class="number">1</span>]];</span><br><span class="line">                    path[i][j] = cnt[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这部分两个if有点难理解，因为可能会想到，两个if都满足的话，那么最后得出的dp[i][j]就有可能存在同一个大集合里面选取了两个小集合的情况，这样就违背了“只从一个大集合选其中一个小集合”的情况。但，可以发现，我们最后限制了方法数是dp[tot][p]=1时，才是有唯一方案的。如果像刚刚说的两个if都满足，那么dp[i][j]一定&gt;1，也就不会符合下面的dp[tot][p]=1限制，所以解决了这个问题。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dp[tot][p] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = tot, j = p; j &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">//**标记路径</span></span><br><span class="line">                <span class="keyword">if</span> (path[i][j] == cnt[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    flag[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j -= path[i][j];</span><br><span class="line">                <span class="comment">//记得减。因为背包时恰好选够p,所以要跟随着p逐次减少当时的物品，找到路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p + q; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag[num[<span class="built_in">find</span>(i)]][relat[i]]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        5 4 3 1 2 yes 1 3 no 4 5 yes 5 6 yes 6 7 no  0 0 0</span></span><br><span class="line"><span class="comment">        6 4 4 1 2 yes 1 3 no 4 5 yes 5 6 yes 6 7 no  7 8 yes 0 0 0</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure>

<h2 id="Supermarket"><a href="#Supermarket" class="headerlink" title="Supermarket"></a>Supermarket</h2><p>类似并查集的操作，通过并查集的方式向前找可用位置，本质是贪心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node n1,node n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1.p&gt;n2.p;    </span><br><span class="line">&#125;</span><br><span class="line">node e[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[u]==<span class="number">-1</span>) <span class="keyword">return</span> u;   </span><br><span class="line">    p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;e[i].p,&amp;e[i].d);</span><br><span class="line">        <span class="built_in">sort</span>(e,e+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) p[i]=<span class="number">-1</span>;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pi=<span class="built_in">find</span>(e[i].d);</span><br><span class="line">            <span class="keyword">if</span>(pi)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=e[i].p;</span><br><span class="line">                p[pi]=pi<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parity-game"><a href="#Parity-game" class="headerlink" title="Parity game"></a>Parity game</h2><p>思路类似 How Many Answers Are Wrong ，转化闭区间为开区间进行前缀和的权值维护，由于数据过大，需要离散化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p[<span class="number">5005</span>],d[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">&#125;q[<span class="number">5005</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="built_in">findp</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x]=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> cur=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5004</span>;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;q[i].l,&amp;q[i].r,q[i].op);</span><br><span class="line">        q[i].l--;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(q[i].l);alls.<span class="built_in">push_back</span>(q[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">findp</span>(<span class="built_in">find</span>(q[i].l)),pb=<span class="built_in">findp</span>(<span class="built_in">find</span>(q[i].r));</span><br><span class="line">        <span class="keyword">if</span>(q[i].op[<span class="number">0</span>]==<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb&amp;&amp;(d[<span class="built_in">find</span>(q[i].r)]-d[<span class="built_in">find</span>(q[i].l)])%<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=i<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">            p[pb]=pa;d[pb]=<span class="number">2</span>-d[<span class="built_in">find</span>(q[i].r)]+d[<span class="built_in">find</span>(q[i].l)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb&amp;&amp;(d[<span class="built_in">find</span>(q[i].r)]-d[<span class="built_in">find</span>(q[i].l)])%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=i<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">continue</span>;</span><br><span class="line">            p[pb]=pa;d[pb]=<span class="number">1</span>-d[<span class="built_in">find</span>(q[i].r)]+d[<span class="built_in">find</span>(q[i].l)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-Bug’s-Life"><a href="#A-Bug’s-Life" class="headerlink" title="A Bug’s Life"></a>A Bug’s Life</h2><p>维护一个 01 带权并查集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p[<span class="number">2005</span>],d[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x]=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;p[i]=i;d[i]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(a),pb=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b])%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            ok=<span class="literal">true</span>;</span><br><span class="line">        p[pa]=pb;d[pa]=<span class="number">1</span>-d[a]+d[b];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ok;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d:\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>()) <span class="built_in">printf</span>(<span class="string">&quot;Suspicious bugs found!\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No suspicious bugs found!\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rochambeau"><a href="#Rochambeau" class="headerlink" title="Rochambeau"></a>Rochambeau</h2><p>和食物链一题类似，对距离模三，维护一个三种类的带权并查集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N], d[N];</span><br><span class="line"><span class="type">int</span> f[N], a[M], b[M];</span><br><span class="line"><span class="type">char</span> c[M];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] = (d[x] + d[p[x]]) % <span class="number">3</span>;</span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//判断第k轮对局是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = a[k], y = b[k]; <span class="comment">//取出两个人</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>; <span class="comment">//记录大小关系，&gt;,&lt; 是 1，= 是0</span></span><br><span class="line">    <span class="keyword">if</span> (c[k] == <span class="string">&#x27;=&#x27;</span>) t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[k] == <span class="string">&#x27;&gt;&#x27;</span>) <span class="built_in">swap</span>(x, y); <span class="comment">//保证 x &lt; y</span></span><br><span class="line">    <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (px == py)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[x] != (d[y] + t) % <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[px] = py;</span><br><span class="line">        d[px] = (d[y] - d[x] + t + <span class="number">3</span>) % <span class="number">3</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;a[i], &amp;c[i], &amp;b[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f); </span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, num = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) p[j] = j, d[j] = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">bool</span> is_umpire = <span class="literal">true</span>; <span class="comment">//记录当前人有没有可能是裁判</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">                <span class="keyword">if</span> (a[j] != i &amp;&amp; b[j] != i &amp;&amp; !<span class="built_in">check</span>(j)) <span class="comment">//如果其他对局中存在矛盾，说明当前人不是裁判</span></span><br><span class="line">                &#123;</span><br><span class="line">                    is_umpire = <span class="literal">false</span>; </span><br><span class="line">                    f[i] = j; <span class="comment">//记录最早确定当前人不是裁判的轮数</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (is_umpire) <span class="comment">//如果当前人可能是裁判</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt++; </span><br><span class="line">                num = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cnt) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Can not determine&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (i != num) </span><br><span class="line">                    res = <span class="built_in">max</span>(res, f[i]); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Player %d can be determined to be the judge after %d lines\n&quot;</span>, num, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Connections-in-Galaxy-War"><a href="#Connections-in-Galaxy-War" class="headerlink" title="Connections in Galaxy War"></a>Connections in Galaxy War</h2><p>类似星球大战一题，并查集对于删边并不容易处理，所以采取离线处理，倒着将删除的边逐渐连接，即建边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m, ask, val[<span class="number">10005</span>], p[<span class="number">10005</span>], d[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> e1[<span class="number">20005</span>], e2[<span class="number">20005</span>];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; st[<span class="number">20005</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">&#125; q[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> px = <span class="built_in">find</span>(x),  py = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(px != py)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[px] &gt; d[py]) p[py] = px;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[py] &gt; d[px]) p[px] = py;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(px &gt; py) p[px] = py;</span><br><span class="line">        <span class="keyword">else</span> p[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> fst=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fst) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        fst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">            p[i] = i; d[i] = val[i]; st[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;e1[i], &amp;e2[i]);</span><br><span class="line">            <span class="keyword">if</span> (e1[i] &gt; e2[i]) <span class="built_in">swap</span>(e1[i], e2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ask);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ask; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, q[i].op, &amp;q[i].u);</span><br><span class="line">            <span class="keyword">if</span> (q[i].op[<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i].v);</span><br><span class="line">                <span class="keyword">if</span> (q[i].u &gt; q[i].v) <span class="built_in">swap</span>(q[i].u, q[i].v);</span><br><span class="line">                st[q[i].u][q[i].v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[e1[i]][e2[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">merge</span>(e1[i],e2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ask; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].op[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].u);</span><br><span class="line">                <span class="keyword">if</span> (d[pa] &gt; d[q[i].u]) ans.<span class="built_in">push_back</span>(pa);</span><br><span class="line">                <span class="keyword">else</span> ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">merge</span>(q[i].u,q[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小希的迷宫"><a href="#小希的迷宫" class="headerlink" title="小希的迷宫"></a>小希的迷宫</h2><p>记录连通块的数量即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> u,v,siz,p[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> ok,st[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100004</span>;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>&amp;&amp;v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">0</span>&amp;&amp;v==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(siz==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(siz!=<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            siz=<span class="number">0</span>;ok=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100004</span>;i++) &#123;p[i]=i;st[i]=<span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st[u]) &#123;siz++;st[u]=<span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!st[v]) &#123;siz++;st[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(u),pb=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) &#123;ok=<span class="literal">true</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        p[pa]=pb;siz--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Is-It-A-Tree"><a href="#Is-It-A-Tree" class="headerlink" title="Is It A Tree?"></a>Is It A Tree?</h2><p>本题与小希的迷宫一题做法相同，唯一区别是本题中的边是有向边，故需要统计入度，含有入度 &gt; 1 的点即表明该图不是树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> u,v,siz,cnt,p[<span class="number">100005</span>],in[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> ok,st[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100004</span>;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>&amp;&amp;v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">0</span>&amp;&amp;v==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ cnt ;</span><br><span class="line">            <span class="keyword">if</span>(siz==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Case %d is a tree.\n&quot;</span>,cnt);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(siz!=<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d is not a tree.\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d is a tree.\n&quot;</span>,cnt);</span><br><span class="line">            siz=<span class="number">0</span>;ok=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100004</span>;i++) &#123;p[i]=i;in[i]=<span class="number">0</span>;st[i]=<span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!st[u]) &#123;siz++;st[u]=<span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!st[v]) &#123;siz++;st[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">        in[v]++;</span><br><span class="line">        <span class="keyword">if</span>(in[v]&gt;<span class="number">1</span>) &#123;ok=<span class="literal">true</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(u),pb=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) &#123;ok=<span class="literal">true</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        p[pa]=pb;siz--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>kaungbin专题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangbin专题十五 数位DP</title>
    <url>/kb15/</url>
    <content><![CDATA[<h1 id="kuangbin专题十五-数位DP"><a href="#kuangbin专题十五-数位DP" class="headerlink" title="kuangbin专题十五 数位DP"></a>kuangbin专题十五 数位DP</h1><h2 id="Beautiful-numbers"><a href="#Beautiful-numbers" class="headerlink" title="Beautiful numbers"></a>Beautiful numbers</h2><p>一个数能被它的所有非零数位整除，则能被它们的最小公倍数整除</p>
<p>状态记录当前位置 $pos$ ，当前数大小 $num$ ，当前数各数位的最小公倍数 $lm$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> aa[<span class="number">22</span>],alls[<span class="number">2525</span>],cnt;</span><br><span class="line">ll dp[<span class="number">22</span>][<span class="number">2525</span>][<span class="number">50</span>],l,r;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> !b?a:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;&#125; </span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> num,<span class="type">int</span> lm,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> num%lm==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[pos][num][alls[lm]]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][num][alls[lm]];</span><br><span class="line">    <span class="type">int</span> end=limit?aa[pos]:<span class="number">9</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,(num*<span class="number">10</span>+i)%<span class="number">2520</span>,i?<span class="built_in">lcm</span>(lm,i):lm,limit&amp;&amp;i==end);</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][num][alls[lm]]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x/=<span class="number">10</span>) aa[++pos]=x%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=<span class="number">2520</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2520</span>%i==<span class="number">0</span>) alls[i]=++cnt,alls[<span class="number">2520</span>/i]=++cnt;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="XHXJ’s-LIS"><a href="#XHXJ’s-LIS" class="headerlink" title="XHXJ’s LIS"></a>XHXJ’s LIS</h2><p>采用状压表示上升子序列 $st$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> K;</span><br><span class="line">ll L,R;</span><br><span class="line">ll dp[<span class="number">20</span>][(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)+<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cnt</span><span class="params">(ll s,ll &amp;k,<span class="type">int</span> id)</span><span class="comment">//记录当前最长上升子序列状态  状压</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=id;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">        &#123;</span><br><span class="line">            pos=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        s|=(<span class="number">1</span>&lt;&lt;id) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s^=(<span class="number">1</span>&lt;&lt;pos);</span><br><span class="line">        s|=(<span class="number">1</span>&lt;&lt;id) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> len,ll s,ll k,<span class="type">int</span> limit,<span class="type">int</span> lead)</span><span class="comment">//limit-当前数位是否可随便取 lead-是否有前导零</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> k==K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[len][s][K]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[len][s][K];<span class="comment">//从当前到后面所有的数位 都可以无限制任意取 则记忆化</span></span><br><span class="line">    <span class="type">int</span> up =limit? num[len] :<span class="number">9</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll tmps=s,tmpk=k;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;lead)<span class="comment">//处理前导零情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmps=<span class="number">0</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmps=<span class="built_in">cnt</span>(tmps,tmpk,i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(len<span class="number">-1</span>,tmps,tmpk,limit&amp;&amp;i==up,lead&amp;&amp;i==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> limit?ans:dp[len][s][K]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        num[++len]=u%<span class="number">10</span>;<span class="comment">//记录每位的最值</span></span><br><span class="line">        u/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp)); <span class="comment">//整个题都可以记忆化</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>,&amp;L,&amp;R,&amp;K);</span><br><span class="line">        ll ans=<span class="built_in">solve</span>(R)-<span class="built_in">solve</span>(L<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,tt++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bomb"><a href="#Bomb" class="headerlink" title="Bomb"></a>Bomb</h2><p>状态记录当前位置 $pos$ ，上一位数字 $pre$ ，是否满足数字要求 $st$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">23</span>];</span><br><span class="line">ll r,dp[<span class="number">23</span>][<span class="number">11</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> pre,<span class="type">bool</span> st,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> st;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[pos][pre][st]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre][st];</span><br><span class="line">    <span class="type">int</span> end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,st||(pre==<span class="number">4</span>&amp;&amp;i==<span class="number">9</span>),limit&amp;&amp;i==end);</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][pre][st]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(<span class="number">0</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Round-Numbers"><a href="#Round-Numbers" class="headerlink" title="Round Numbers"></a>Round Numbers</h2><p>状态记录当前位置 $pos$ ，1 的数量 $one$ ，0 的数量 $zero$ 以及前导零 $lead0$</p>
<p>对于 0 的数量统计，仅将非前导零部分的 0 部分统计</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">35</span>];</span><br><span class="line">ll l,r,dp[<span class="number">35</span>][<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> one,<span class="type">int</span> zero,<span class="type">bool</span> lead0,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> zero&gt;=one;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0&amp;&amp;dp[pos][one][zero]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][one][zero];</span><br><span class="line">    <span class="type">int</span> end=limit?a[pos]:<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,one+(i==<span class="number">1</span>),zero+(lead0&amp;&amp;i==<span class="number">0</span>),lead0||i,limit&amp;&amp;i==a[pos]);</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;lead0) dp[pos][one][zero]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">2</span>;</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Balanced-Number"><a href="#Balanced-Number" class="headerlink" title="Balanced Number"></a>Balanced Number</h2><p>状态记录当前位置 $pos$ ，平衡轴点 $k$ ，力矩和 $sum$</p>
<p>本题关键点在于枚举平衡轴点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">23</span>];</span><br><span class="line">ll l,r,dp[<span class="number">23</span>][<span class="number">23</span>][<span class="number">3000</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> sum==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[pos][k][sum]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][k][sum];</span><br><span class="line">    <span class="type">int</span> end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,k,sum+(pos-k)*i,limit&amp;&amp;i==end);</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][k][sum]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=pos;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos,i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans-pos+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-number"><a href="#B-number" class="headerlink" title="B-number"></a>B-number</h2><p>状态记录当前位置 $pos$ ，前一位数 $pre$ ，数位加和 $sum$ ，子串是否包含 “13” $st$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>];</span><br><span class="line">ll r,dp[<span class="number">13</span>][<span class="number">10</span>][<span class="number">14</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> pre,<span class="type">int</span> sum,<span class="type">bool</span> st,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> st&amp;&amp;(sum%<span class="number">13</span>==<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;dp[pos][pre][sum][st]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre][sum][st];</span><br><span class="line">    <span class="type">int</span> end=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,(sum*<span class="number">10</span>+i)%<span class="number">13</span>,st||(pre==<span class="number">1</span>&amp;&amp;i==<span class="number">3</span>),limit&amp;&amp;i==end);</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][pre][sum][st]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++pos]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r)!=EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-x"><a href="#F-x" class="headerlink" title="F(x)"></a>F(x)</h2><p>状态记录当前位置 $pos$ ，和 $sum$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> val[<span class="number">15</span>],a[<span class="number">15</span>],dp[<span class="number">15</span>][<span class="number">10000</span>];<span class="comment">//值的大概范围：(1&lt;&lt;10)*9 = 1024*9</span></span><br><span class="line"><span class="comment">//val[i]:记录二进制对应位置的值，即 1&lt;&lt;(i-1)</span></span><br><span class="line"><span class="comment">//a数组记录给定数字的所有数位上的值</span></span><br><span class="line"><span class="comment">//dp[i][j]:为非受限时，从i位置到低位中，对应位置函数值不超过j的情况数</span></span><br><span class="line"><span class="type">int</span> all;<span class="comment">//记录限定的函数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算v的函数值</span></span><br><span class="line">    <span class="keyword">if</span>(v&lt;<span class="number">10</span>) <span class="keyword">return</span> v;<span class="comment">//小于10为边界，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cal</span>(v/<span class="number">10</span>)*<span class="number">2</span>+v%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pos为当前位置，lim为当前位置是否受限，sum为当前对应函数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> lim, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) &#123;<span class="comment">//边界位置，判断函数值是否小于对应值</span></span><br><span class="line">        <span class="keyword">return</span> sum&lt;=all;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过对应函数值的，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span>(sum&gt;all) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//非受限并且当前状态已经计算过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!lim&amp;&amp;dp[pos][all-sum]) <span class="keyword">return</span> dp[pos][all-sum];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//累加结果</span></span><br><span class="line">    <span class="type">int</span> siz = lim?a[pos]:<span class="number">9</span>;<span class="comment">//当前位置的范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= siz;i++) &#123;<span class="comment">//遍历所有范围</span></span><br><span class="line">        <span class="comment">//lim参数：当前受限并且值为a[pos]</span></span><br><span class="line">        <span class="comment">//sum参数：累加当前位置 pos 的对应值 i</span></span><br><span class="line">        ans += <span class="built_in">dfs</span>(pos<span class="number">-1</span>, lim&amp;&amp;i==a[pos], sum+i*val[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非受限，记录当前状态值</span></span><br><span class="line">    <span class="keyword">if</span>(!lim) dp[pos][all-sum] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算v的所有数位的值</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(v) &#123;<span class="comment">//从1开始记录</span></span><br><span class="line">        a[++pos] = v%<span class="number">10</span>;</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前位置为pos，当前受限，函数值为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算二进制对应位置的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">15</span>;i++) val[i] = <span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cas = <span class="number">1</span>;cas &lt;= t;cas++) &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">        all = <span class="built_in">cal</span>(a);<span class="comment">//计算限定的函数值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, cas, <span class="built_in">solve</span>(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="恨-7-不成妻"><a href="#恨-7-不成妻" class="headerlink" title="恨 7 不成妻"></a>恨 7 不成妻</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> ll mod=(ll)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">ll bit[maxn],tp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll cnt;     <span class="comment">//满足条件数的个数</span></span><br><span class="line">    ll sum;     <span class="comment">//满足条件的数的和</span></span><br><span class="line">    ll sqsum;   <span class="comment">//满足条件的数的平方的和</span></span><br><span class="line">    <span class="built_in">node</span>(ll _cnt=<span class="number">0</span>,ll _sum=<span class="number">0</span>,ll _sqsum=<span class="number">0</span>):<span class="built_in">cnt</span>(_cnt),<span class="built_in">sum</span>(_sum),<span class="built_in">sqsum</span>(_sqsum)&#123;&#125;</span><br><span class="line">&#125;F[maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">int</span> ori,<span class="type">bool</span> lead,<span class="type">bool</span> limit)</span></span>&#123;   <span class="comment">//枚举位置,每一位加起来的和%7,这个数%7,限制</span></span><br><span class="line">    <span class="comment">//当pos==0时,当sum不是7的倍数,ori不是7的倍数时,上一层的数是合法的,个数记为1返回</span></span><br><span class="line">    <span class="comment">//为什么返回的sum==0,sqsum==0呢？因为这是要返回上一层去算的</span></span><br><span class="line">    node ret, tmp;</span><br><span class="line">    <span class="keyword">if</span>(!pos) <span class="keyword">return</span> <span class="built_in">node</span>((sum&amp;&amp;ori), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; F[pos][sum][ori].cnt != <span class="number">-1</span>) <span class="keyword">return</span> F[pos][sum][ori];</span><br><span class="line">    <span class="type">int</span> endi=limit?bit[pos]:<span class="number">9</span>;</span><br><span class="line">    tmp=<span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= endi; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret = <span class="built_in">dfs</span>(pos<span class="number">-1</span>, (sum+i)%<span class="number">7</span>, (ori*<span class="number">10</span>+i)%<span class="number">7</span>, lead&amp;&amp;!i, limit&amp;&amp;(i==endi));</span><br><span class="line">        tmp.cnt = (tmp.cnt + ret.cnt) % mod;</span><br><span class="line">        tmp.sum = (tmp.sum + ret.sum + ret.cnt * i % mod * tp[pos<span class="number">-1</span>] % mod) % mod;</span><br><span class="line">        tmp.sqsum = (tmp.sqsum + ret.sqsum + <span class="number">2</span> * ret.sum % mod * i % mod * tp[pos<span class="number">-1</span>] % mod) % mod;</span><br><span class="line">        tmp.sqsum = (tmp.sqsum + i * i * tp[pos<span class="number">-1</span>] % mod * tp[pos<span class="number">-1</span>] % mod * ret.cnt % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (!limit&amp;&amp;!lead) ? F[pos][sum][ori] = tmp: tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    bit[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        bit[++bit[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(bit[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>).sqsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(F,<span class="number">-1</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line">    tp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">19</span>; ++i) tp[i]=tp[i<span class="number">-1</span>]*<span class="number">10</span> % mod;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="built_in">solve</span>(R) - <span class="built_in">solve</span>(L<span class="number">-1</span>) + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>kaungbin专题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangbin专题十二 基础DP</title>
    <url>/kb12/</url>
    <content><![CDATA[<h1 id="kuangbin专题十二-基础DP"><a href="#kuangbin专题十二-基础DP" class="headerlink" title="kuangbin专题十二 基础DP"></a>kuangbin专题十二 基础DP</h1>]]></content>
      <categories>
        <category>算法题解</category>
        <category>kaungbin专题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangbin专题七 线段树</title>
    <url>/kb7/</url>
    <content><![CDATA[<h1 id="kuangbin专题七-线段树"><a href="#kuangbin专题七-线段树" class="headerlink" title="kuangbin专题七 线段树"></a>kuangbin专题七 线段树</h1><h2 id="敌兵布阵"><a href="#敌兵布阵" class="headerlink" title="敌兵布阵"></a>敌兵布阵</h2><p>基础线段树模板，维护区间和，单点修改+区间查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;tr[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)</span><br><span class="line">        tr[u].sum+=c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,x,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,c);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,t);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> op[<span class="number">7</span>];<span class="type">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) <span class="built_in">update</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>) <span class="built_in">update</span>(<span class="number">1</span>,l,-r);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-Hate-It"><a href="#I-Hate-It" class="headerlink" title="I Hate It"></a>I Hate It</h2><p>基础线段树模板，维护区间最大值，单点修改+区间查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 998244353</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,ma;</span><br><span class="line">&#125;tr[<span class="number">800010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].ma=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].ma,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].ma=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)</span><br><span class="line">        tr[u].ma=c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,x,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,c);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">        <span class="keyword">return</span> tr[u].ma;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res=<span class="built_in">max</span>(res,<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res=<span class="built_in">max</span>(res,<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> op;<span class="type">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">&#x27;U&#x27;</span>) <span class="built_in">update</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-Simple-Problem-with-Integers"><a href="#A-Simple-Problem-with-Integers" class="headerlink" title="A Simple Problem with Integers"></a>A Simple Problem with Integers</h2><p>基础线段树模板，区间修改+区间查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,a[<span class="number">100005</span>]; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">&#125;tr[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(ll)(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">        tr[u].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;</span><br><span class="line">    tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum+=(ll)(tr[u].r-tr[u].l+<span class="number">1</span>)*d;</span><br><span class="line">        tr[u].add+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid=(tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r,d);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll sum=<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mayor’s-posters"><a href="#Mayor’s-posters" class="headerlink" title="Mayor’s posters"></a>Mayor’s posters</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">question</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;q[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">&#125;tr[<span class="number">160020</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].ok)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].ok=<span class="literal">true</span>;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;tr[u].ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;test %d %d  %d\n&quot;,tr[u].l,tr[u].r,ans);</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].ok) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        tr[u].ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ok1=<span class="literal">false</span>,ok2=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ok1=<span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ok2=<span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    tr[u].ok=tr[u&lt;&lt;<span class="number">1</span>].ok&amp;&amp;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok;</span><br><span class="line">    <span class="keyword">return</span> ok1||ok2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">            alls.<span class="built_in">push_back</span>(q[i].l);</span><br><span class="line">            alls.<span class="built_in">push_back</span>(q[i].r);</span><br><span class="line">            alls.<span class="built_in">push_back</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">            alls.<span class="built_in">push_back</span>(q[i].r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">        alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,alls.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;idx %d   %d %d\n&quot;,i,find(q[i].l),find(q[i].r));</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">update</span>(<span class="number">1</span>,<span class="built_in">find</span>(q[i].l),<span class="built_in">find</span>(q[i].r))) ans++;</span><br><span class="line">            <span class="comment">//printf(&quot;t %d\n&quot;,ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        alls.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Just-a-Hook"><a href="#Just-a-Hook" class="headerlink" title="Just a Hook"></a>Just a Hook</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ask,id,cnt[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">question</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,idx;</span><br><span class="line">&#125;q[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> ok,ook;</span><br><span class="line">&#125;tr[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].ok)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>].ok=<span class="literal">true</span>;</span><br><span class="line">        tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;tr[u].ok=<span class="literal">false</span>;tr[u].ook=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].ok) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u].ook)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[id]+=(tr[u].r-tr[u].l+<span class="number">1</span>);</span><br><span class="line">            tr[u].ok=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    tr[u].ok=tr[u&lt;&lt;<span class="number">1</span>].ok&amp;&amp;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok;</span><br><span class="line">    tr[u].ook=tr[u&lt;&lt;<span class="number">1</span>].ook||tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ook||tr[u&lt;&lt;<span class="number">1</span>].ok||tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[<span class="number">1</span>]=<span class="number">0</span>;cnt[<span class="number">2</span>]=<span class="number">0</span>;cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;ask);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ask;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r,&amp;q[i].idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ask;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            id=q[i].idx;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,q[i].l,q[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;t %d %d %d\n&quot;,n-cnt[2]-cnt[3],cnt[2],cnt[3]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: The total value of the hook is %d.\n&quot;</span>,t,n-cnt[<span class="number">2</span>]-cnt[<span class="number">3</span>]+<span class="number">2</span>*cnt[<span class="number">2</span>]+<span class="number">3</span>*cnt[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Balanced-Lineup"><a href="#Balanced-Lineup" class="headerlink" title="Balanced Lineup"></a>Balanced Lineup</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q,a[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,ma,mi;</span><br><span class="line">&#125;tr[<span class="number">200020</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].ma=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].ma,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ma);</span><br><span class="line">    tr[u].mi=<span class="built_in">min</span>(tr[u&lt;&lt;<span class="number">1</span>].mi,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].ma=a[l];</span><br><span class="line">        tr[u].mi=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].ma;</span><br><span class="line">    <span class="type">int</span> ma=<span class="number">0</span>,mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ma=<span class="built_in">max</span>(ma,<span class="built_in">ask1</span>(u&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ma=<span class="built_in">max</span>(ma,<span class="built_in">ask1</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> ma;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].mi;</span><br><span class="line">    <span class="type">int</span> mi=<span class="number">1e9</span>,mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) mi=<span class="built_in">min</span>(mi,<span class="built_in">ask2</span>(u&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) mi=<span class="built_in">min</span>(mi,<span class="built_in">ask2</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l,r;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask1</span>(<span class="number">1</span>,l,r)-<span class="built_in">ask2</span>(<span class="number">1</span>,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Can-you-answer-these-queries"><a href="#Can-you-answer-these-queries" class="headerlink" title="Can you answer these queries?"></a>Can you answer these queries?</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,q,idx,a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">&#125;tr[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    tr[u].ok=tr[u&lt;&lt;<span class="number">1</span>].ok&amp;&amp;tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l=l;tr[u].r=r;tr[u].ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=a[l];</span><br><span class="line">        <span class="keyword">if</span>(tr[u].sum==<span class="number">1</span>) tr[u].ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r&amp;&amp;tr[u].ok) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum=<span class="built_in">sqrt</span>(tr[u].sum);</span><br><span class="line">        <span class="keyword">if</span>(tr[u].sum==<span class="number">1</span>) tr[u].ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">ask</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%lld:\n&quot;</span>,idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> op,l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="keyword">if</span>(op) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tunnel-Warfare"><a href="#Tunnel-Warfare" class="headerlink" title="Tunnel Warfare"></a>Tunnel Warfare</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> vmax,lmax,rmax;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;<span class="comment">//用来记录上一个被鬼子袭击的村庄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node &amp;root=tr[u],&amp;left=tr[ls],&amp;right=tr[rs];</span><br><span class="line">    root.lmax=left.lmax;</span><br><span class="line">    root.rmax=right.rmax;</span><br><span class="line">    root.vmax=<span class="built_in">max</span>(<span class="built_in">max</span>(left.vmax,right.vmax),left.rmax+right.lmax);</span><br><span class="line">    <span class="keyword">if</span>(left.vmax==left.r-left.l+<span class="number">1</span>) root.lmax+=right.lmax;</span><br><span class="line">    <span class="keyword">if</span>(right.vmax==right.r-right.l+<span class="number">1</span>) root.rmax+=left.rmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//单点修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u]=&#123;x,x,k,k,k&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(ls,x,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rs,x,k);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r) <span class="keyword">return</span> tr[u].vmax;</span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mid-tr[ls].rmax+<span class="number">1</span>&amp;&amp;x&lt;=mid+tr[rs].lmax)<span class="comment">//如果最大子段和横跨两个区间，返回左儿子的最大后缀加上右儿子的最大前缀 </span></span><br><span class="line">    <span class="keyword">return</span> tr[ls].rmax+tr[rs].lmax;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;x;</span><br><span class="line">                s.<span class="built_in">push</span>(x);</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;x;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x)&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>,s.<span class="built_in">top</span>(),<span class="number">1</span>);</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>kaungbin专题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>kuangbin</tag>
      </tags>
  </entry>
</search>
